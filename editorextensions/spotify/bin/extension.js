/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/lucid-extension-sdk/commandtypes.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/commandtypes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ZOrderOperation = exports.isRawSendXHRResponse = exports.GetLLMContextType = exports.GetItemsAtSearchType = exports.HashAlgorithmEnum = exports.commandTitles = void 0;\nconst checks_1 = __webpack_require__(/*! ./core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\n/** @ignore */\nexports.commandTitles = new Map([\n    [\"aci\" /* CommandName.AddCardIntegration */, 'AddCardIntegration'],\n    [\"alta\" /* CommandName.AddLineTextArea */, 'AddLineTextArea'],\n    [\"ami\" /* CommandName.AddMenuItem */, 'AddMenuItem'],\n    [\"asd\" /* CommandName.AddShapeData */, 'AddShapeData'],\n    [\"asi\" /* CommandName.AddSpreadsheetIntegration */, 'AddSpreadsheetIntegration'],\n    [\"atc\" /* CommandName.AddTableColumn */, 'AddTableColumn'],\n    [\"atr\" /* CommandName.AddTableRow */, 'AddTableRow'],\n    [\"a\" /* CommandName.Alert */, 'Alert'],\n    [\"av\" /* CommandName.AnimateViewport */, 'AnimateViewport'],\n    [\"adi\" /* CommandName.AwaitDataSourceImport */, 'AwaitDataSourceImport'],\n    [\"ai\" /* CommandName.AwaitImport */, 'AwaitImport'],\n    [\"b\" /* CommandName.Bootstrap */, 'Bootstrap'],\n    [\"ceps\" /* CommandName.CanEditPackageSettings */, 'CanEditPackageSettings'],\n    [\"cdc\" /* CommandName.CancelDragBlockToCanvas */, 'CancelDragBlockToCanvas'],\n    [\"c\" /* CommandName.Confirm */, 'Confirm'],\n    [\"cb\" /* CommandName.CreateBlock */, 'CreateBlock'],\n    [\"cc\" /* CommandName.CreateCollection */, 'CreateCollection'],\n    [\"cds\" /* CommandName.CreateDataSource */, 'CreateDataSource'],\n    [\"cde\" /* CommandName.CreateDocumentElement */, 'CreateDocumentElement'],\n    [\"cl\" /* CommandName.CreateLine */, 'CreateLine'],\n    [\"cp\" /* CommandName.CreatePage */, 'CreatePage'],\n    [\"die\" /* CommandName.DataItemExists */, 'DataItemExists'],\n    [\"dde\" /* CommandName.DeleteDocumentElement */, 'DeleteDocumentElement'],\n    [\"di\" /* CommandName.DeleteItem */, 'DeleteItem'],\n    [\"dp\" /* CommandName.DeletePage */, 'DeletePage'],\n    [\"dsd\" /* CommandName.DeleteShapeData */, 'DeleteShapeData'],\n    [\"dtc\" /* CommandName.DeleteTableColumn */, 'DeleteTableColumn'],\n    [\"dtr\" /* CommandName.DeleteTableRow */, 'DeleteTableRow'],\n    [\"d\" /* CommandName.Download */, 'Download'],\n    [\"dpm\" /* CommandName.DragPointerMove */, 'DragPointerMove'],\n    [\"dpu\" /* CommandName.DragPointerUp */, 'DragPointerUp'],\n    [\"ee\" /* CommandName.ElementExists */, 'ElementExists'],\n    [\"ef\" /* CommandName.ExecuteFormula */, 'ExecuteFormula'],\n    [\"fas\" /* CommandName.FindAvailableSpace */, 'FindAvailableSpace'],\n    [\"fbe\" /* CommandName.FireBeaconEvent */, 'FireBeaconEvent'],\n    [\"goci\" /* CommandName.GetOAuthClientId */, 'GetOAuthClientId'],\n    [\"gcl\" /* CommandName.GetConnectedLines */, 'GetConnectedLines'],\n    [\"gcp\" /* CommandName.GetCurrentPage */, 'GetCurrentPage'],\n    [\"gcs\" /* CommandName.GetCustomShape */, 'GetCustomShape'],\n    [\"gdif\" /* CommandName.GetDataItemField */, 'GetDataItemField'],\n    [\"gdap\" /* CommandName.GetDocumentAccessPermission */, 'GetDocumentAccessPermission'],\n    [\"gdid\" /* CommandName.GetDocumentId */, 'GetDocumentId'],\n    [\"get\" /* CommandName.GetElementType */, 'GetElementType'],\n    [\"gec\" /* CommandName.GetEnvironmentConfig */, 'GetEnvironmentConfig'],\n    [\"gip\" /* CommandName.GetItemPageId */, 'GetItemPageId'],\n    [\"gia\" /* CommandName.GetItemsAt */, 'GetItemsAt'],\n    [\"llm\" /* CommandName.GetLLMContextFromItems */, 'GetLLMContextFromItems'],\n    [\"got\" /* CommandName.GetOAuthToken */, 'GetOAuthToken'],\n    [\"gps\" /* CommandName.GetPackageSettings */, 'GetPackageSettings'],\n    [\"gpr\" /* CommandName.GetProduct */, 'GetProduct'],\n    [\"gp\" /* CommandName.GetProperty */, 'GetProperty'],\n    [\"grk\" /* CommandName.GetReferenceKey */, 'GetReferenceKey'],\n    [\"grlp\" /* CommandName.GetRelativeLinePosition */, 'GetRelativeLinePosition'],\n    [\"gs\" /* CommandName.GetSelection */, 'GetSelection'],\n    [\"gsd\" /* CommandName.GetShapeData */, 'GetShapeData'],\n    [\"gsvg\" /* CommandName.GetSvg */, 'GetSvg'],\n    [\"gts\" /* CommandName.GetTextStyle */, 'GetTextStyle'],\n    [\"guid\" /* CommandName.GetUserId */, 'GetUserId'],\n    [\"gvr\" /* CommandName.GetVisibleRect */, 'GetVisibleRect'],\n    [\"hm\" /* CommandName.HideModal */, 'HideModal'],\n    [\"hp\" /* CommandName.HidePanel */, 'HidePanel'],\n    [\"hac\" /* CommandName.HookAllChanges */, 'HookAllChanges'],\n    [\"hci\" /* CommandName.HookCreateItems */, 'HookCreateItems'],\n    [\"hdi\" /* CommandName.HookDeleteItems */, 'HookDeleteItems'],\n    [\"hs\" /* CommandName.HookSelection */, 'HookSelection'],\n    [\"hte\" /* CommandName.HookTextEdit */, 'HookTextEdit'],\n    [\"ic\" /* CommandName.ImportCards */, 'ImportCards'],\n    [\"il\" /* CommandName.ImportLinks */, 'ImportLinks'],\n    [\"imp\" /* CommandName.ImportPage */, 'ImportPage'],\n    [\"k\" /* CommandName.KillExtension */, 'KillExtension'],\n    [\"lb\" /* CommandName.ListBlocks */, 'ListBlocks'],\n    [\"lcf\" /* CommandName.ListCollectionFields */, 'ListCollectionFields'],\n    [\"lc\" /* CommandName.ListCollections */, 'ListCollections'],\n    [\"ldi\" /* CommandName.ListDataItems */, 'ListDataItems'],\n    [\"lds\" /* CommandName.ListDataSources */, 'ListDataSources'],\n    [\"lde\" /* CommandName.ListDocumentElements */, 'ListDocumentElements'],\n    [\"lg\" /* CommandName.ListGroups */, 'ListGroups'],\n    [\"ll\" /* CommandName.ListLines */, 'ListLines'],\n    [\"lp\" /* CommandName.ListPages */, 'ListPages'],\n    [\"lpr\" /* CommandName.ListProperties */, 'ListProperties'],\n    [\"lrk\" /* CommandName.ListReferenceKeys */, 'ListReferenceKeys'],\n    [\"lsd\" /* CommandName.ListShapeData */, 'ListShapeData'],\n    [\"lta\" /* CommandName.ListTextAreas */, 'ListTextAreas'],\n    [\"lbc\" /* CommandName.LoadBlockClasses */, 'LoadBlockClasses'],\n    [\"log\" /* CommandName.LogForTestCase */, 'LogForTestCase'],\n    [\"mt\" /* CommandName.MeasureText */, 'MeasureText'],\n    [\"oi\" /* CommandName.OffsetItems */, 'OffsetItems'],\n    [\"pdi\" /* CommandName.PatchDataItems */, 'PatchDataItems'],\n    [\"p\" /* CommandName.Prompt */, 'Prompt'],\n    [\"rp\" /* CommandName.RegisterPanel */, 'RegisterPanel'],\n    [\"ru\" /* CommandName.RegisterUnfurl */, 'RegisterUnfurl'],\n    [\"r\" /* CommandName.ReloadExtension */, 'ReloadExtension'],\n    [\"oauth\" /* CommandName.SendOAuthRequest */, 'SendOAuthRequest'],\n    [\"aoauth\" /* CommandName.SendAsyncOAuthRequest */, 'SendAsyncOAuthRequest'],\n    [\"suim\" /* CommandName.SendUIMessage */, 'SendUIMessage'],\n    [\"xhr\" /* CommandName.SendXHR */, 'SendXHR'],\n    [\"scp\" /* CommandName.SetCurrentPage */, 'SetCurrentPage'],\n    [\"sps\" /* CommandName.SetPackageSettings */, 'SetPackageSettings'],\n    [\"sp\" /* CommandName.SetProperty */, 'SetProperty'],\n    [\"srk\" /* CommandName.SetReferenceKey */, 'SetReferenceKey'],\n    [\"ss\" /* CommandName.SetSelection */, 'SetSelection'],\n    [\"ssd\" /* CommandName.SetShapeData */, 'SetShapeData'],\n    [\"sts\" /* CommandName.SetTextStyle */, 'SetTextStyle'],\n    [\"sm\" /* CommandName.ShowModal */, 'ShowModal'],\n    [\"spsm\" /* CommandName.ShowPackageSettingsModal */, 'ShowPackageSettingsModal'],\n    [\"spn\" /* CommandName.ShowPanel */, 'ShowPanel'],\n    [\"sleep\" /* CommandName.SleepForTestCase */, 'SleepForTestCase'],\n    [\"sdc\" /* CommandName.StartDragBlockToCanvas */, 'StartDragBlockToCanvas'],\n    [\"pdf\" /* CommandName.StartPDFUploadRequest */, 'StartPDFUploadRequest'],\n    [\"throw\" /* CommandName.ThrowForTestCase */, 'ThrowForTestCase'],\n    [\"tauth\" /* CommandName.TriggerAuthFlow */, 'TriggerAuthFlow'],\n    [\"uac\" /* CommandName.UnhookAllChanges */, 'UnhookAllChanges'],\n    [\"uci\" /* CommandName.UnhookCreateItems */, 'UnhookCreateItems'],\n    [\"udi\" /* CommandName.UnhookDeleteItems */, 'UnhookDeleteItems'],\n    [\"us\" /* CommandName.UnhookSelection */, 'UnhookSelection'],\n    [\"ute\" /* CommandName.UnhookTextEdit */, 'UnhookTextEdit'],\n    [\"wm\" /* CommandName.WithMutex */, 'WithMutex'],\n    [\"wsa\" /* CommandName.WithSilentActions */, 'WithSilentActions'],\n    [\"z\" /* CommandName.ZOrder */, 'ZOrder'],\n]);\nvar HashAlgorithmEnum;\n(function (HashAlgorithmEnum) {\n    /** Use the SHA 256 hashing algorithm */\n    HashAlgorithmEnum[\"sha256\"] = \"SHA256\";\n})(HashAlgorithmEnum || (exports.HashAlgorithmEnum = HashAlgorithmEnum = {}));\nvar GetItemsAtSearchType;\n(function (GetItemsAtSearchType) {\n    GetItemsAtSearchType[GetItemsAtSearchType[\"PossiblyOverlapping\"] = 0] = \"PossiblyOverlapping\";\n    GetItemsAtSearchType[GetItemsAtSearchType[\"Overlapping\"] = 1] = \"Overlapping\";\n    GetItemsAtSearchType[GetItemsAtSearchType[\"Contained\"] = 2] = \"Contained\";\n})(GetItemsAtSearchType || (exports.GetItemsAtSearchType = GetItemsAtSearchType = {}));\nvar GetLLMContextType;\n(function (GetLLMContextType) {\n    /** Get context in a format for LLMs where relationships among connected and\n     * contained items are preserved. Expand the scope of the selection to\n     * include blocks contained by the selection as well as lines connecting\n     * items in the selection. */\n    GetLLMContextType[GetLLMContextType[\"Relational\"] = 1] = \"Relational\";\n    /** Get context containing only plain text displayed on the given items, more suitable for embeddings */\n    GetLLMContextType[GetLLMContextType[\"PlainText\"] = 2] = \"PlainText\";\n    /** Get context in a format for LLMs where relationships among connected and\n     * contained items are preserved. Do not expand the scope of the selection,\n     * other than to ensure relationships are represented. Text on selected\n     * items will be included, but text on automatically added items will not.\n     * */\n    GetLLMContextType[GetLLMContextType[\"RelationalWithoutExpansion\"] = 3] = \"RelationalWithoutExpansion\";\n})(GetLLMContextType || (exports.GetLLMContextType = GetLLMContextType = {}));\nfunction isRawSendXHRResponse(val) {\n    return (0, checks_1.isString)(val['url']) && (0, checks_1.isString)(val['t']) && (0, checks_1.isNumber)(val['s']) && (0, checks_1.isObject)(val['h']);\n}\nexports.isRawSendXHRResponse = isRawSendXHRResponse;\nvar ZOrderOperation;\n(function (ZOrderOperation) {\n    ZOrderOperation[ZOrderOperation[\"UP\"] = 1] = \"UP\";\n    ZOrderOperation[ZOrderOperation[\"TOP\"] = 2] = \"TOP\";\n    ZOrderOperation[ZOrderOperation[\"DOWN\"] = 3] = \"DOWN\";\n    ZOrderOperation[ZOrderOperation[\"BOTTOM\"] = 4] = \"BOTTOM\";\n})(ZOrderOperation || (exports.ZOrderOperation = ZOrderOperation = {}));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/commandtypes.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/base64.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/base64.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodeBase64 = exports.decodeBase64 = void 0;\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n//This gives a ~8x speedup vs. using alphabet.indexOf() in the main decode loop.\nconst charCodeToEncodedInt = [];\nfor (let i = 0; i < alphabet.length; i++) {\n    charCodeToEncodedInt[alphabet.charCodeAt(i)] = i;\n}\nfunction decodeBase64(base64String) {\n    //Filter out whitespace, etc\n    base64String = base64String.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n    if (base64String.length % 4 !== 0) {\n        throw new Error('Invalid base64 input; length must be a multiple of 4');\n    }\n    //4 characters of input turns into 3 bytes of output\n    let bytes = (base64String.length / 4) * 3;\n    //But each trailing = (up to 2) is one fewer byte of output\n    if (base64String.endsWith('==')) {\n        bytes -= 2;\n    }\n    else if (base64String.endsWith('=')) {\n        bytes -= 1;\n    }\n    const output = new Uint8Array(bytes);\n    let inputIndex = 0;\n    for (let outputIndex = 0; outputIndex < bytes; outputIndex += 3) {\n        //Get the 4 numbers 0-63 encoded in the next 4 characters\n        const enc1 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];\n        const enc2 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];\n        const enc3 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];\n        const enc4 = charCodeToEncodedInt[base64String.charCodeAt(inputIndex++)];\n        if (enc1 === undefined || enc2 === undefined || enc3 === undefined || enc4 === undefined) {\n            throw new Error('char code to encoded int contains an undefined index');\n        }\n        //Read 8 total bits into each of the output values. Skip one byte\n        //for each padding = at the end of the string\n        output[outputIndex] = (enc1 << 2) | (enc2 >> 4);\n        if (enc3 != 64) {\n            output[outputIndex + 1] = ((enc2 & 15) << 4) | (enc3 >> 2);\n        }\n        if (enc4 != 64) {\n            output[outputIndex + 2] = ((enc3 & 3) << 6) | enc4;\n        }\n    }\n    return output;\n}\nexports.decodeBase64 = decodeBase64;\nfunction encodeBase64(byteArray) {\n    // 3 bytes of input become 4 chars of output\n    // i.e. every 6 bits of input becomes 1 char of output\n    const fullByteChunkCount = Math.floor(byteArray.length / 3);\n    const outputLength = Math.ceil(byteArray.length / 3) * 4;\n    const output = new Array(outputLength);\n    let inputIndex = 0;\n    let outputIndex = 0;\n    for (let byteChunkIndex = 0; byteChunkIndex < fullByteChunkCount; byteChunkIndex++) {\n        const byte1 = byteArray[inputIndex++];\n        const byte2 = byteArray[inputIndex++];\n        const byte3 = byteArray[inputIndex++];\n        if (byte1 === undefined || byte2 === undefined || byte3 === undefined) {\n            throw new Error('byteArray contains undefined indexes');\n        }\n        const enc1 = byte1 >> 2; // first 6 bits of byte1\n        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4); // last 2 bits of byte1 and first 4 bits of byte2\n        const enc3 = ((byte2 & 15) << 2) | (byte3 >> 6); // last 4 bits of byte2 and first 2 bits of byte3\n        const enc4 = byte3 & 63; // last 6 bits of byte3\n        output[outputIndex++] = alphabet[enc1];\n        output[outputIndex++] = alphabet[enc2];\n        output[outputIndex++] = alphabet[enc3];\n        output[outputIndex++] = alphabet[enc4];\n    }\n    // handle remainder, i.e. trailing one or two bytes\n    if (inputIndex < byteArray.length) {\n        const byte1 = byteArray[inputIndex++];\n        const hasSecondByte = inputIndex < byteArray.length;\n        const byte2 = hasSecondByte ? byteArray[inputIndex++] : 0;\n        const enc1 = byte1 >> 2; // first 6 bits of byte1\n        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4); // last 2 bits of byte1 and first 4 bits of byte2\n        const enc3 = hasSecondByte ? (byte2 & 15) << 2 : 64; // last 4 bits of byte2\n        output[outputIndex++] = alphabet[enc1];\n        output[outputIndex++] = alphabet[enc2];\n        output[outputIndex++] = alphabet[enc3];\n        output[outputIndex++] = '=';\n    }\n    return output.join('');\n}\nexports.encodeBase64 = encodeBase64;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/base64.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidCardFields = exports.StatusValues = exports.deserializeLucidCardFieldDisplaySettings = exports.serializeLucidCardFieldDisplaySettings = exports.isOnClickHandlerKey = exports.OnClickHandlerKeys = exports.isFieldDisplayType = exports.FieldDisplayType = void 0;\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/**\n * When configuring a field on a LucidCardBlock to be displayed as a data graphic, one of these values specifies\n * the function to convert the field value to the data graphic settings. The definition of these functions is in\n * LucidCardsLibrary.registerStencilDisplayTypes.\n */\nvar FieldDisplayType;\n(function (FieldDisplayType) {\n    /**\n     * Text badge with the full text of the field.\n     * Black text on a light gray background in the upper-right of the card.\n     */\n    FieldDisplayType[\"BasicTextBadge\"] = \"BasicTextBadge\";\n    /**\n     * Given a name (usually of a user), puts a text badge with their initials (first letter of each name)\n     * at the bottom-left of the card, black text on a light gray background.\n     */\n    FieldDisplayType[\"InitializedString\"] = \"InitializedString\";\n    /**\n     * Given a number, display the number in the bottom-left of the card. If the number is higher than 999,\n     * display 999.\n     */\n    FieldDisplayType[\"StandardEstimation\"] = \"StandardEstimation\";\n    /**\n     * Given a URL, display a small image cropped into a circle in the lower-left of the card.\n     */\n    FieldDisplayType[\"ImageBadge\"] = \"ImageBadge\";\n    /**\n     * Given a URL, display a small image cropped into a square in the lower-left of the card.\n     */\n    FieldDisplayType[\"SquareImageBadge\"] = \"SquareImageBadge\";\n    /**\n     * Given a date, display a small calendar icon alongside a very short version of the date\n     * as a string, e.g. \"Sep 9\"\n     */\n    FieldDisplayType[\"DateBadge\"] = \"DateBadge\";\n    /** Given an object containing iconUrl (optional) and name (optional), determine whether\n     * to display as an ImageBadge or InitializedString (or nothing, if neither is present).\n     */\n    FieldDisplayType[\"UserProfile\"] = \"UserProfile\";\n})(FieldDisplayType || (exports.FieldDisplayType = FieldDisplayType = {}));\nexports.isFieldDisplayType = (0, validators_1.enumValidator)(FieldDisplayType);\n/**\n * When configuring a field on a LucidCardBlock to be displayed as a data graphic, this click handler value\n * specifies what to do when the user clicks on the data graphic produced.\n */\nvar OnClickHandlerKeys;\n(function (OnClickHandlerKeys) {\n    /**\n     * Display the UI panel to edit fields on the data associated with the card\n     */\n    OnClickHandlerKeys[\"BasicEditPanel\"] = \"BasicEditPanel\";\n    /**\n     * Open a new browser window to a URL specified by linkFormula\n     */\n    OnClickHandlerKeys[\"OpenBrowserWindow\"] = \"OpenBrowserWindow\";\n    /**\n     * Display a custom UI panel to edit non-standard fields on the data associated with the card\n     */\n    OnClickHandlerKeys[\"CustomEditAction\"] = \"CustomEditAction\";\n})(OnClickHandlerKeys || (exports.OnClickHandlerKeys = OnClickHandlerKeys = {}));\nexports.isOnClickHandlerKey = (0, validators_1.enumValidator)(OnClickHandlerKeys);\n/** @ignore */\nfunction serializeLucidCardFieldDisplaySettings(settings) {\n    return {\n        'StencilConfig': settings.stencilConfig && {\n            'getterKey': settings.stencilConfig.displayType,\n            'f': settings.stencilConfig.valueFormula,\n            't': settings.stencilConfig.tooltipFormula,\n            'l': settings.stencilConfig.linkFormula,\n            'fg': settings.stencilConfig.foregroundColor,\n            'bg': settings.stencilConfig.backgroundColor,\n            'h': settings.stencilConfig.horizontalPosition,\n            'v': settings.stencilConfig.verticalPosition,\n            'onClickHandlerKey': settings.stencilConfig.onClickHandlerKey,\n            'imageBadgeSettings': settings.stencilConfig.imageBadgeSettings,\n            'textBadgeSettings': settings.stencilConfig.textBadgeSettings,\n        },\n    };\n}\nexports.serializeLucidCardFieldDisplaySettings = serializeLucidCardFieldDisplaySettings;\n/** @ignore */\nfunction deserializeLucidCardFieldDisplaySettings(settings) {\n    return {\n        stencilConfig: settings['StencilConfig'] && {\n            displayType: settings['StencilConfig']['getterKey'],\n            valueFormula: settings['StencilConfig']['f'],\n            tooltipFormula: settings['StencilConfig']['t'],\n            linkFormula: settings['StencilConfig']['l'],\n            foregroundColor: settings['StencilConfig']['fg'],\n            backgroundColor: settings['StencilConfig']['bg'],\n            horizontalPosition: settings['StencilConfig']['h'],\n            verticalPosition: settings['StencilConfig']['v'],\n            onClickHandlerKey: settings['StencilConfig']['onClickHandlerKey'],\n            imageBadgeSettings: settings['StencilConfig']['imageBadgeSettings'],\n            textBadgeSettings: settings['StencilConfig']['textBadgeSettings'],\n        },\n    };\n}\nexports.deserializeLucidCardFieldDisplaySettings = deserializeLucidCardFieldDisplaySettings;\n/**\n * These are the three possible values for the status of a basic card block.\n */\nvar StatusValues;\n(function (StatusValues) {\n    StatusValues[\"Todo\"] = \"To Do\";\n    StatusValues[\"InProgress\"] = \"In Progress\";\n    StatusValues[\"Done\"] = \"Done\";\n})(StatusValues || (exports.StatusValues = StatusValues = {}));\nvar LucidCardFields;\n(function (LucidCardFields) {\n    LucidCardFields[\"Title\"] = \"Title\";\n    LucidCardFields[\"Description\"] = \"Description\";\n    LucidCardFields[\"Assignee\"] = \"Assignee\";\n    LucidCardFields[\"Estimate\"] = \"Estimate\";\n    LucidCardFields[\"Status\"] = \"Status\";\n    LucidCardFields[\"StartTime\"] = \"StartTime\";\n    LucidCardFields[\"EndTime\"] = \"EndTime\";\n})(LucidCardFields || (exports.LucidCardFields = LucidCardFields = {}));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeCardIntegrationConfig = exports.serializeCardIntegrationConfig = void 0;\nconst cardfielddisplaysettings_1 = __webpack_require__(/*! ./cardfielddisplaysettings */ \"./node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js\");\n/** @ignore */\nfunction serializeCardIntegrationConfig(config) {\n    return {\n        'cc': {\n            'f': config.cardConfig.fieldNames,\n            'fd': config.cardConfig.fieldDisplaySettings\n                ? [...config.cardConfig.fieldDisplaySettings].map(([key, settings]) => [\n                    key,\n                    (0, cardfielddisplaysettings_1.serializeLucidCardFieldDisplaySettings)(settings),\n                ])\n                : undefined,\n            'fs': config.cardConfig.fieldStyles ? [...config.cardConfig.fieldStyles] : undefined,\n        },\n        'cdpc': {\n            'f': config.cardDetailsPanelConfig.fields.map((field) => {\n                return {\n                    'n': field.name,\n                    'l': field.locked,\n                };\n            }),\n        },\n    };\n}\nexports.serializeCardIntegrationConfig = serializeCardIntegrationConfig;\n/** @ignore */\nfunction deserializeCardIntegrationConfig(raw) {\n    return {\n        cardConfig: {\n            fieldNames: raw['cc']['f'],\n            fieldStyles: raw['cc']['fs'] ? new Map(raw['cc']['fs']) : undefined,\n            fieldDisplaySettings: raw['cc']['fd']\n                ? new Map(raw['cc']['fd'].map(([key, settings]) => [\n                    key,\n                    (0, cardfielddisplaysettings_1.deserializeLucidCardFieldDisplaySettings)(settings),\n                ]))\n                : undefined,\n        },\n        cardDetailsPanelConfig: {\n            fields: raw['cdpc']['f'].map((field) => {\n                return {\n                    name: field['n'],\n                    locked: field['l'],\n                };\n            }),\n        },\n    };\n}\nexports.deserializeCardIntegrationConfig = deserializeCardIntegrationConfig;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationdefinitions.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationdefinitions.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeCardFieldArrayDefinition = exports.deserializeCardFieldDefinition = exports.isSerializedExtensionCardFieldDefinition = exports.isSerializedFieldOptions = exports.isSerializedFieldOption = exports.deserializeFieldOption = exports.serializeCardFieldArrayDefinition = exports.serializeCardFieldDefinition = exports.serializeCardFieldOption = void 0;\nconst schemadefinition_1 = __webpack_require__(/*! ../../data/schemadefinition */ \"./node_modules/lucid-extension-sdk/data/schemadefinition.js\");\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../data/fieldtypedefinition/fieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst serializedfielddefinition_1 = __webpack_require__(/*! ../data/serializedfield/serializedfielddefinition */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js\");\nconst serializedfields_1 = __webpack_require__(/*! ../data/serializedfield/serializedfields */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/** @ignore */\nfunction serializeCardFieldOption(option) {\n    return {\n        'l': option.label,\n        'v': option.value,\n        'i': option.iconUrl,\n    };\n}\nexports.serializeCardFieldOption = serializeCardFieldOption;\n/** @ignore */\nfunction serializeCardFieldDefinition(field) {\n    var _a;\n    return Object.assign(Object.assign({}, (0, schemadefinition_1.serializeFieldDefinition)(field)), { 'l': field.label, 'def': field.default, 'd': field.description, 'op': (0, checks_1.isString)(field.options) ? field.options : (_a = field.options) === null || _a === void 0 ? void 0 : _a.map(serializeCardFieldOption), 's': field.search });\n}\nexports.serializeCardFieldDefinition = serializeCardFieldDefinition;\n/** @ignore */\nfunction serializeCardFieldArrayDefinition(fields) {\n    return fields.map(serializeCardFieldDefinition);\n}\nexports.serializeCardFieldArrayDefinition = serializeCardFieldArrayDefinition;\n/** @ignore */\nfunction deserializeFieldOption(option) {\n    return {\n        label: option['l'],\n        value: option['v'],\n        iconUrl: option['i'],\n    };\n}\nexports.deserializeFieldOption = deserializeFieldOption;\nexports.isSerializedFieldOption = (0, validators_1.objectValidator)({\n    'l': checks_1.isString,\n    'v': serializedfields_1.isSerializedFieldType,\n    'i': (0, validators_1.option)(checks_1.isString),\n});\nexports.isSerializedFieldOptions = (0, validators_1.arrayValidator)(exports.isSerializedFieldOption);\n/** @ignore */\nexports.isSerializedExtensionCardFieldDefinition = (0, validators_1.objectValidator)({\n    'Name': checks_1.isString,\n    'Type': fieldtypedefinition_1.isSerializedFieldTypeDefinition,\n    'Constraints': (0, validators_1.option)((0, validators_1.arrayValidator)(serializedfielddefinition_1.isSerializedFieldConstraint)),\n    'l': checks_1.isString,\n    'd': (0, validators_1.option)(checks_1.isString),\n    'def': (0, validators_1.option)(serializedfields_1.isSerializedFieldType),\n    'op': (0, validators_1.option)((0, validators_1.either)(checks_1.isString, (0, validators_1.arrayValidator)(exports.isSerializedFieldOption))),\n    's': (0, validators_1.option)(checks_1.isString),\n});\n/** @ignore */\nfunction deserializeCardFieldDefinition(field) {\n    var _a;\n    return Object.assign(Object.assign({}, (0, schemadefinition_1.parseFieldDefinition)(field)), { label: field['l'], description: field['d'], default: field['def'], options: (0, checks_1.isString)(field['op']) ? field['op'] : (_a = field['op']) === null || _a === void 0 ? void 0 : _a.map(deserializeFieldOption), search: field['s'] });\n}\nexports.deserializeCardFieldDefinition = deserializeCardFieldDefinition;\n/** @ignore */\nfunction deserializeCardFieldArrayDefinition(fields) {\n    return fields.map(deserializeCardFieldDefinition);\n}\nexports.deserializeCardFieldArrayDefinition = deserializeCardFieldArrayDefinition;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationdefinitions.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegration.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegration.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidCardIntegration = void 0;\nclass LucidCardIntegration {\n    constructor(client) {\n        this.client = client;\n    }\n    showCardImport(name) {\n        return this.client.sendCommand(\"ic\" /* CommandName.ImportCards */, name);\n    }\n}\nexports.LucidCardIntegration = LucidCardIntegration;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegration.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationregistry.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationregistry.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidCardIntegrationRegistry = void 0;\nconst collectiondefinition_1 = __webpack_require__(/*! ../../data/collectiondefinition */ \"./node_modules/lucid-extension-sdk/data/collectiondefinition.js\");\nconst datasourceproxy_1 = __webpack_require__(/*! ../../data/datasourceproxy */ \"./node_modules/lucid-extension-sdk/data/datasourceproxy.js\");\nconst cardintegrationconfig_1 = __webpack_require__(/*! ./cardintegrationconfig */ \"./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js\");\nconst cardintegrationdefinitions_1 = __webpack_require__(/*! ./cardintegrationdefinitions */ \"./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationdefinitions.js\");\nclass LucidCardIntegrationRegistry {\n    static nextHookName() {\n        return '__lucidcard__hook' + LucidCardIntegrationRegistry.nextHookId++;\n    }\n    static registerFieldOptionsCallback(client, callback) {\n        const name = LucidCardIntegrationRegistry.nextHookName();\n        client.registerAction(name, async ({ 'i': inputSoFar }) => {\n            const result = await callback(new Map(inputSoFar));\n            return result.map((option) => (0, cardintegrationdefinitions_1.serializeCardFieldOption)(option));\n        });\n        return name;\n    }\n    static registerFieldSearchCallback(client, callback) {\n        const name = LucidCardIntegrationRegistry.nextHookName();\n        client.registerAction(name, async ({ 'i': inputSoFar, 's': searchText }) => {\n            const result = await callback(searchText, new Map(inputSoFar));\n            return result.map((option) => (0, cardintegrationdefinitions_1.serializeCardFieldOption)(option));\n        });\n        return name;\n    }\n    /**\n     * Register a card integration.\n     */\n    static addCardIntegration(client, cardIntegration) {\n        const getFieldsActionName = LucidCardIntegrationRegistry.nextHookName();\n        client.registerAction(getFieldsActionName, async (param) => {\n            const dataSource = new datasourceproxy_1.DataSourceProxy(param['d'], client);\n            const fields = await cardIntegration.fieldConfiguration.getAllFields(dataSource);\n            return fields;\n        });\n        let onSelectedFieldsChangeActionName = undefined;\n        const onSelectedFieldsChange = cardIntegration.fieldConfiguration.onSelectedFieldsChange;\n        if (onSelectedFieldsChange) {\n            onSelectedFieldsChangeActionName = LucidCardIntegrationRegistry.nextHookName();\n            client.registerAction(onSelectedFieldsChangeActionName, async (param) => {\n                const dataSource = new datasourceproxy_1.DataSourceProxy(param['ds'], client);\n                await onSelectedFieldsChange(dataSource, param['sf']);\n            });\n        }\n        const getDefaultConfigActionName = LucidCardIntegrationRegistry.nextHookName();\n        client.registerAction(getDefaultConfigActionName, async (param) => {\n            const dataSource = new datasourceproxy_1.DataSourceProxy(param['d'], client);\n            return (0, cardintegrationconfig_1.serializeCardIntegrationConfig)(await cardIntegration.getDefaultConfig(dataSource));\n        });\n        let showIntroActionName = undefined;\n        if (cardIntegration.showIntro) {\n            showIntroActionName = LucidCardIntegrationRegistry.nextHookName();\n            client.registerAction(showIntroActionName, cardIntegration.showIntro);\n        }\n        const serialized = {\n            'n': cardIntegration.label,\n            'dcn': cardIntegration.dataConnectorName,\n            'il': cardIntegration.itemLabel,\n            'isl': cardIntegration.itemsLabel,\n            'u': cardIntegration.iconUrl,\n            'ts': cardIntegration.textStyle,\n            'fc': {\n                'gf': getFieldsActionName,\n                'osfc': onSelectedFieldsChangeActionName,\n                'fvsc': cardIntegration.fieldConfiguration.fieldValueSearchCallbacks\n                    ? [...cardIntegration.fieldConfiguration.fieldValueSearchCallbacks.entries()]\n                    : undefined,\n            },\n            'gdc': getDefaultConfigActionName,\n            'i': showIntroActionName,\n        };\n        if (cardIntegration.importModal) {\n            const importModal = cardIntegration.importModal;\n            serialized['im'] = {\n                'gsf': LucidCardIntegrationRegistry.nextHookName(),\n                's': LucidCardIntegrationRegistry.nextHookName(),\n                'i': LucidCardIntegrationRegistry.nextHookName(),\n                'os': importModal.onSetup ? LucidCardIntegrationRegistry.nextHookName() : undefined,\n            };\n            client.registerAction(serialized['im']['gsf'], async ({ 's': searchSoFar }) => {\n                const result = await importModal.getSearchFields(new Map(searchSoFar));\n                return (0, cardintegrationdefinitions_1.serializeCardFieldArrayDefinition)(result);\n            });\n            client.registerAction(serialized['im']['s'], async ({ 's': param }) => {\n                const result = await importModal.search(new Map(param));\n                return {\n                    'd': (0, collectiondefinition_1.serializeCollectionDefinition)(result.data),\n                    'f': (0, cardintegrationdefinitions_1.serializeCardFieldArrayDefinition)(result.fields),\n                    'm': result.partialImportMetadata && {\n                        'cid': result.partialImportMetadata.collectionId,\n                        'sid': result.partialImportMetadata.syncDataSourceId,\n                    },\n                };\n            });\n            client.registerAction(serialized['im']['i'], async ({ 'pks': primaryKeys, 's': searchFields }) => {\n                const result = await importModal.import(primaryKeys, new Map(searchFields));\n                return {\n                    'c': result.collection.id,\n                    'pks': result.primaryKeys,\n                };\n            });\n            if (serialized['im']['os']) {\n                client.registerAction(serialized['im']['os'], async () => {\n                    var _a;\n                    await ((_a = importModal.onSetup) === null || _a === void 0 ? void 0 : _a.call(importModal));\n                });\n            }\n        }\n        if (cardIntegration.addCard) {\n            const addCard = cardIntegration.addCard;\n            serialized['ac'] = {\n                'gif': LucidCardIntegrationRegistry.nextHookName(),\n                'cc': LucidCardIntegrationRegistry.nextHookName(),\n            };\n            client.registerAction(serialized['ac']['gif'], async ({ 'i': inputSoFar }) => {\n                const result = await addCard.getInputFields(new Map(inputSoFar));\n                return (0, cardintegrationdefinitions_1.serializeCardFieldArrayDefinition)(result);\n            });\n            client.registerAction(serialized['ac']['cc'], async ({ 'i': input }) => {\n                const result = await addCard.createCardData(new Map(input));\n                return {\n                    'c': result.collection.id,\n                    'pk': result.primaryKey,\n                };\n            });\n        }\n        client.sendCommand(\"aci\" /* CommandName.AddCardIntegration */, serialized);\n    }\n}\nexports.LucidCardIntegrationRegistry = LucidCardIntegrationRegistry;\nLucidCardIntegrationRegistry.nextHookId = 0;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationregistry.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/checks.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/checks.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isInstanceOf = exports.isLiteral = exports.isPromise = exports.isUnknown = exports.isAny = exports.isEmptyOrNullishObject = exports.isAtLeastLength = exports.isExactLength = exports.isTypedArray = exports.isArray = exports.isRecord = exports.isObjectUnsafer = exports.isObjectUnsafe = exports.isObject = exports.isFunction = exports.isInfinite = exports.isInt = exports.isNumber = exports.isBoolean = exports.isString = exports.isNullish = exports.isDefAndNotNull = exports.isVoid = exports.isUndefined = exports.isNull = exports.isDef = void 0;\n/**\n * Returns true if the specified value is not undefined.\n *\n * @param val Variable to test.\n * @return Whether variable is defined.\n */\nfunction isDef(val) {\n    return val !== undefined;\n}\nexports.isDef = isDef;\n/**\n * Returns true if the specified value is null.\n * @param val Variable to test.\n * @return Whether variable is null.\n */\nfunction isNull(val) {\n    return val === null;\n}\nexports.isNull = isNull;\n/**\n * Returns true if the specified value is undefined.\n * @param val Variable to test.\n * @return Whether variable is undefined.\n */\nfunction isUndefined(val) {\n    return val === undefined;\n}\nexports.isUndefined = isUndefined;\n/**\n * Returns true if the specified value is undefined.\n * @param val Variable to test.\n * @return Whether variable is undefined.\n */\nfunction isVoid(x) {\n    return x === undefined;\n}\nexports.isVoid = isVoid;\n/**\n * Returns true if the specified value is defined and not null.\n * @param val Variable to test.\n * @return Whether variable is defined and not null.\n */\nfunction isDefAndNotNull(val) {\n    return val != null;\n}\nexports.isDefAndNotNull = isDefAndNotNull;\n/**\n * Returns true if the specified value is null or undefined.\n * @param val Variable to test\n * @return Whether the variable is null or undefined.\n */\nfunction isNullish(val) {\n    return val == null;\n}\nexports.isNullish = isNullish;\n/**\n * Returns true if the specified value is a string.\n * @param val Variable to test.\n * @return Whether variable is a string.\n */\nfunction isString(val) {\n    return typeof val == 'string';\n}\nexports.isString = isString;\n/**\n * Returns true if the specified value is a boolean.\n * @param val Variable to test.\n * @return Whether variable is boolean.\n */\nfunction isBoolean(val) {\n    return typeof val == 'boolean';\n}\nexports.isBoolean = isBoolean;\n/**\n * Returns true if the specified value is a number.\n * @param val Variable to test.\n * @return Whether variable is a number.\n */\nfunction isNumber(val) {\n    return typeof val == 'number';\n}\nexports.isNumber = isNumber;\n/**\n * Returns true if the specified value is an integer.\n * @param val Variable to test.\n * @return Whether variable is an integer.\n */\nfunction isInt(val) {\n    return isNumber(val) && isFinite(val) && val % 1 == 0;\n}\nexports.isInt = isInt;\n/**\n * Returns true if the specified value is either positive or negative infinity.\n * @param val Variable to test.\n * @returns Whether variable is positive or negative infinity.\n */\nfunction isInfinite(val) {\n    return isNumber(val) && !isNaN(val) && !isFinite(val);\n}\nexports.isInfinite = isInfinite;\nfunction isFunction(val) {\n    return typeof val === 'function';\n}\nexports.isFunction = isFunction;\n/**\n * Returns true if the specified value is an object (including arrays and functions) (i.e. it's safe to do property accesses on it).\n *\n * @param val Variable to test.\n * @return Whether variable is an object.\n */\nfunction isObject(val) {\n    const type = typeof val;\n    return (type == 'object' && val != null) || type == 'function';\n}\nexports.isObject = isObject;\n/**\n * Returns true for objects, includings arrays and functions.\n * Matches the behavior of goog.isObject, with a more permissive type.\n *\n * @param val Variable to test.\n * @return Whether variable is an object.\n */\nfunction isObjectUnsafe(val) {\n    const type = typeof val;\n    return (type == 'object' && val != null) || type == 'function';\n}\nexports.isObjectUnsafe = isObjectUnsafe;\n/**\n * Returns true for objects, includings arrays and functions.\n * Matches the behavior of goog.isObject, with an extremely permissive type.\n *\n * @param val Variable to test.\n * @return Whether variable is an object.\n */\nfunction isObjectUnsafer(val) {\n    const type = typeof val;\n    return (type == 'object' && val != null) || type == 'function';\n}\nexports.isObjectUnsafer = isObjectUnsafer;\n/**\n * Returns true if the specified value is an object (i.e. it's safe to do property accesses on it),\n * and every value matches the record type.\n *\n * @param val Variable to test.\n * @return Whether variable is an object.\n */\nfunction isRecord(typeGuard) {\n    return function (val) {\n        return isObject(val) && Object.values(val).every(typeGuard);\n    };\n}\nexports.isRecord = isRecord;\n/**\n * Returns true if the specified value is an array.\n *\n * This is safer than using Array.isArray directly because it doesn't introduce an `any` type.\n * @param val Variable to test.\n * @return Whether variable is an array.\n */\nfunction isArray(val) {\n    return Array.isArray(val);\n}\nexports.isArray = isArray;\n/**\n * Returns true if the specified value is an array and every element passes the type guard function.\n *\n * @param val Variable to test.\n * @param typeGuard the type guard function to test every element in the array.\n * @return Whether variable is an array of the given type.\n */\nfunction isTypedArray(typeGuard) {\n    return function (val) {\n        return isArray(val) && val.every(typeGuard);\n    };\n}\nexports.isTypedArray = isTypedArray;\nfunction isExactLength(arr, exactLength) {\n    return arr.length === exactLength;\n}\nexports.isExactLength = isExactLength;\nfunction isAtLeastLength(arr, minimumLength) {\n    return arr.length >= minimumLength;\n}\nexports.isAtLeastLength = isAtLeastLength;\n/**\n * Returns true if the specified object is either empty or all existing keys map to a nullish value\n *\n * @param val Variable to test\n * @return Whether variable is empty or maps exclusively to nullish values\n */\nfunction isEmptyOrNullishObject(val) {\n    return !(val &&\n        typeof val === 'object' &&\n        Object.keys(val).find((key) => isDefAndNotNull(val[key])));\n}\nexports.isEmptyOrNullishObject = isEmptyOrNullishObject;\n/**\n * @deprecated Prefer isUnknown\n */\nfunction isAny(val) {\n    return true;\n}\nexports.isAny = isAny;\nfunction isUnknown(val) {\n    return true;\n}\nexports.isUnknown = isUnknown;\nfunction isPromise(val) {\n    return isObjectUnsafe(val) && isFunction(val['then']) && isFunction(val['catch']);\n}\nexports.isPromise = isPromise;\nfunction isLiteral(t) {\n    return (x) => x === t;\n}\nexports.isLiteral = isLiteral;\n/**\n * Since `instanceof` should generally be avoided, this function should generally be avoided as well.\n *\n * A valid use case is for native types, like Uint8Array.\n */\nfunction isInstanceOf(klass) {\n    return (x) => x instanceof klass;\n}\nexports.isInstanceOf = isInstanceOf;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/checks.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/alphabet.js":
/*!***************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/alphabet.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.alphabet = void 0;\nexports.alphabet = [\n    'A',\n    'B',\n    'C',\n    'D',\n    'E',\n    'F',\n    'G',\n    'H',\n    'I',\n    'J',\n    'K',\n    'L',\n    'M',\n    'N',\n    'O',\n    'P',\n    'Q',\n    'R',\n    'S',\n    'T',\n    'U',\n    'V',\n    'W',\n    'X',\n    'Y',\n    'Z',\n];\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/datasource/alphabet.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataSourceType = void 0;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nvar DataSourceType;\n(function (DataSourceType) {\n    DataSourceType[DataSourceType[\"GoogleSheets\"] = 0] = \"GoogleSheets\";\n    DataSourceType[DataSourceType[\"CSV\"] = 1] = \"CSV\";\n    DataSourceType[DataSourceType[\"Excel\"] = 2] = \"Excel\";\n    DataSourceType[DataSourceType[\"Salesforce\"] = 3] = \"Salesforce\";\n    DataSourceType[DataSourceType[\"Generator\"] = 4] = \"Generator\";\n    DataSourceType[DataSourceType[\"DataService\"] = 5] = \"DataService\";\n    DataSourceType[DataSourceType[\"ForeignKeyOverride\"] = 7] = \"ForeignKeyOverride\";\n    DataSourceType[DataSourceType[\"Extension\"] = 8] = \"Extension\";\n    DataSourceType[DataSourceType[\"Unknown\"] = 9] = \"Unknown\";\n})(DataSourceType || (exports.DataSourceType = DataSourceType = {}));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/datasourceutils.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/datasourceutils.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.makeSerializedImportedDataSource = exports.makeSerializedImportedCollection = exports.MetadataPK = exports.makeNameReadablyUnique = exports.normalizeName = exports.alphabetize = void 0;\nconst dataupdatefiltertype_1 = __webpack_require__(/*! ../../../data/dataupdatefiltertype */ \"./node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js\");\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst scalarfieldtype_1 = __webpack_require__(/*! ../fieldtypedefinition/scalarfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nconst alphabet_1 = __webpack_require__(/*! ./alphabet */ \"./node_modules/lucid-extension-sdk/core/data/datasource/alphabet.js\");\nconst datasourcetype_1 = __webpack_require__(/*! ./datasourcetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js\");\nconst spreadsheetpossibledatatypes_1 = __webpack_require__(/*! ./spreadsheetpossibledatatypes */ \"./node_modules/lucid-extension-sdk/core/data/datasource/spreadsheetpossibledatatypes.js\");\nconst upstreamupdatetype_1 = __webpack_require__(/*! ./upstreamupdatetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js\");\n/** @ignore */\nfunction _alphabetize(n) {\n    if (n == undefined || n < 0) {\n        return '';\n    }\n    else if (n < alphabet_1.alphabet.length) {\n        return alphabet_1.alphabet[n];\n    }\n    else {\n        return alphabetize(Math.floor(n / alphabet_1.alphabet.length) - 1) + alphabetize(n % alphabet_1.alphabet.length);\n    }\n}\n/** @ignore */\nconst memoize = new Map();\n/** @ignore */\nfunction alphabetize(n) {\n    const stored = memoize.get(n);\n    if (stored != null) {\n        return stored;\n    }\n    const value = _alphabetize(n);\n    memoize.set(n, value);\n    return value;\n}\nexports.alphabetize = alphabetize;\n/** @ignore */\nfunction normalizeName(name) {\n    return name.trim().toLowerCase();\n}\nexports.normalizeName = normalizeName;\nconst appendedNumberRegex = /(.*) \\(([0-9]+)\\)$/;\n/** @ignore */\nfunction makeNameReadablyUnique(originalName, usedNamesNormalized, transform = normalizeName) {\n    if (!usedNamesNormalized.has(transform(originalName))) {\n        return originalName;\n    }\n    const match = appendedNumberRegex.exec(originalName);\n    let count = 1;\n    if (match && (0, checks_1.isString)(match[1]) && (0, checks_1.isString)(match[2])) {\n        originalName = match[1];\n        count = Number(match[2]) + 1;\n    }\n    let newName = originalName;\n    do {\n        newName = originalName + ` (${count})`;\n        count++;\n    } while (usedNamesNormalized.has(transform(newName)));\n    return newName;\n}\nexports.makeNameReadablyUnique = makeNameReadablyUnique;\n/** @ignore */\nexports.MetadataPK = '__PK__';\n/** @ignore */\nfunction makePrimaryCollectionSchema(rawSchemaFields, data, schemaFromData) {\n    var _a, _b;\n    const headerRow = (_a = schemaFromData === null || schemaFromData === void 0 ? void 0 : schemaFromData.headerRow) !== null && _a !== void 0 ? _a : -1;\n    const headerRowData = headerRow >= 0 ? data[headerRow] : undefined;\n    const headerRowAsStringArray = headerRowData &&\n        rawSchemaFields.map((rawSchemaField, index) => {\n            var _a;\n            const headerRowDataAsString = `${(_a = headerRowData[rawSchemaField]) !== null && _a !== void 0 ? _a : ''}`;\n            return headerRowDataAsString.trim() === '' ? alphabetize(index) : headerRowDataAsString;\n        });\n    const schemaFields = headerRowAsStringArray !== null && headerRowAsStringArray !== void 0 ? headerRowAsStringArray : rawSchemaFields;\n    const fields = [];\n    const oldToNewFields = new Map();\n    const usedFieldsNormalized = new Set([normalizeName(exports.MetadataPK)]);\n    schemaFields.forEach((field, index) => {\n        const finalFieldName = makeNameReadablyUnique(field, usedFieldsNormalized);\n        usedFieldsNormalized.add(normalizeName(finalFieldName));\n        fields.push({ 'Name': finalFieldName, 'Type': spreadsheetpossibledatatypes_1.SpreadSheetPossibleDataTypes });\n        oldToNewFields.set(rawSchemaFields[index], finalFieldName);\n    });\n    const oldPrimaryKeys = (_b = schemaFromData === null || schemaFromData === void 0 ? void 0 : schemaFromData.primaryKey) !== null && _b !== void 0 ? _b : [];\n    const translatedPrimaryKeys = oldPrimaryKeys\n        .map((oldPrimaryKey) => oldToNewFields.get(oldPrimaryKey))\n        .filter(checks_1.isDefAndNotNull); // There should be no untranslatable primary keys, but we need to satisfy the type system\n    return {\n        sheetSchema: {\n            'Fields': fields,\n            'PrimaryKey': translatedPrimaryKeys,\n        },\n        oldToNewFields,\n    };\n}\nfunction getPrimaryKeysForData(oldToNewFields, data, schemaFromData) {\n    if (!schemaFromData || schemaFromData.primaryKey.length === 0) {\n        return data.map((row, index) => `${index + 1}`);\n    }\n    const primaryKey = schemaFromData.primaryKey;\n    const primaryKeyInNewFields = primaryKey.map((oldField) => { var _a; return (_a = oldToNewFields.get(oldField)) !== null && _a !== void 0 ? _a : oldField; });\n    // For reasons I have forgotten, the actual primary key order is determined by the alphabetized name order.\n    const sortedPrimaryKeyInNewFields = primaryKeyInNewFields.slice().sort();\n    const sortedPrimaryKey = sortedPrimaryKeyInNewFields.map((newField) => primaryKey[primaryKeyInNewFields.indexOf(newField)]);\n    const usedNames = new Set();\n    return data.map((serializedField) => {\n        const primaryKeyValues = sortedPrimaryKey.map((key) => serializedField[key]);\n        const compositeValue = JSON.stringify(primaryKeyValues);\n        const nameWithoutContext = compositeValue.slice(1, compositeValue.length - 1);\n        let name = nameWithoutContext;\n        let dupCount = -1;\n        while (usedNames.has(name)) {\n            name = `${nameWithoutContext},${++dupCount}`;\n        }\n        usedNames.add(name);\n        return name;\n    });\n}\n/** @ignore */\nfunction makeMetadataCollection(metadataType, sheetName, dataItems, sheetSchema) {\n    return {\n        'Name': sheetName + '|' + metadataType,\n        'Schema': sheetSchema,\n        'Items': dataItems,\n    };\n}\n/** @ignore */\nfunction makeItemOrderCollection(primaryKeys, sheetName, headerRow) {\n    const itemOrderItems = {};\n    let rowIndex = 0;\n    for (let i = 0; i < primaryKeys.length; i++) {\n        const primaryKey = primaryKeys[i];\n        if (i !== headerRow) {\n            rowIndex++;\n            itemOrderItems[`${rowIndex}`] = { 'Key': `${primaryKey}`, 'Order': rowIndex };\n        }\n    }\n    const itemOrderSchema = {\n        'Fields': [\n            { 'Name': 'Key', 'Type': scalarfieldtype_1.ScalarFieldTypeEnum.STRING },\n            { 'Name': 'Order', 'Type': scalarfieldtype_1.ScalarFieldTypeEnum.NUMBER },\n        ],\n        'PrimaryKey': ['Order'],\n    };\n    return makeMetadataCollection('ItemOrder', sheetName, itemOrderItems, itemOrderSchema);\n}\n/** @ignore */\nfunction makeHeaderrowMetadataCollection(headerRowPrimaryKey, headerRowData, oldToNewFields, sheetName, schema) {\n    const dataItem = {};\n    for (const [key, field] of Object.entries(headerRowData)) {\n        const newKey = oldToNewFields.get(key);\n        if (newKey) {\n            dataItem[newKey] = field;\n        }\n    }\n    const itemOrderItems = {\n        [headerRowPrimaryKey]: dataItem,\n    };\n    return makeMetadataCollection('HeaderRowMetadata', sheetName, itemOrderItems, schema);\n}\n/** @ignore */\nfunction makeSerializedItems(primaryKeys, rawItems, oldToNewFields, headerRow, isMetadata = false) {\n    const serializedItems = {};\n    rawItems.forEach((rawItem, rowIndex) => {\n        if (isMetadata || rowIndex !== headerRow) {\n            const dataItem = {};\n            for (const [key, field] of Object.entries(rawItem)) {\n                const newKey = oldToNewFields.get(key);\n                if (newKey) {\n                    dataItem[newKey] = field;\n                }\n            }\n            const primaryKey = primaryKeys[rowIndex];\n            if (isMetadata && Object.keys(dataItem).length > 0) {\n                const metadataPrimaryKey = `${primaryKey}`;\n                dataItem[exports.MetadataPK] = metadataPrimaryKey;\n                serializedItems[`${JSON.stringify(metadataPrimaryKey)}`] = dataItem;\n            }\n            else if (!isMetadata) {\n                serializedItems[primaryKey] = dataItem;\n            }\n        }\n    });\n    return serializedItems;\n}\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nfunction makeSerializedImportedCollection(name, rawFieldNames, data, upstreamConfig, dataIsPartial, metadata, schemaFromData) {\n    var _a;\n    const { sheetSchema, oldToNewFields } = makePrimaryCollectionSchema(rawFieldNames, data, schemaFromData);\n    const primaryKeys = getPrimaryKeysForData(oldToNewFields, data, schemaFromData);\n    const headerRow = (_a = schemaFromData === null || schemaFromData === void 0 ? void 0 : schemaFromData.headerRow) !== null && _a !== void 0 ? _a : -1;\n    const metadataCollections = {};\n    metadataCollections['ItemOrder'] = makeItemOrderCollection(primaryKeys, name, headerRow);\n    if (headerRow > -1 && headerRow < data.length) {\n        const headerRowData = data[headerRow];\n        const headerRowPrimaryKey = primaryKeys[headerRow];\n        metadataCollections['HeaderRowMetadata'] = makeHeaderrowMetadataCollection(headerRowPrimaryKey, headerRowData, oldToNewFields, name, sheetSchema);\n    }\n    if (metadata) {\n        const metadataFields = [{ 'Name': exports.MetadataPK, 'Type': scalarfieldtype_1.ScalarFieldTypeEnum.STRING }];\n        sheetSchema['Fields'].forEach((field) => metadataFields.push({\n            'Name': field['Name'],\n            'Type': [scalarfieldtype_1.ScalarFieldTypeEnum.STRING, scalarfieldtype_1.ScalarFieldTypeEnum.NULL],\n        }));\n        const metadataSchema = { 'Fields': metadataFields, 'PrimaryKey': [exports.MetadataPK] };\n        for (const [type, data] of Object.entries(metadata)) {\n            metadataCollections[type] = makeMetadataCollection(type, name, makeSerializedItems(primaryKeys, data, oldToNewFields, headerRow, true), metadataSchema);\n        }\n    }\n    return {\n        'Name': name,\n        'Schema': sheetSchema,\n        'Items': makeSerializedItems(primaryKeys, data, oldToNewFields, headerRow),\n        'UpstreamConfig': upstreamConfig,\n        'Metadata': metadataCollections,\n        'DataIsPartial': dataIsPartial,\n    };\n}\nexports.makeSerializedImportedCollection = makeSerializedImportedCollection;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nfunction makeSerializedImportedDataSource(id, name, collections) {\n    return {\n        'Properties': {\n            'Name': name,\n            'UpstreamConfig': {\n                'SourceType': datasourcetype_1.DataSourceType.DataService,\n                'UpdateType': upstreamupdatetype_1.UpstreamUpdateType.EVENTPULL,\n                'SourceConfig': {\n                    'spreadsheetId': id,\n                    'UpdateFilterType': dataupdatefiltertype_1.DataUpdateFilterType.CurrentCollectionUpdates,\n                },\n            },\n        },\n        'Collections': collections,\n    };\n}\nexports.makeSerializedImportedDataSource = makeSerializedImportedDataSource;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/datasource/datasourceutils.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/metadatatypes.js":
/*!********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/metadatatypes.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MetadataTypes = void 0;\n// Google Sheets has both notes and comments, we store notes in the comment metadata collection. Comments are not\n// meant to be permanent in Google Sheets whereas they are in Excel, resulting in some confusion with our naming.\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nvar MetadataTypes;\n(function (MetadataTypes) {\n    MetadataTypes[\"Format\"] = \"Format\";\n    MetadataTypes[\"FillColor\"] = \"FillColor\";\n    MetadataTypes[\"TextColor\"] = \"TextColor\";\n    MetadataTypes[\"Comment\"] = \"Comment\";\n    MetadataTypes[\"Formula\"] = \"Formula\";\n    MetadataTypes[\"HeaderRowMetadata\"] = \"HeaderRowMetadata\";\n})(MetadataTypes || (exports.MetadataTypes = MetadataTypes = {}));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/datasource/metadatatypes.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/serializeddatasourceproperties.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/serializeddatasourceproperties.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedDataSourceProperties = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst serializedupstreamconfig_1 = __webpack_require__(/*! ./serializedupstreamconfig */ \"./node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js\");\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isSerializedDataSourceProperties = (0, validators_1.strictObjectValidator)({\n    'Name': checks_1.isString,\n    'UpstreamConfig': (0, validators_1.nullableOption)(serializedupstreamconfig_1.isSerializedUpstreamConfig),\n});\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/datasource/serializeddatasourceproperties.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/serializedimporteddatasource.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/serializedimporteddatasource.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedImportedDataSource = exports.isSerializedImportedCollection = exports.isSerializedImportedMetadataCollection = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst serializeddataitems_1 = __webpack_require__(/*! ../serializedfield/serializeddataitems */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializeddataitems.js\");\nconst serializedschema_1 = __webpack_require__(/*! ../serializedfield/serializedschema */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js\");\nconst serializeddatasourceproperties_1 = __webpack_require__(/*! ./serializeddatasourceproperties */ \"./node_modules/lucid-extension-sdk/core/data/datasource/serializeddatasourceproperties.js\");\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isSerializedImportedMetadataCollection = (0, validators_1.strictObjectValidator)({\n    'Name': checks_1.isString,\n    'Schema': serializedschema_1.isSerializedSchema,\n    'Items': serializeddataitems_1.isSerializedDataItems,\n});\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isSerializedImportedCollection = (0, validators_1.strictObjectValidator)({\n    'Name': checks_1.isString,\n    'Schema': serializedschema_1.isSerializedSchema,\n    'Items': serializeddataitems_1.isSerializedDataItems,\n    'UpstreamConfig': checks_1.isObject,\n    'Metadata': (0, checks_1.isRecord)(exports.isSerializedImportedMetadataCollection),\n    'DataIsPartial': (0, validators_1.option)(validators_1.isTrue),\n});\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isSerializedImportedDataSource = (0, validators_1.strictObjectValidator)({\n    'Properties': serializeddatasourceproperties_1.isSerializedDataSourceProperties,\n    'Collections': (0, checks_1.isTypedArray)(exports.isSerializedImportedCollection),\n});\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/datasource/serializedimporteddatasource.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedUpstreamConfig = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst datasourcetype_1 = __webpack_require__(/*! ./datasourcetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js\");\nconst upstreampatchtype_1 = __webpack_require__(/*! ./upstreampatchtype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js\");\nconst upstreamupdatetype_1 = __webpack_require__(/*! ./upstreamupdatetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js\");\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.isSerializedUpstreamConfig = (0, validators_1.strictObjectValidator)({\n    'SourceType': (0, validators_1.enumValidator)(datasourcetype_1.DataSourceType),\n    'UpdateType': (0, validators_1.enumValidator)(upstreamupdatetype_1.UpstreamUpdateType),\n    'PatchType': (0, validators_1.nullableOption)((0, validators_1.enumValidator)(upstreampatchtype_1.UpstreamPatchType)),\n    'SourceConfig': checks_1.isObject,\n});\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/spreadsheetpossibledatatypes.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/spreadsheetpossibledatatypes.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SpreadSheetPossibleDataTypes = void 0;\nconst scalarfieldtype_1 = __webpack_require__(/*! ../fieldtypedefinition/scalarfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nexports.SpreadSheetPossibleDataTypes = [\n    scalarfieldtype_1.ScalarFieldTypeEnum.BOOLEAN,\n    scalarfieldtype_1.ScalarFieldTypeEnum.NUMBER,\n    scalarfieldtype_1.ScalarFieldTypeEnum.STRING,\n    scalarfieldtype_1.ScalarFieldTypeEnum.NULL,\n    scalarfieldtype_1.ScalarFieldTypeEnum.CURRENCY,\n    scalarfieldtype_1.ScalarFieldTypeEnum.DATE,\n    scalarfieldtype_1.ScalarFieldTypeEnum.COLOR,\n];\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/datasource/spreadsheetpossibledatatypes.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/upstreamconfig.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/upstreamconfig.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedSourceConfig = exports.deserializeUpstreamConfig = exports.serializeUpstreamConfig = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nfunction serializeUpstreamConfig(config) {\n    return {\n        'SourceType': config.dataSourceType,\n        'UpdateType': config.updateType,\n        'PatchType': config.patchType,\n        'SourceConfig': config.sourceConfig,\n    };\n}\nexports.serializeUpstreamConfig = serializeUpstreamConfig;\nfunction deserializeUpstreamConfig(config) {\n    return {\n        dataSourceType: config['SourceType'],\n        updateType: config['UpdateType'],\n        patchType: config['PatchType'] === null ? undefined : config['PatchType'],\n        sourceConfig: config['SourceConfig'],\n    };\n}\nexports.deserializeUpstreamConfig = deserializeUpstreamConfig;\nfunction isSerializedSourceConfig(x) {\n    return (0, checks_1.isObject)(x);\n}\nexports.isSerializedSourceConfig = isSerializedSourceConfig;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/datasource/upstreamconfig.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js":
/*!************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UpstreamPatchType = void 0;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nvar UpstreamPatchType;\n(function (UpstreamPatchType) {\n    UpstreamPatchType[UpstreamPatchType[\"NONE\"] = 0] = \"NONE\";\n    UpstreamPatchType[UpstreamPatchType[\"MANUAL\"] = 2] = \"MANUAL\";\n    UpstreamPatchType[UpstreamPatchType[\"AUTO\"] = 3] = \"AUTO\";\n})(UpstreamPatchType || (exports.UpstreamPatchType = UpstreamPatchType = {}));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UpstreamUpdateType = void 0;\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nvar UpstreamUpdateType;\n(function (UpstreamUpdateType) {\n    UpstreamUpdateType[UpstreamUpdateType[\"NONE\"] = 0] = \"NONE\";\n    UpstreamUpdateType[UpstreamUpdateType[\"PULL\"] = 1] = \"PULL\";\n    UpstreamUpdateType[UpstreamUpdateType[\"USER\"] = 2] = \"USER\";\n    UpstreamUpdateType[UpstreamUpdateType[\"EVENTPULL\"] = 3] = \"EVENTPULL\";\n})(UpstreamUpdateType || (exports.UpstreamUpdateType = UpstreamUpdateType = {}));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldspecification.js":
/*!**************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldspecification.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FormattedPrimaryKey = exports.declareSchema = void 0;\nfunction isArrayAndAssertReadonly(val) {\n    return Array.isArray(val);\n}\n/**\n * Specifies all the fields that this itegration will be sending to the data-sync service.\n * Give you well typed methods to convert from `YourType[]` to `{[PrimaryKey:string]: YourType}`\n * which is what most of the data sync service calls expect.\n *\n * There is fromItems which does the above will full type information, and fromItems sparse\n * which allows all the fields not part of the primaryKey to be undefined. The former should\n * be used with initial imports, and the latter can be used for updates.\n */\nfunction declareSchema({ primaryKey, fields }) {\n    const primaryKeyObj = new FormattedPrimaryKey(...primaryKey);\n    return {\n        example: fields,\n        array: Object.entries(fields).map(([name, { type, constraints, mapping }]) => {\n            return {\n                'name': name,\n                'type': isArrayAndAssertReadonly(type) ? type.slice() : type,\n                'constraints': constraints,\n                'mapping': mapping,\n            };\n        }),\n        primaryKey: primaryKeyObj,\n        fromItemsSparse: (items) => {\n            return new Map(items.map((item) => [primaryKeyObj.forItem(item), item]));\n        },\n        fromItems: (items) => {\n            return new Map(items.map((item) => [primaryKeyObj.forItem(item), item]));\n        },\n    };\n}\nexports.declareSchema = declareSchema;\n/**\n * Generates a mapper that, given a primary key definition is able to produce the primary key for that item.\n **/\nclass FormattedPrimaryKey {\n    constructor(...elements) {\n        this.elements = [...elements].sort();\n    }\n    /**\n     * Generate the serialized form of the item's primary key.\n     *\n     * For single value primary keys, the encoded values are just the json representation of the primary\n     * key. For example, if the primary key is ['id'] the following table shows encodings:\n     *\n     * | type    | value     | encoded                            |\n     * |---------|-----------|------------------------------------|\n     * | number  | `15`      | `new Map([[\"15\", ...], ...])`      |\n     * | boolean | `false`   | `new Map([[\"false\", ...], ...])`   |\n     * | string  | `\"hello\"` | `new Map([['\"hello\"', ...], ...])` |\n     *\n     * Take note of the extra quotes in the string case.\n     *\n     * For primary keys with multiple values, first sort the array of primary keys then join the json encoded values\n     * from of the keys with commas. For example:\n     *\n     * ```\n     * primary key = [\"lastName\", \"firstName\"]\n     * sorted key = [\"firstName\", \"lastName\"]\n     * row = {\"lastName\": \"Smith\", \"firstName\": \"John\", \"age\": 42}\n     * row key = '\"John\",\"Smith\"'\n     * items = new Map([['\"John\",\"Smith\"', {\"lastName\": \"Smith\", \"firstName\": \"John\", \"age\": 42}]])\n     * ```\n     */\n    forItem(item) {\n        let pk = JSON.stringify(this.elements.map((field) => item[field]));\n        pk = pk.substring(1, pk.length - 1);\n        return pk;\n    }\n}\nexports.FormattedPrimaryKey = FormattedPrimaryKey;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/fieldspecification.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/basefieldtypedefinition.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/basefieldtypedefinition.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedBaseFieldTypeDefinition = exports.deserializeBaseFieldTypeDefinition = exports.serializeBaseFieldTypeDefinition = exports.isBaseFieldTypeDefinition = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst collectionenumfieldtype_1 = __webpack_require__(/*! ./collectionenumfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js\");\nconst fieldtypearray_1 = __webpack_require__(/*! ./fieldtypearray */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js\");\nconst literalfieldtype_1 = __webpack_require__(/*! ./literalfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js\");\nconst ndimensionalfieldtypearray_1 = __webpack_require__(/*! ./ndimensionalfieldtypearray */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js\");\nconst scalarfieldtype_1 = __webpack_require__(/*! ./scalarfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nfunction isBaseFieldTypeDefinition(fieldType) {\n    return ((0, scalarfieldtype_1.isScalarFieldTypeEnum)(fieldType) ||\n        (0, literalfieldtype_1.isLiteralFieldType)(fieldType) ||\n        fieldType instanceof fieldtypearray_1.FieldTypeArray ||\n        fieldType instanceof ndimensionalfieldtypearray_1.NDimensionalFieldTypeArray ||\n        (0, collectionenumfieldtype_1.isCollectionEnumFieldType)(fieldType));\n}\nexports.isBaseFieldTypeDefinition = isBaseFieldTypeDefinition;\nfunction serializeBaseFieldTypeDefinition(baseFieldType) {\n    // Unfortunately there's no easy way to do goog.DEBUG checks inside lucid-extension-sdk right now.\n    // if (goog.DEBUG && !isBaseFieldTypeDefinition(baseFieldType)) {\n    //     throw new Error(`Passed non-BaseFieldTypeDefinition into serializeBaseFieldTypeDefinition()!`);\n    // }\n    if (baseFieldType instanceof literalfieldtype_1.LiteralFieldType ||\n        baseFieldType instanceof fieldtypearray_1.FieldTypeArray ||\n        baseFieldType instanceof ndimensionalfieldtypearray_1.NDimensionalFieldTypeArray ||\n        baseFieldType instanceof collectionenumfieldtype_1.CollectionEnumFieldType) {\n        return baseFieldType.toJSON();\n    }\n    return baseFieldType;\n}\nexports.serializeBaseFieldTypeDefinition = serializeBaseFieldTypeDefinition;\nfunction deserializeBaseFieldTypeDefinition(baseFieldType) {\n    if ((0, literalfieldtype_1.isSerializedLiteralFieldType)(baseFieldType)) {\n        return (0, literalfieldtype_1.deserializeLiteralFieldType)(baseFieldType);\n    }\n    if ((0, collectionenumfieldtype_1.isSerializedCollectionEnumFieldType)(baseFieldType)) {\n        return (0, collectionenumfieldtype_1.deserializeCollectionEnumFieldType)(baseFieldType);\n    }\n    if ((0, fieldtypearray_1.isSerializedFieldTypeArray)(baseFieldType, isSerializedBaseFieldTypeDefinition)) {\n        return (0, fieldtypearray_1.deserializeFieldTypeArray)(baseFieldType);\n    }\n    if ((0, ndimensionalfieldtypearray_1.isSerializedNDimensionalFieldTypeArray)(baseFieldType)) {\n        return (0, ndimensionalfieldtypearray_1.deserializeNDimensionalFieldTypeArray)(baseFieldType);\n    }\n    return baseFieldType;\n}\nexports.deserializeBaseFieldTypeDefinition = deserializeBaseFieldTypeDefinition;\nfunction isSerializedBaseFieldTypeDefinition(definition) {\n    return ((0, checks_1.isDefAndNotNull)(scalarfieldtype_1.ScalarFieldTypeEnum[definition]) ||\n        (0, literalfieldtype_1.isSerializedLiteralFieldType)(definition) ||\n        (0, collectionenumfieldtype_1.isSerializedCollectionEnumFieldType)(definition) ||\n        (0, fieldtypearray_1.isSerializedFieldTypeArray)(definition, isSerializedBaseFieldTypeDefinition) ||\n        (0, ndimensionalfieldtypearray_1.isSerializedNDimensionalFieldTypeArray)(definition));\n}\nexports.isSerializedBaseFieldTypeDefinition = isSerializedBaseFieldTypeDefinition;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/basefieldtypedefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedCollectionEnumFieldType = exports.deserializeCollectionEnumFieldType = exports.isCollectionEnumFieldType = exports.CollectionEnumFieldType = exports.isCollectionEnumFieldNames = exports.CollectionEnumFieldNames = exports.CollectionEnumFieldTypeKey = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nexports.CollectionEnumFieldTypeKey = 'COLLECTION_ENUM';\n/**\n * Contains the field names of all valid fields for a groovy metadata collection.\n *\n * This should be kept in sync with GroovyFieldNames in FieldType.scala\n */\nvar CollectionEnumFieldNames;\n(function (CollectionEnumFieldNames) {\n    CollectionEnumFieldNames[\"Name\"] = \"name\";\n    CollectionEnumFieldNames[\"Id\"] = \"id\";\n    CollectionEnumFieldNames[\"Description\"] = \"description\";\n    CollectionEnumFieldNames[\"Color\"] = \"color\";\n    CollectionEnumFieldNames[\"IconUrl\"] = \"iconUrl\";\n})(CollectionEnumFieldNames || (exports.CollectionEnumFieldNames = CollectionEnumFieldNames = {}));\nexports.isCollectionEnumFieldNames = (0, validators_1.enumValidator)(CollectionEnumFieldNames);\nclass CollectionEnumFieldType {\n    constructor(collectionId) {\n        this.collectionId = collectionId;\n    }\n    toJSON() {\n        return { [exports.CollectionEnumFieldTypeKey]: this.collectionId };\n    }\n}\nexports.CollectionEnumFieldType = CollectionEnumFieldType;\n/**\n * Specifies which groovy field name is used as the primary key.\n *\n * This should be kept in sync with GroovyFieldNames in FieldType.scala\n */\nCollectionEnumFieldType.PRIMARY_KEY = CollectionEnumFieldNames.Id;\nconst isCollectionEnumFieldType = (fieldType) => {\n    return fieldType instanceof CollectionEnumFieldType;\n};\nexports.isCollectionEnumFieldType = isCollectionEnumFieldType;\nfunction deserializeCollectionEnumFieldType(serializedCollectionEnumFieldType) {\n    return new CollectionEnumFieldType(serializedCollectionEnumFieldType[exports.CollectionEnumFieldTypeKey]);\n}\nexports.deserializeCollectionEnumFieldType = deserializeCollectionEnumFieldType;\nfunction isSerializedCollectionEnumFieldType(fieldType) {\n    return (0, checks_1.isObjectUnsafe)(fieldType) && (0, checks_1.isString)(fieldType[exports.CollectionEnumFieldTypeKey]);\n}\nexports.isSerializedCollectionEnumFieldType = isSerializedCollectionEnumFieldType;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeFieldTypeArray = exports.isSerializedFieldTypeArray = exports.FieldTypeArray = exports.BaseFieldTypeArray = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst collectionenumfieldtype_1 = __webpack_require__(/*! ./collectionenumfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js\");\nconst literalfieldtype_1 = __webpack_require__(/*! ./literalfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js\");\nconst scalarfieldtype_1 = __webpack_require__(/*! ./scalarfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nclass BaseFieldTypeArray {\n    constructor(validTypesArray) {\n        this.validTypesArray = validTypesArray;\n    }\n    getInnerTypes() {\n        return this.validTypesArray;\n    }\n    getInnerNonArrayTypes() {\n        return this.validTypesArray.filter((innerType) => !(innerType instanceof BaseFieldTypeArray));\n    }\n    toJSON() {\n        return {\n            'ND': false,\n            'validTypes': this.validTypesArray.map((t) => this.serializeType(t)),\n        };\n    }\n}\nexports.BaseFieldTypeArray = BaseFieldTypeArray;\nclass FieldTypeArray extends BaseFieldTypeArray {\n    serializeType(t) {\n        return (0, scalarfieldtype_1.isScalarFieldTypeEnum)(t) ? t : t.toJSON();\n    }\n}\nexports.FieldTypeArray = FieldTypeArray;\nfunction isSerializedFieldTypeArray(fieldType, validateTypeCheck) {\n    return ((0, checks_1.isObjectUnsafe)(fieldType) &&\n        (0, checks_1.isBoolean)(fieldType['ND']) &&\n        fieldType['ND'] === false &&\n        (0, checks_1.isArray)(fieldType['validTypes']) &&\n        fieldType['validTypes'].every((validType) => {\n            return validateTypeCheck(validType);\n        }));\n}\nexports.isSerializedFieldTypeArray = isSerializedFieldTypeArray;\nfunction deserializeFieldTypeArray(serializedFieldTypeArray) {\n    return new FieldTypeArray(serializedFieldTypeArray['validTypes'].map((t) => {\n        if ((0, literalfieldtype_1.isSerializedLiteralFieldType)(t)) {\n            return (0, literalfieldtype_1.deserializeLiteralFieldType)(t);\n        }\n        else if ((0, collectionenumfieldtype_1.isSerializedCollectionEnumFieldType)(t)) {\n            return (0, collectionenumfieldtype_1.deserializeCollectionEnumFieldType)(t);\n        }\n        else if ((0, checks_1.isObject)(t)) {\n            return deserializeFieldTypeArray(t);\n        }\n        return t;\n    }));\n}\nexports.deserializeFieldTypeArray = deserializeFieldTypeArray;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedFieldTypeDefinition = exports.deserializeFieldTypeDefinition = exports.serializeFieldTypeDefinition = exports.fieldTypesEqual = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst basefieldtypedefinition_1 = __webpack_require__(/*! ./basefieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/basefieldtypedefinition.js\");\nconst collectionenumfieldtype_1 = __webpack_require__(/*! ./collectionenumfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js\");\nconst fieldtypearray_1 = __webpack_require__(/*! ./fieldtypearray */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js\");\nconst literalfieldtype_1 = __webpack_require__(/*! ./literalfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js\");\nconst ndimensionalfieldtypearray_1 = __webpack_require__(/*! ./ndimensionalfieldtypearray */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js\");\nfunction fieldTypesEqual(a, b, checkEnumCollectionId = true) {\n    if (a === b) {\n        return true;\n    }\n    if ((0, literalfieldtype_1.isLiteralFieldType)(a) && (0, literalfieldtype_1.isLiteralFieldType)(b)) {\n        return a.getLiteral() === b.getLiteral();\n    }\n    if ((0, collectionenumfieldtype_1.isCollectionEnumFieldType)(a) && (0, collectionenumfieldtype_1.isCollectionEnumFieldType)(b)) {\n        return checkEnumCollectionId ? a.collectionId === b.collectionId : true;\n    }\n    a = (0, checks_1.isArray)(a) ? a : [a];\n    b = (0, checks_1.isArray)(b) ? b : [b];\n    const setA = new Set(a);\n    const setB = new Set(b);\n    if (setA.size !== setB.size) {\n        return false;\n    }\n    for (const bItem of setB) {\n        if (setA.has(bItem)) {\n            continue;\n        }\n        if ((0, literalfieldtype_1.isLiteralFieldType)(bItem)) {\n            const found = a.some((aItem) => (0, literalfieldtype_1.isLiteralFieldType)(aItem) && fieldTypesEqual(aItem, bItem));\n            if (!found) {\n                return false;\n            }\n        }\n        else if (bItem instanceof fieldtypearray_1.FieldTypeArray) {\n            const found = a.some((aItem) => aItem instanceof fieldtypearray_1.FieldTypeArray && fieldTypesEqual(aItem.validTypesArray, bItem.validTypesArray));\n            if (!found) {\n                return false;\n            }\n        }\n        else if ((0, ndimensionalfieldtypearray_1.isNDimensionalFieldTypeArray)(bItem)) {\n            const aItem = a.find(ndimensionalfieldtypearray_1.isNDimensionalFieldTypeArray);\n            if (!aItem || !fieldTypesEqual(aItem.validTypesArray, bItem.validTypesArray)) {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    return true;\n}\nexports.fieldTypesEqual = fieldTypesEqual;\nfunction serializeFieldTypeDefinition(fieldType) {\n    if ((0, checks_1.isArray)(fieldType)) {\n        return fieldType.map(basefieldtypedefinition_1.serializeBaseFieldTypeDefinition);\n    }\n    else {\n        return (0, basefieldtypedefinition_1.serializeBaseFieldTypeDefinition)(fieldType);\n    }\n}\nexports.serializeFieldTypeDefinition = serializeFieldTypeDefinition;\nconst deserializeFieldTypeDefinition = (serializedFieldType) => {\n    if ((0, checks_1.isArray)(serializedFieldType)) {\n        return serializedFieldType.map(basefieldtypedefinition_1.deserializeBaseFieldTypeDefinition);\n    }\n    return (0, basefieldtypedefinition_1.deserializeBaseFieldTypeDefinition)(serializedFieldType);\n};\nexports.deserializeFieldTypeDefinition = deserializeFieldTypeDefinition;\nfunction isSerializedFieldTypeDefinition(definition) {\n    if ((0, checks_1.isArray)(definition)) {\n        return definition.every(basefieldtypedefinition_1.isSerializedBaseFieldTypeDefinition);\n    }\n    return (0, basefieldtypedefinition_1.isSerializedBaseFieldTypeDefinition)(definition);\n}\nexports.isSerializedFieldTypeDefinition = isSerializedFieldTypeDefinition;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeLiteralFieldType = exports.isSerializedLiteralFieldType = exports.isLiteralFieldType = exports.LiteralFieldType = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst scalarfieldtype_1 = __webpack_require__(/*! ./scalarfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nclass LiteralFieldType {\n    constructor(literal) {\n        this.scalarFieldType = scalarfieldtype_1.ScalarFieldTypeEnum.ANY;\n        if ((0, checks_1.isString)(literal)) {\n            this.literal = literal.substring(LiteralFieldType.literalStringPrefix.length);\n            this.scalarFieldType = scalarfieldtype_1.ScalarFieldTypeEnum.STRING;\n        }\n        else if ((0, checks_1.isBoolean)(literal)) {\n            this.literal = literal;\n            this.scalarFieldType = scalarfieldtype_1.ScalarFieldTypeEnum.BOOLEAN;\n        }\n        else {\n            this.literal = literal;\n            this.scalarFieldType = scalarfieldtype_1.ScalarFieldTypeEnum.NUMBER;\n        }\n    }\n    getLiteral() {\n        return this.literal;\n    }\n    getScalarFieldType() {\n        return this.scalarFieldType;\n    }\n    toJSON() {\n        if (this.scalarFieldType === scalarfieldtype_1.ScalarFieldTypeEnum.STRING) {\n            return LiteralFieldType.literalStringPrefix + this.literal;\n        }\n        return this.literal.toString();\n    }\n}\nexports.LiteralFieldType = LiteralFieldType;\nLiteralFieldType.literalStringPrefix = '%';\nfunction isLiteralFieldType(fieldType) {\n    return fieldType instanceof LiteralFieldType;\n}\nexports.isLiteralFieldType = isLiteralFieldType;\nfunction isSerializedLiteralFieldType(definition) {\n    return (0, checks_1.isString)(definition);\n}\nexports.isSerializedLiteralFieldType = isSerializedLiteralFieldType;\n/**\n * String literals without the literalStringPrefix will return the boolean literal false\n */\nfunction deserializeLiteralFieldType(serializedLiteralFieldType) {\n    if (serializedLiteralFieldType.startsWith(LiteralFieldType.literalStringPrefix)) {\n        return new LiteralFieldType(serializedLiteralFieldType);\n    }\n    const numberLiteral = Number(serializedLiteralFieldType);\n    if (isNaN(numberLiteral) ||\n        numberLiteral === Number.POSITIVE_INFINITY ||\n        numberLiteral === Number.NEGATIVE_INFINITY) {\n        return new LiteralFieldType(serializedLiteralFieldType === 'true');\n    }\n    return new LiteralFieldType(numberLiteral);\n}\nexports.deserializeLiteralFieldType = deserializeLiteralFieldType;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeNDimensionalFieldTypeArray = exports.isSerializedNDimensionalFieldTypeArray = exports.isNDimensionalFieldTypeArray = exports.isValidTypeForNDimensionalFieldTypeArray = exports.NDimensionalFieldTypeArray = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst literalfieldtype_1 = __webpack_require__(/*! ./literalfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js\");\nconst scalarfieldtype_1 = __webpack_require__(/*! ./scalarfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\");\nclass NDimensionalFieldTypeArray {\n    constructor(validTypesArray) {\n        this.validTypesArray = validTypesArray;\n    }\n    getInnerTypes() {\n        return [...this.validTypesArray, this];\n    }\n    getInnerNonArrayTypes() {\n        return this.validTypesArray.filter((innerType) => (0, scalarfieldtype_1.isScalarFieldTypeEnum)(innerType) || (0, literalfieldtype_1.isLiteralFieldType)(innerType));\n    }\n    toJSON() {\n        return {\n            'ND': true,\n            'validTypes': this.validTypesArray.map((t) => ((0, scalarfieldtype_1.isScalarFieldTypeEnum)(t) ? t : t.toJSON())),\n        };\n    }\n}\nexports.NDimensionalFieldTypeArray = NDimensionalFieldTypeArray;\nfunction isValidTypeForNDimensionalFieldTypeArray(fieldType) {\n    return (0, scalarfieldtype_1.isScalarFieldTypeEnum)(fieldType) || (0, literalfieldtype_1.isLiteralFieldType)(fieldType);\n}\nexports.isValidTypeForNDimensionalFieldTypeArray = isValidTypeForNDimensionalFieldTypeArray;\nfunction isNDimensionalFieldTypeArray(fieldType) {\n    return fieldType instanceof NDimensionalFieldTypeArray;\n}\nexports.isNDimensionalFieldTypeArray = isNDimensionalFieldTypeArray;\nfunction isSerializedNDimensionalFieldTypeArray(fieldType) {\n    return ((0, checks_1.isObjectUnsafe)(fieldType) &&\n        (0, checks_1.isBoolean)(fieldType['ND']) &&\n        fieldType['ND'] === true &&\n        (0, checks_1.isTypedArray)(checks_1.isAny)(fieldType['validTypes']) &&\n        fieldType['validTypes'].every((validType) => {\n            return (0, checks_1.isDefAndNotNull)(scalarfieldtype_1.ScalarFieldTypeEnum[validType]) || (0, literalfieldtype_1.isSerializedLiteralFieldType)(validType);\n        }));\n}\nexports.isSerializedNDimensionalFieldTypeArray = isSerializedNDimensionalFieldTypeArray;\nfunction deserializeNDimensionalFieldTypeArray(serializedNDimensionalFieldTypeArray) {\n    return new NDimensionalFieldTypeArray(serializedNDimensionalFieldTypeArray['validTypes'].map((t) => {\n        if ((0, literalfieldtype_1.isSerializedLiteralFieldType)(t)) {\n            return (0, literalfieldtype_1.deserializeLiteralFieldType)(t);\n        }\n        return t;\n    }));\n}\nexports.deserializeNDimensionalFieldTypeArray = deserializeNDimensionalFieldTypeArray;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isScalarFieldTypeEnum = exports.AnyScalarFieldType = exports.ScalarFieldTypeEnum = void 0;\nvar ScalarFieldTypeEnum;\n(function (ScalarFieldTypeEnum) {\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"ANY\"] = 0] = \"ANY\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"NUMBER\"] = 1] = \"NUMBER\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"BOOLEAN\"] = 2] = \"BOOLEAN\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"STRING\"] = 3] = \"STRING\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"COLOR\"] = 4] = \"COLOR\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"DATE\"] = 5] = \"DATE\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"NULL\"] = 6] = \"NULL\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"DICTIONARY\"] = 7] = \"DICTIONARY\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"CURRENCY\"] = 8] = \"CURRENCY\";\n    ScalarFieldTypeEnum[ScalarFieldTypeEnum[\"DATEONLY\"] = 9] = \"DATEONLY\";\n})(ScalarFieldTypeEnum || (exports.ScalarFieldTypeEnum = ScalarFieldTypeEnum = {}));\nexports.AnyScalarFieldType = [\n    ScalarFieldTypeEnum.ANY,\n    ScalarFieldTypeEnum.NUMBER,\n    ScalarFieldTypeEnum.STRING,\n    ScalarFieldTypeEnum.BOOLEAN,\n    ScalarFieldTypeEnum.COLOR,\n    ScalarFieldTypeEnum.DATE,\n    ScalarFieldTypeEnum.DATEONLY,\n    ScalarFieldTypeEnum.NULL,\n    ScalarFieldTypeEnum.DICTIONARY,\n    ScalarFieldTypeEnum.CURRENCY,\n];\nconst AnyScalarFieldTypeSet = new Set(exports.AnyScalarFieldType);\nconst isScalarFieldTypeEnum = (fieldType) => {\n    return AnyScalarFieldTypeSet.has(fieldType);\n};\nexports.isScalarFieldTypeEnum = isScalarFieldTypeEnum;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semanticfields.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semanticfields.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSemanticFields = exports.SemanticFields = void 0;\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/**\n * Semantic Fields serve as standardized categories that transcend individual data source labels, facilitating\n * a uniform way to access and manipulate data. For instance, regardless of the source, data that pertains to \"titles\"\n * or \"user information\" often carries the same kind of information, though it may be labeled differently across systems.\n * Lucid’s Semantic Fields ensure that such data is recognized and treated consistently within the platform,\n * regardless of external labeling conventions.\n *\n * Semantic Mapping is the process through which Lucid aligns these disparate field names to a set of standardized\n * Semantic Fields. By using Semantic Fields like Title, Description, User, and Project, Lucid simplifies the way\n * users access and interact with data brought in from external sources.\n *\n * Benefits of Semantic Fields:\n * Uniformity: Ensures that data from diverse sources is referenced consistently within Lucid.\n * Integration Simplicity: Simplifies the process of integrating new data sources into Lucid by mapping to an established set of Semantic Fields.\n * Feature Compatibility: Allows for seamless use of Lucid’s intelligent features across all data, regardless of its origin.\n * Data Organization: Provides a structured approach to organizing and grouping data within the Lucid ecosystem.\n */\nvar SemanticFields;\n(function (SemanticFields) {\n    /**\n     * Represents the title or main descriptor of an item.\n     */\n    SemanticFields[\"Title\"] = \"title\";\n    /**\n     * Captures detailed information or a summary about an item.\n     */\n    SemanticFields[\"Description\"] = \"description\";\n    /**\n     * Refers to the user associated with or assigned to an item.\n     */\n    SemanticFields[\"User\"] = \"user\";\n    /**\n     * Specific to the reporting user, typically in the context of a ticketing system.\n     */\n    SemanticFields[\"Reporter\"] = \"user.reporter\";\n    /**\n     * Refers to the time associated with an item.\n     */\n    SemanticFields[\"Time\"] = \"time\";\n    /**\n     * Pertains to the ending or completion time of an item.\n     */\n    SemanticFields[\"EndTime\"] = \"time.endtime\";\n    /**\n     * Contains estimations related to items, like time or resource estimates.\n     */\n    SemanticFields[\"Estimate\"] = \"estimate\";\n    /**\n     * Reflects status of an item, typically in the context of a ticketing system.\n     */\n    SemanticFields[\"Status\"] = \"status\";\n    /**\n     * Classifies the type of issue or item, typically in the context of a ticketing system.\n     */\n    SemanticFields[\"IssueType\"] = \"issuetype\";\n    /**\n     * Indicates the importance or urgency level of an item.\n     */\n    SemanticFields[\"Priority\"] = \"priority\";\n    /**\n     * Relates to the project with which an item is associated.\n     */\n    SemanticFields[\"Project\"] = \"project\";\n    /**\n     * The unique URL or identifier linking back to the item’s source.\n     */\n    SemanticFields[\"SourceItemUrl\"] = \"url\";\n    /**\n     * Refers to the URL of the image associated with this item\n     */\n    SemanticFields[\"ImageUrl\"] = \"url.image\";\n})(SemanticFields || (exports.SemanticFields = SemanticFields = {}));\nexports.isSemanticFields = (0, validators_1.stringEnumValidator)(SemanticFields);\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semanticfields.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semantickind.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semantickind.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.semanticKindToSemanticFields = exports.isSemanticKind = exports.SemanticKind = void 0;\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst semanticfields_1 = __webpack_require__(/*! ./semanticfields */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semanticfields.js\");\n/**\n * @deprecated use SemanticFields instead. SemanticKind has not been removed to ensure backwards compatability.\n */\nvar SemanticKind;\n(function (SemanticKind) {\n    SemanticKind[\"Id\"] = \"id\";\n    SemanticKind[\"Title\"] = \"title\";\n    SemanticKind[\"Name\"] = \"name\";\n    SemanticKind[\"Image\"] = \"image\";\n    SemanticKind[\"Description\"] = \"description\";\n    SemanticKind[\"Assignee\"] = \"assignee\";\n    SemanticKind[\"Estimate\"] = \"estimate\";\n    SemanticKind[\"Status\"] = \"status\";\n    SemanticKind[\"IssueType\"] = \"issuetype\";\n    SemanticKind[\"Priority\"] = \"priority\";\n    SemanticKind[\"Project\"] = \"project\";\n    SemanticKind[\"Reporter\"] = \"reporter\";\n    SemanticKind[\"StartTime\"] = \"starttime\";\n    SemanticKind[\"EndTime\"] = \"endtime\";\n    SemanticKind[\"GroupByHint\"] = \"groupbyhint\";\n    SemanticKind[\"PrimaryKeyReference\"] = \"primarykeyreference\";\n    SemanticKind[\"URL\"] = \"url\";\n})(SemanticKind || (exports.SemanticKind = SemanticKind = {}));\nexports.isSemanticKind = (0, validators_1.enumValidator)(SemanticKind);\nfunction semanticKindToSemanticFields(semanticField) {\n    if ((0, semanticfields_1.isSemanticFields)(semanticField)) {\n        return semanticField;\n    }\n    else {\n        switch (semanticField) {\n            case SemanticKind.Id:\n                return undefined;\n            case SemanticKind.Title:\n                return semanticfields_1.SemanticFields.Title;\n            // Name could have been mapped to User or Title but all uses cases outside of the unified viz API use it as Title\n            case SemanticKind.Name:\n                return semanticfields_1.SemanticFields.Title;\n            case SemanticKind.Image:\n                return semanticfields_1.SemanticFields.ImageUrl;\n            case SemanticKind.Description:\n                return semanticfields_1.SemanticFields.Description;\n            case SemanticKind.Assignee:\n                return semanticfields_1.SemanticFields.User;\n            case SemanticKind.Estimate:\n                return semanticfields_1.SemanticFields.Estimate;\n            case SemanticKind.Status:\n                return semanticfields_1.SemanticFields.Status;\n            case SemanticKind.IssueType:\n                return semanticfields_1.SemanticFields.IssueType;\n            case SemanticKind.Priority:\n                return semanticfields_1.SemanticFields.Priority;\n            case SemanticKind.Project:\n                return semanticfields_1.SemanticFields.Project;\n            case SemanticKind.Reporter:\n                return semanticfields_1.SemanticFields.Reporter;\n            case SemanticKind.StartTime:\n                return semanticfields_1.SemanticFields.Time;\n            case SemanticKind.EndTime:\n                return semanticfields_1.SemanticFields.EndTime;\n            case SemanticKind.GroupByHint:\n                return undefined;\n            case SemanticKind.PrimaryKeyReference:\n                return undefined;\n            case SemanticKind.URL:\n                return semanticfields_1.SemanticFields.SourceItemUrl;\n            default:\n                return undefined;\n        }\n    }\n}\nexports.semanticKindToSemanticFields = semanticKindToSemanticFields;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semantickind.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedFlattenedReference = exports.isUnTypedSerializedFlattenedReference = exports.isTypedSerializedFlattenedReference = exports.FlattenedReferenceKeyName = exports.FlattenedReferenceKeyId = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nexports.FlattenedReferenceKeyId = '192d0e9f-2f5a-4032-9f03-59bbf1ea5891';\nexports.FlattenedReferenceKeyName = '192d0e9f-2f5a-4032-9f03-59bbf1ea5891_n';\n/** @ignore */\nfunction isTypedSerializedFlattenedReference(data) {\n    return (0, checks_1.isObjectUnsafe)(data) && (0, checks_1.isObject)(data['sc']) && (0, checks_1.isObject)(data['d']);\n}\nexports.isTypedSerializedFlattenedReference = isTypedSerializedFlattenedReference;\n/** @ignore */\nfunction isUnTypedSerializedFlattenedReference(data) {\n    return (0, checks_1.isObjectUnsafe)(data) && data[exports.FlattenedReferenceKeyId] === true;\n}\nexports.isUnTypedSerializedFlattenedReference = isUnTypedSerializedFlattenedReference;\n/** @ignore */\nfunction isSerializedFlattenedReference(data) {\n    return isUnTypedSerializedFlattenedReference(data) || isTypedSerializedFlattenedReference(data);\n}\nexports.isSerializedFlattenedReference = isSerializedFlattenedReference;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/serializedfield/serializeddataitems.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/serializedfield/serializeddataitems.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedDataItems = void 0;\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst serializedfields_1 = __webpack_require__(/*! ./serializedfields */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js\");\nexports.isSerializedDataItems = (0, validators_1.objectOfValidator)(serializedfields_1.isSerializedFields);\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/serializedfield/serializeddataitems.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedFieldDefinition = exports.isSerializedFieldConstraint = exports.isFieldConstraintType = exports.FieldConstraintType = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../fieldtypedefinition/fieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst semanticfields_1 = __webpack_require__(/*! ../fieldtypedefinition/semanticfields */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semanticfields.js\");\nconst semantickind_1 = __webpack_require__(/*! ../fieldtypedefinition/semantickind */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semantickind.js\");\n// The options here must match com.lucidchart.data.model.fielddefinition.FieldConstraintType on the backend\nvar FieldConstraintType;\n(function (FieldConstraintType) {\n    FieldConstraintType[\"REQUIRED\"] = \"required\";\n    FieldConstraintType[\"LOCKED\"] = \"locked\";\n    FieldConstraintType[\"MIN_VALUE\"] = \"minValue\";\n    FieldConstraintType[\"MAX_VALUE\"] = \"maxValue\";\n    FieldConstraintType[\"SINGLE_LINE_ONLY\"] = \"singleLineOnly\";\n    FieldConstraintType[\"NO_WHITESPACE\"] = \"noWhitespace\";\n    FieldConstraintType[\"UNIQUE_EDIT\"] = \"uniqueEditType\";\n})(FieldConstraintType || (exports.FieldConstraintType = FieldConstraintType = {}));\nexports.isFieldConstraintType = (0, validators_1.enumValidator)(FieldConstraintType);\nexports.isSerializedFieldConstraint = (0, validators_1.objectValidator)({\n    'Type': (0, validators_1.enumValidator)(FieldConstraintType),\n    'Details': (0, validators_1.option)(checks_1.isAny),\n});\nexports.isSerializedFieldDefinition = (0, validators_1.strictObjectValidator)({\n    'Name': checks_1.isString,\n    'Type': fieldtypedefinition_1.isSerializedFieldTypeDefinition,\n    'Constraints': (0, validators_1.option)((0, validators_1.arrayValidator)(exports.isSerializedFieldConstraint)),\n    'SyncSchema': (0, validators_1.option)(checks_1.isString),\n    'Mapping': (0, validators_1.option)((0, validators_1.either)((0, validators_1.arrayValidator)(semanticfields_1.isSemanticFields), (0, validators_1.arrayValidator)(semantickind_1.isSemanticKind))),\n});\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedFields = exports.isSerializedJsonFieldType = exports.isSerializedFieldType = exports.isSerializedLucidDateObject = exports.isSerializedMillisecondsDateObject = exports.isSerializedLucidCurrency = exports.isSerializedLucidDictionary = exports.isJsonSerializedLucidDictionary = exports.isNestedSerializedLucidDictionary = exports.isSerializedColorObjectFieldType = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nfunction isSerializedColorObjectFieldType(value) {\n    return (0, checks_1.isObjectUnsafe)(value) && (0, checks_1.isObject)(value['color']);\n}\nexports.isSerializedColorObjectFieldType = isSerializedColorObjectFieldType;\n/** a dictionary type that has full type support */\nexports.isNestedSerializedLucidDictionary = (0, validators_1.strictObjectValidator)({\n    'dict': (0, validators_1.mapValidator)(isSerializedFieldType),\n});\n/** a dictionary type that only supports raw js, primarily used when external data could be arbritrary js */\nexports.isJsonSerializedLucidDictionary = (0, validators_1.strictObjectValidator)({\n    'js': (0, validators_1.mapValidator)(isSerializedJsonFieldType),\n});\nexports.isSerializedLucidDictionary = (0, validators_1.either)(exports.isNestedSerializedLucidDictionary, exports.isJsonSerializedLucidDictionary);\nexports.isSerializedLucidCurrency = (0, validators_1.objectValidator)({\n    'a': checks_1.isNumber,\n    't': checks_1.isString,\n});\nexports.isSerializedMillisecondsDateObject = (0, validators_1.objectValidator)({\n    'ms': checks_1.isNumber,\n    'isDateOnly': (0, validators_1.option)(checks_1.isBoolean),\n});\nconst isSerializedIsoDateObject = (0, validators_1.objectValidator)({\n    'isoDate': checks_1.isString,\n    'displayTimezone': (0, validators_1.option)(checks_1.isString),\n});\nexports.isSerializedLucidDateObject = (0, validators_1.either)(exports.isSerializedMillisecondsDateObject, isSerializedIsoDateObject);\nfunction isSerializedFieldType(value) {\n    return (value == null ||\n        (0, checks_1.isNumber)(value) ||\n        (0, checks_1.isString)(value) ||\n        (0, checks_1.isBoolean)(value) ||\n        (0, exports.isSerializedLucidDictionary)(value) ||\n        (0, exports.isSerializedLucidCurrency)(value) ||\n        ((0, checks_1.isArray)(value) && value.every(isSerializedFieldType)) ||\n        (0, exports.isSerializedLucidDateObject)(value) ||\n        isSerializedColorObjectFieldType(value));\n}\nexports.isSerializedFieldType = isSerializedFieldType;\nfunction isSerializedJsonFieldType(value) {\n    return (value == null ||\n        (0, checks_1.isNumber)(value) ||\n        (0, checks_1.isString)(value) ||\n        (0, checks_1.isBoolean)(value) ||\n        ((0, checks_1.isArray)(value) && value.every(isSerializedJsonFieldType)) ||\n        ((0, checks_1.isObject)(value) && Object.values(value).every(isSerializedJsonFieldType)));\n}\nexports.isSerializedJsonFieldType = isSerializedJsonFieldType;\nexports.isSerializedFields = (0, validators_1.objectOfValidator)(isSerializedFieldType);\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedSchema = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst serializedfielddefinition_1 = __webpack_require__(/*! ./serializedfielddefinition */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js\");\nfunction isSerializedSchema(schema) {\n    if (schema == null) {\n        return false;\n    }\n    const fields = schema['Fields'];\n    const primaryKey = schema['PrimaryKey'];\n    const fieldLabelOverrides = schema['FieldLabelOverrides'];\n    const validOverrides = (0, checks_1.isDefAndNotNull)(fieldLabelOverrides)\n        ? (0, checks_1.isRecord)(checks_1.isString)(fieldLabelOverrides) && !(0, checks_1.isArray)(fieldLabelOverrides)\n        : true; // Optional field\n    return ((0, checks_1.isTypedArray)(serializedfielddefinition_1.isSerializedFieldDefinition)(fields) &&\n        (0, validators_1.arrayValidator)(serializedfielddefinition_1.isSerializedFieldDefinition)(fields) &&\n        (0, checks_1.isArray)(primaryKey) &&\n        primaryKey.every(checks_1.isString) &&\n        validOverrides);\n}\nexports.isSerializedSchema = isSerializedSchema;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/dataerrortype.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/dataerrortype.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/dataerrortype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/defer.js":
/*!********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/defer.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defer = void 0;\nfunction checkPromiseExists() {\n    if (typeof Promise !== 'function') {\n        throw new Error('No promise library available');\n    }\n}\nfunction defer() {\n    checkPromiseExists();\n    let resolve = undefined;\n    let reject = undefined;\n    const promise = new Promise((resolveLocal, rejectLocal) => {\n        resolve = resolveLocal;\n        reject = rejectLocal;\n    });\n    if (!resolve || !reject) {\n        throw new Error('Promise constructor does not provide proper arguments to callback');\n    }\n    return {\n        resolve: resolve,\n        reject: reject,\n        promise: promise,\n        then: promise.then.bind(promise),\n        catch: promise.catch.bind(promise),\n        finally: promise.finally.bind(promise),\n        [Symbol.toStringTag]: promise[Symbol.toStringTag],\n    };\n}\nexports.defer = defer;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/defer.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/guards.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/guards.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/guards.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/humanreadableerror.js":
/*!*********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/humanreadableerror.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HumanReadableError = void 0;\n/**\n * An error carrying a message that is good to be shown directly in the UI.\n * These can be thrown from extensions and caught in core code.\n */\nclass HumanReadableError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'HumanReadableError';\n    }\n}\nexports.HumanReadableError = HumanReadableError;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/humanreadableerror.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/iframe/iframeutils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/iframe/iframeutils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseIFrameAttributesFromHTML = exports.generateIFrameHTML = exports.DEFAULT_IFRAME_HEIGHT = exports.DEFAULT_IFRAME_WIDTH = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\n/**\n * Aspect ratio 16:9, wider rectangle\n * This will be the default setting if not provided\n *\n * The values are small since we only use width and height value to calculate aspect ratio\n * So in this case, it will be width/height, which will be 16:9\n * It's the same result as 1600 and 900 as default width and height\n */\nexports.DEFAULT_IFRAME_WIDTH = 16;\nexports.DEFAULT_IFRAME_HEIGHT = 9;\n/**\n * Iframes from external sources are not trustworthy to be embedded directly. They could cause security vulnerability,\n * including XSS attacks. Even if the iframes come from sources with good reputation, it is still a good practice to\n * sanitize their source HTML and restrict their functionality in the sandbox before embedding them to our apps.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe for a list of iframe attributes.\n */\nconst iframeRegExps = {\n    src: /src=\"((https:\\/\\/|\\/\\/).*?)\"/i,\n    height: /height=\"(\\d*?)\"/i,\n    width: /width=\"(\\d*?)\"/i,\n    title: /title=\"(.*?)\"/i,\n};\n/**\n * Generate iframe HTML from the IFrameAttributes object\n * @returns the generated iframe HTML\n * @ignore\n * */\nfunction generateIFrameHTML(iframeAttributes) {\n    let iframeHTML = `<iframe src=\"${iframeAttributes.src}\"`;\n    if (iframeAttributes.width) {\n        iframeHTML += ` width=\"${iframeAttributes.width.toString()}\"`;\n    }\n    if (iframeAttributes.height) {\n        iframeHTML += ` height=\"${iframeAttributes.height.toString()}\"`;\n    }\n    if (iframeAttributes.title) {\n        // Escape all the double quotation marks\n        const title = iframeAttributes.title.replace(/\"/g, '&quot;');\n        iframeHTML += ` title=\"${title}\"`;\n    }\n    iframeHTML += '></iframe>';\n    return iframeHTML;\n}\nexports.generateIFrameHTML = generateIFrameHTML;\n/**\n * Parse the iframe HTML, i.e. <iframe>...</iframe> into the IFrameAttributes object\n * @returns the required attributes to render the target iframe\n * @ignore\n */\nfunction parseIFrameAttributesFromHTML(iframeHTML) {\n    var _a, _b, _c, _d, _e, _f;\n    if (!iframeHTML.startsWith('<iframe')) {\n        return {\n            srcdoc: iframeHTML,\n            height: exports.DEFAULT_IFRAME_HEIGHT,\n            width: exports.DEFAULT_IFRAME_WIDTH,\n        };\n    }\n    const src = (_b = (_a = iframeHTML.match(iframeRegExps.src)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : '';\n    const height = (_c = iframeHTML.match(iframeRegExps.height)) === null || _c === void 0 ? void 0 : _c[1];\n    const width = (_d = iframeHTML.match(iframeRegExps.width)) === null || _d === void 0 ? void 0 : _d[1];\n    const title = (_f = (_e = iframeHTML.match(iframeRegExps.title)) === null || _e === void 0 ? void 0 : _e[1]) !== null && _f !== void 0 ? _f : '';\n    return {\n        src: src,\n        height: !(0, checks_1.isUndefined)(height) ? Number.parseInt(height) : exports.DEFAULT_IFRAME_HEIGHT,\n        width: !(0, checks_1.isUndefined)(width) ? Number.parseInt(width) : exports.DEFAULT_IFRAME_WIDTH,\n        title: title,\n    };\n}\nexports.parseIFrameAttributesFromHTML = parseIFrameAttributesFromHTML;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/iframe/iframeutils.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/jsonserializable.js":
/*!*******************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/jsonserializable.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isJsonObject = exports.isJsonSerializable = void 0;\nconst checks_1 = __webpack_require__(/*! ./checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nfunction isJsonSerializable(x) {\n    return (x == null ||\n        (0, checks_1.isString)(x) ||\n        (0, checks_1.isNumber)(x) ||\n        (0, checks_1.isBoolean)(x) ||\n        ((0, checks_1.isArray)(x) && x.every(isJsonSerializable)) ||\n        isJsonObject(x));\n}\nexports.isJsonSerializable = isJsonSerializable;\nfunction isJsonObject(x) {\n    if (!(0, checks_1.isObjectUnsafe)(x)) {\n        return false;\n    }\n    for (const k in x) {\n        if (!isJsonSerializable(x[k])) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isJsonObject = isJsonObject;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/jsonserializable.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/lucidproduct.js":
/*!***************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/lucidproduct.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidProduct = void 0;\n/**\n * Lucid products supporting the extension API\n */\nvar LucidProduct;\n(function (LucidProduct) {\n    LucidProduct[\"Chart\"] = \"chart\";\n    LucidProduct[\"Spark\"] = \"spark\";\n    LucidProduct[\"TeamSpaces\"] = \"teamspaces\";\n})(LucidProduct || (exports.LucidProduct = LucidProduct = {}));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/lucidproduct.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/object.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/object.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromEntries = exports.flatten = exports.objectEvery = void 0;\nfunction objectEvery(obj, f, opt_this) {\n    for (const key in obj) {\n        if (!f.call(opt_this, obj[key], key, obj)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.objectEvery = objectEvery;\nfunction flatten(a) {\n    const result = [];\n    for (const item of a) {\n        result.push(...item);\n    }\n    return result;\n}\nexports.flatten = flatten;\n// TODO: Placeholder until we adopt ES8 and can use Object.fromEntries(obj)\nfunction fromEntries(entries) {\n    const result = {};\n    for (const [key, value] of entries) {\n        result[key] = value;\n    }\n    return result;\n}\nexports.fromEntries = fromEntries;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/object.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/offsettype.js":
/*!*************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/offsettype.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isLinearOffsetType = exports.OffsetType = void 0;\n/**\n * When adjusting the size or location of items on a page, these are the specific operations that are available.\n */\nvar OffsetType;\n(function (OffsetType) {\n    /**\n     * Resize from the northwest (upper-left) corner of the selection, anchoring the lower-right corner in place.\n     */\n    OffsetType[OffsetType[\"NW\"] = 0] = \"NW\";\n    /**\n     * Resize from the northeast (upper-right) corner of the selection, anchoring the lower-left corner in place.\n     */\n    OffsetType[OffsetType[\"NE\"] = 1] = \"NE\";\n    /**\n     * Resize from the southeast (lower-right) corner of the selection, anchoring the upper-left corner in place.\n     */\n    OffsetType[OffsetType[\"SE\"] = 2] = \"SE\";\n    /**\n     * Resize from the southwest (lower-left) corner of the selection, anchoring the upper-right corner in place.\n     */\n    OffsetType[OffsetType[\"SW\"] = 3] = \"SW\";\n    /**\n     * Move the selection without resizing.\n     */\n    OffsetType[OffsetType[\"MOVE\"] = 4] = \"MOVE\";\n    OffsetType[OffsetType[\"ROTATE\"] = 5] = \"ROTATE\";\n    OffsetType[OffsetType[\"SCALE\"] = 6] = \"SCALE\";\n    OffsetType[OffsetType[\"CUSTOM\"] = 7] = \"CUSTOM\";\n    /**\n     * Resize from the north (upper) side of the selection, stretching vertically.\n     */\n    OffsetType[OffsetType[\"N\"] = 8] = \"N\";\n    /**\n     * Resize from the east (right) side of the selection, stretching horizontally.\n     */\n    OffsetType[OffsetType[\"E\"] = 9] = \"E\";\n    /**\n     * Resize from the south (lower) side of the selection, stretching vertically.\n     */\n    OffsetType[OffsetType[\"S\"] = 10] = \"S\";\n    /**\n     * Resize from the west (left) side of the selection, stretching horizontally.\n     */\n    OffsetType[OffsetType[\"W\"] = 11] = \"W\";\n})(OffsetType || (exports.OffsetType = OffsetType = {}));\nfunction isLinearOffsetType(offsetType) {\n    return (offsetType === OffsetType.NW ||\n        offsetType === OffsetType.NE ||\n        offsetType === OffsetType.SE ||\n        offsetType === OffsetType.SW ||\n        offsetType === OffsetType.MOVE ||\n        offsetType === OffsetType.N ||\n        offsetType === OffsetType.E ||\n        offsetType === OffsetType.S ||\n        offsetType === OffsetType.W);\n}\nexports.isLinearOffsetType = isLinearOffsetType;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/offsettype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/optionalkey.js":
/*!**************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/optionalkey.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/optionalkey.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isLayerPos = exports.isVerticalPos = exports.isHorizontalPos = exports.isValidSerializedBadgeEnumPosition = exports.serializeBadgeEnumPositionAsKey = exports.serializeBadgeEnumPosition = exports.deserializeBadgeEnumPosition = exports.badgePositionsEqual = exports.defaultBadgePositionSerialized = exports.defaultBadgePosition = exports.BadgePositionsClockwise = exports.BadgeResponsiveness = exports.BadgeLayerPos = exports.VerticalBadgePos = exports.HorizontalBadgePos = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nvar HorizontalBadgePos;\n(function (HorizontalBadgePos) {\n    HorizontalBadgePos[HorizontalBadgePos[\"LEFT\"] = 0] = \"LEFT\";\n    HorizontalBadgePos[HorizontalBadgePos[\"CENTER\"] = 1] = \"CENTER\";\n    HorizontalBadgePos[HorizontalBadgePos[\"RIGHT\"] = 2] = \"RIGHT\";\n})(HorizontalBadgePos || (exports.HorizontalBadgePos = HorizontalBadgePos = {}));\nvar VerticalBadgePos;\n(function (VerticalBadgePos) {\n    VerticalBadgePos[VerticalBadgePos[\"TOP\"] = 0] = \"TOP\";\n    VerticalBadgePos[VerticalBadgePos[\"CENTER\"] = 1] = \"CENTER\";\n    VerticalBadgePos[VerticalBadgePos[\"BOTTOM\"] = 2] = \"BOTTOM\";\n})(VerticalBadgePos || (exports.VerticalBadgePos = VerticalBadgePos = {}));\nvar BadgeLayerPos;\n(function (BadgeLayerPos) {\n    BadgeLayerPos[BadgeLayerPos[\"INSIDE\"] = 0] = \"INSIDE\";\n    BadgeLayerPos[BadgeLayerPos[\"EDGE\"] = 1] = \"EDGE\";\n    BadgeLayerPos[BadgeLayerPos[\"OUTSIDE\"] = 2] = \"OUTSIDE\";\n})(BadgeLayerPos || (exports.BadgeLayerPos = BadgeLayerPos = {}));\nvar BadgeResponsiveness;\n(function (BadgeResponsiveness) {\n    BadgeResponsiveness[BadgeResponsiveness[\"STATIC\"] = 0] = \"STATIC\";\n    BadgeResponsiveness[BadgeResponsiveness[\"STACK\"] = 1] = \"STACK\";\n})(BadgeResponsiveness || (exports.BadgeResponsiveness = BadgeResponsiveness = {}));\n/*\n * The order of the badge position starting from the top-left corner and going clockwise\n */\nexports.BadgePositionsClockwise = [\n    { horizontalPos: 0, verticalPos: 0 },\n    { horizontalPos: 1, verticalPos: 0 },\n    { horizontalPos: 2, verticalPos: 0 },\n    { horizontalPos: 2, verticalPos: 1 },\n    { horizontalPos: 2, verticalPos: 2 },\n    { horizontalPos: 1, verticalPos: 2 },\n    { horizontalPos: 0, verticalPos: 2 },\n    { horizontalPos: 0, verticalPos: 1 }, // left-center\n];\nexports.defaultBadgePosition = {\n    horizontalPos: HorizontalBadgePos.RIGHT,\n    verticalPos: VerticalBadgePos.TOP,\n    layer: BadgeLayerPos.EDGE,\n    responsive: BadgeResponsiveness.STACK,\n};\nexports.defaultBadgePositionSerialized = {\n    'horiz': HorizontalBadgePos.RIGHT,\n    'vert': VerticalBadgePos.TOP,\n    'layer': BadgeLayerPos.EDGE,\n    'responsive': BadgeResponsiveness.STACK,\n};\nfunction badgePositionsEqual(a, b) {\n    return (a.horizontalPos === b.horizontalPos &&\n        a.verticalPos === b.verticalPos &&\n        a.layer === b.layer &&\n        a.responsive === b.responsive);\n}\nexports.badgePositionsEqual = badgePositionsEqual;\nfunction deserializeBadgeEnumPosition(serialized) {\n    if (serialized == null) {\n        return undefined;\n    }\n    return {\n        horizontalPos: serialized['horiz'] != null ? serialized['horiz'] : exports.defaultBadgePosition.horizontalPos,\n        verticalPos: serialized['vert'] != null ? serialized['vert'] : exports.defaultBadgePosition.verticalPos,\n        layer: serialized['layer'] != null ? serialized['layer'] : exports.defaultBadgePosition.layer,\n        responsive: serialized['responsive'] != null ? serialized['responsive'] : exports.defaultBadgePosition.responsive,\n    };\n}\nexports.deserializeBadgeEnumPosition = deserializeBadgeEnumPosition;\nfunction serializeBadgeEnumPosition(position) {\n    if (position == null) {\n        return {\n            'horiz': exports.defaultBadgePosition.horizontalPos,\n            'vert': exports.defaultBadgePosition.verticalPos,\n            'layer': exports.defaultBadgePosition.layer,\n            'responsive': exports.defaultBadgePosition.responsive,\n        };\n    }\n    return {\n        'horiz': position.horizontalPos,\n        'vert': position.verticalPos,\n        'layer': position.layer,\n        'responsive': position.responsive,\n    };\n}\nexports.serializeBadgeEnumPosition = serializeBadgeEnumPosition;\nfunction serializeBadgeEnumPositionAsKey(position) {\n    return JSON.stringify(position);\n}\nexports.serializeBadgeEnumPositionAsKey = serializeBadgeEnumPositionAsKey;\nfunction isValidSerializedBadgeEnumPosition(val) {\n    // All fields are optional, so it's fine if they're not present\n    const horizValid = val['horiz'] == undefined || Object.values(HorizontalBadgePos).includes(val['horiz']);\n    const vertValid = val['vert'] == undefined || Object.values(VerticalBadgePos).includes(val['vert']);\n    const layerValid = val['layer'] == undefined || Object.values(BadgeLayerPos).includes(val['layer']);\n    const responsiveValid = val['responsive'] == undefined || Object.values(BadgeResponsiveness).includes(val['responsive']);\n    return horizValid && vertValid && layerValid && responsiveValid;\n}\nexports.isValidSerializedBadgeEnumPosition = isValidSerializedBadgeEnumPosition;\nfunction isHorizontalPos(maybePos) {\n    if ((0, checks_1.isNumber)(maybePos)) {\n        return !!HorizontalBadgePos[maybePos];\n    }\n    return false;\n}\nexports.isHorizontalPos = isHorizontalPos;\nfunction isVerticalPos(maybePos) {\n    if ((0, checks_1.isNumber)(maybePos)) {\n        return !!VerticalBadgePos[maybePos];\n    }\n    return false;\n}\nexports.isVerticalPos = isVerticalPos;\nfunction isLayerPos(maybePos) {\n    if ((0, checks_1.isNumber)(maybePos)) {\n        return !!BadgeLayerPos[maybePos];\n    }\n    return false;\n}\nexports.isLayerPos = isLayerPos;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/properties/datagraphic/datagraphicindexes.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/properties/datagraphic/datagraphicindexes.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.areDataGraphicImagesEqual = exports.areDataGraphicIconIndexesEqual = exports.DataGraphicIconSets = void 0;\nvar DataGraphicIconSets;\n(function (DataGraphicIconSets) {\n    // Custom icons are a user-defined set of uploaded icons, not a predefined set of icons\n    DataGraphicIconSets[DataGraphicIconSets[\"CUSTOM_ICONS\"] = -1] = \"CUSTOM_ICONS\";\n    DataGraphicIconSets[DataGraphicIconSets[\"STATUS_ICONS\"] = 0] = \"STATUS_ICONS\";\n    DataGraphicIconSets[DataGraphicIconSets[\"STATUS_CIRCLES\"] = 1] = \"STATUS_CIRCLES\";\n    DataGraphicIconSets[DataGraphicIconSets[\"STOPLIGHTS\"] = 2] = \"STOPLIGHTS\";\n    DataGraphicIconSets[DataGraphicIconSets[\"TOGGLES\"] = 3] = \"TOGGLES\";\n    DataGraphicIconSets[DataGraphicIconSets[\"COMPLETION_PIES\"] = 4] = \"COMPLETION_PIES\";\n    DataGraphicIconSets[DataGraphicIconSets[\"TRENDING_ARROWS\"] = 5] = \"TRENDING_ARROWS\";\n    DataGraphicIconSets[DataGraphicIconSets[\"STATUS_CHECK_BOXES\"] = 6] = \"STATUS_CHECK_BOXES\";\n    DataGraphicIconSets[DataGraphicIconSets[\"TRENDING_ARROWS_FLIPPED\"] = 7] = \"TRENDING_ARROWS_FLIPPED\";\n})(DataGraphicIconSets || (exports.DataGraphicIconSets = DataGraphicIconSets = {}));\nfunction areDataGraphicIconIndexesEqual(a, b) {\n    return a.set == b.set && a.index == b.index && areDataGraphicImagesEqual(a.iconImage, b.iconImage);\n}\nexports.areDataGraphicIconIndexesEqual = areDataGraphicIconIndexesEqual;\nfunction areDataGraphicImagesEqual(a, b) {\n    if (a == undefined || b == undefined) {\n        return a == b;\n    }\n    return a.w == b.w && a.h == b.h && a.url == b.url;\n}\nexports.areDataGraphicImagesEqual = areDataGraphicImagesEqual;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/properties/datagraphic/datagraphicindexes.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/properties/datagraphic/staticdatagraphicsettings.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/properties/datagraphic/staticdatagraphicsettings.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedSimpleStaticDataGraphicSettings = exports.deserializeSimpleStaticDataGraphicSettings = exports.serializeSimpleStaticDataGraphicSettings = void 0;\nconst checks_1 = __webpack_require__(/*! ../../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst badgeposition_1 = __webpack_require__(/*! ./badgeposition */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\");\nfunction serializeSimpleStaticDataGraphicSettings(settings) {\n    return {\n        'icon': settings.icon,\n        'pos': (0, badgeposition_1.serializeBadgeEnumPosition)(settings.position),\n        'color': settings.color,\n    };\n}\nexports.serializeSimpleStaticDataGraphicSettings = serializeSimpleStaticDataGraphicSettings;\nfunction deserializeSimpleStaticDataGraphicSettings(settings) {\n    return {\n        icon: settings['icon'],\n        position: (0, badgeposition_1.deserializeBadgeEnumPosition)(settings['pos']),\n        color: settings['color'],\n    };\n}\nexports.deserializeSimpleStaticDataGraphicSettings = deserializeSimpleStaticDataGraphicSettings;\nfunction isSerializedSimpleStaticDataGraphicSettings(settings) {\n    return ((0, checks_1.isObjectUnsafe)(settings) &&\n        (0, checks_1.isString)(settings['color']) &&\n        (0, checks_1.isObject)(settings['icon']) &&\n        (0, badgeposition_1.isValidSerializedBadgeEnumPosition)(settings['pos']));\n}\nexports.isSerializedSimpleStaticDataGraphicSettings = isSerializedSimpleStaticDataGraphicSettings;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/properties/datagraphic/staticdatagraphicsettings.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/properties/fillcolor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/properties/fillcolor.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeSimpleFill = exports.SimpleImageFillPosition = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\n/**\n * Different ways of laying out the image in the background of the block.\n */\nvar SimpleImageFillPosition;\n(function (SimpleImageFillPosition) {\n    /** The image retains its original aspect ratio, and is as large as possible while still fitting in the block */\n    SimpleImageFillPosition[\"Fit\"] = \"fit\";\n    /** The image retains its original aspect ratio, and is as small as possible while still completely covering the block */\n    SimpleImageFillPosition[\"Fill\"] = \"fill\";\n    /** The image is stretched to the bounding box of the block */\n    SimpleImageFillPosition[\"Stretch\"] = \"stretch\";\n    /** The image is shown in its original size if possible */\n    SimpleImageFillPosition[\"Original\"] = \"original\";\n    /** The image is tiled in its original size vertically and horizontally to fully cover the block */\n    SimpleImageFillPosition[\"Tile\"] = \"tile\";\n    //TODO: 'mask' but mask requires additional settings\n})(SimpleImageFillPosition || (exports.SimpleImageFillPosition = SimpleImageFillPosition = {}));\n/** @ignore */\nfunction serializeSimpleFill(fill) {\n    if ((0, checks_1.isString)(fill)) {\n        return fill;\n    }\n    else {\n        return {\n            'pos': fill.position,\n            'url': fill.url,\n            'polys': null,\n        };\n    }\n}\nexports.serializeSimpleFill = serializeSimpleFill;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/properties/fillcolor.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/properties/shadow.js":
/*!********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/properties/shadow.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeShadow = exports.serializeShadow = void 0;\nfunction serializeShadow(shadow) {\n    return {\n        'x': shadow.distance * Math.cos(shadow.angle),\n        'y': shadow.distance * Math.sin(shadow.angle),\n        'b': shadow.blur,\n        'c': shadow.color,\n        'ang': shadow.angle,\n    };\n}\nexports.serializeShadow = serializeShadow;\nfunction deserializeShadow(shadow) {\n    var _a;\n    return {\n        distance: Math.sqrt(shadow['x'] * shadow['x'] + shadow['y'] * shadow['y']),\n        angle: (_a = shadow['ang']) !== null && _a !== void 0 ? _a : Math.atan2(shadow['y'], shadow['x']),\n        blur: shadow['b'],\n        color: shadow['c'],\n    };\n}\nexports.deserializeShadow = deserializeShadow;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/properties/shadow.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/properties/strokestyle.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/properties/strokestyle.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertStrokeStyleToBorder = exports.isStrokeStyle = exports.StrokeStyle = void 0;\nvar StrokeStyle;\n(function (StrokeStyle) {\n    StrokeStyle[\"Solid\"] = \"solid\";\n    StrokeStyle[\"Dashed\"] = \"dashed\";\n    StrokeStyle[\"LongDash\"] = \"longdash\";\n    StrokeStyle[\"DashDot\"] = \"dashdot\";\n    StrokeStyle[\"DashDotDot\"] = \"dashdotdot\";\n    StrokeStyle[\"DashLongDash\"] = \"dashlongdash\";\n    StrokeStyle[\"Dashed32\"] = \"dashed32\";\n    StrokeStyle[\"Dashed44\"] = \"dashed44\";\n    StrokeStyle[\"Dashed24\"] = \"dashed24\";\n    StrokeStyle[\"Dotted\"] = \"dotted\";\n    StrokeStyle[\"DotDotDot\"] = \"dotdotdot\";\n    StrokeStyle[\"StripeThinThin\"] = \"stripethinthin\";\n    StrokeStyle[\"StripeThickThick\"] = \"stripethickthick\";\n    StrokeStyle[\"StripeThickThin\"] = \"stripethickthin\";\n    StrokeStyle[\"StripeThinThick\"] = \"stripethinthick\";\n    StrokeStyle[\"StripeThickThinThick\"] = \"stripethickthinthick\";\n    StrokeStyle[\"StripeThinThickThin\"] = \"stripethinthickthin\";\n    StrokeStyle[\"StripeTriple\"] = \"stripetriple\";\n})(StrokeStyle || (exports.StrokeStyle = StrokeStyle = {}));\nconst strokeStyleSet = new Set(Object.values(StrokeStyle));\nfunction isStrokeStyle(value) {\n    return strokeStyleSet.has(value);\n}\nexports.isStrokeStyle = isStrokeStyle;\nfunction convertStrokeStyleToBorder(strokeStyle) {\n    if (strokeStyle.startsWith('dash') || strokeStyle == StrokeStyle.LongDash) {\n        return 'dashed';\n    }\n    else if (strokeStyle.startsWith('dot')) {\n        return 'dotted';\n    }\n    else {\n        return 'solid';\n    }\n}\nexports.convertStrokeStyleToBorder = convertStrokeStyleToBorder;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/properties/strokestyle.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/result.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/result.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isEqual = exports.groupByResultType = exports.isFailure = exports.isSuccess = void 0;\nconst checks_1 = __webpack_require__(/*! ./checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nfunction isSuccess(res) {\n    return (0, checks_1.isDef)(res.value);\n}\nexports.isSuccess = isSuccess;\nfunction isFailure(res) {\n    return (0, checks_1.isDef)(res.error);\n}\nexports.isFailure = isFailure;\nfunction groupByResultType(results) {\n    const successes = [];\n    const failures = [];\n    results.forEach((result) => {\n        if (isSuccess(result)) {\n            successes.push(result);\n        }\n        else {\n            failures.push(result);\n        }\n    });\n    return [successes, failures];\n}\nexports.groupByResultType = groupByResultType;\nfunction isEqual(a, b, valueCompS, valueCompF) {\n    return ((!!a &&\n        !!b &&\n        ((isSuccess(a) && isSuccess(b) && valueCompS(a.value, b.value)) ||\n            (isFailure(a) && isFailure(b) && valueCompF(a.error, b.error)))) ||\n        a == b);\n}\nexports.isEqual = isEqual;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/result.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/rules/conditions.js":
/*!*******************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/rules/conditions.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectedShapesCondition = exports.ShapeTypeConditions = exports.ShapeDataConditions = exports.TextConditions = exports.ConditionCombination = void 0;\nvar ConditionCombination;\n(function (ConditionCombination) {\n    ConditionCombination[\"AND\"] = \"AND\";\n    ConditionCombination[\"OR\"] = \"OR\";\n})(ConditionCombination || (exports.ConditionCombination = ConditionCombination = {}));\nvar TextConditions;\n(function (TextConditions) {\n    TextConditions[TextConditions[\"TextEmpty\"] = 0] = \"TextEmpty\";\n    TextConditions[TextConditions[\"TextNotEmpty\"] = 1] = \"TextNotEmpty\";\n    TextConditions[TextConditions[\"TextContains\"] = 2] = \"TextContains\";\n    TextConditions[TextConditions[\"TextDoesNotContain\"] = 3] = \"TextDoesNotContain\";\n    TextConditions[TextConditions[\"GreaterThan\"] = 8] = \"GreaterThan\";\n    TextConditions[TextConditions[\"GreaterThanOrEqual\"] = 9] = \"GreaterThanOrEqual\";\n    TextConditions[TextConditions[\"LessThan\"] = 10] = \"LessThan\";\n    TextConditions[TextConditions[\"LessThanOrEqual\"] = 11] = \"LessThanOrEqual\";\n    TextConditions[TextConditions[\"Equal\"] = 12] = \"Equal\";\n    TextConditions[TextConditions[\"NotEqual\"] = 13] = \"NotEqual\";\n    TextConditions[TextConditions[\"Between\"] = 14] = \"Between\";\n    TextConditions[TextConditions[\"NotBetween\"] = 15] = \"NotBetween\";\n})(TextConditions || (exports.TextConditions = TextConditions = {}));\nvar ShapeDataConditions;\n(function (ShapeDataConditions) {\n    ShapeDataConditions[ShapeDataConditions[\"TextEmpty\"] = 0] = \"TextEmpty\";\n    ShapeDataConditions[ShapeDataConditions[\"TextNotEmpty\"] = 1] = \"TextNotEmpty\";\n    ShapeDataConditions[ShapeDataConditions[\"TextContains\"] = 2] = \"TextContains\";\n    ShapeDataConditions[ShapeDataConditions[\"TextDoesNotContain\"] = 3] = \"TextDoesNotContain\";\n    /** @deprecated */ ShapeDataConditions[ShapeDataConditions[\"TextEquals\"] = 4] = \"TextEquals\";\n    /** @deprecated */ ShapeDataConditions[ShapeDataConditions[\"TextNotEqual\"] = 5] = \"TextNotEqual\";\n    ShapeDataConditions[ShapeDataConditions[\"TextStartsWith\"] = 6] = \"TextStartsWith\";\n    ShapeDataConditions[ShapeDataConditions[\"TextEndsWith\"] = 7] = \"TextEndsWith\";\n    ShapeDataConditions[ShapeDataConditions[\"GreaterThan\"] = 8] = \"GreaterThan\";\n    ShapeDataConditions[ShapeDataConditions[\"GreaterThanOrEqual\"] = 9] = \"GreaterThanOrEqual\";\n    ShapeDataConditions[ShapeDataConditions[\"LessThan\"] = 10] = \"LessThan\";\n    ShapeDataConditions[ShapeDataConditions[\"LessThanOrEqual\"] = 11] = \"LessThanOrEqual\";\n    ShapeDataConditions[ShapeDataConditions[\"Equal\"] = 12] = \"Equal\";\n    ShapeDataConditions[ShapeDataConditions[\"NotEqual\"] = 13] = \"NotEqual\";\n    ShapeDataConditions[ShapeDataConditions[\"Between\"] = 14] = \"Between\";\n    ShapeDataConditions[ShapeDataConditions[\"NotBetween\"] = 15] = \"NotBetween\";\n})(ShapeDataConditions || (exports.ShapeDataConditions = ShapeDataConditions = {}));\nvar ShapeTypeConditions;\n(function (ShapeTypeConditions) {\n    ShapeTypeConditions[ShapeTypeConditions[\"TextContains\"] = 2] = \"TextContains\";\n    ShapeTypeConditions[ShapeTypeConditions[\"TextDoesNotContain\"] = 3] = \"TextDoesNotContain\";\n})(ShapeTypeConditions || (exports.ShapeTypeConditions = ShapeTypeConditions = {}));\nvar ConnectedShapesCondition;\n(function (ConnectedShapesCondition) {\n    ConnectedShapesCondition[ConnectedShapesCondition[\"GreaterThan\"] = 8] = \"GreaterThan\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"GreaterThanOrEqual\"] = 9] = \"GreaterThanOrEqual\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"LessThan\"] = 10] = \"LessThan\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"LessThanOrEqual\"] = 11] = \"LessThanOrEqual\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"Equal\"] = 12] = \"Equal\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"NotEqual\"] = 13] = \"NotEqual\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"Between\"] = 14] = \"Between\";\n    ConnectedShapesCondition[ConnectedShapesCondition[\"NotBetween\"] = 15] = \"NotBetween\";\n})(ConnectedShapesCondition || (exports.ConnectedShapesCondition = ConnectedShapesCondition = {}));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/rules/conditions.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/rules/conditiontype.js":
/*!**********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/rules/conditiontype.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConditionType = void 0;\nvar ConditionType;\n(function (ConditionType) {\n    ConditionType[ConditionType[\"Text\"] = 0] = \"Text\";\n    ConditionType[ConditionType[\"ShapeData\"] = 1] = \"ShapeData\";\n    ConditionType[ConditionType[\"Formula\"] = 2] = \"Formula\";\n    ConditionType[ConditionType[\"ShapeType\"] = 3] = \"ShapeType\";\n    ConditionType[ConditionType[\"ConnectedShapes\"] = 4] = \"ConnectedShapes\";\n})(ConditionType || (exports.ConditionType = ConditionType = {}));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/rules/conditiontype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/rules/serializedeffect.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/rules/serializedeffect.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RuleFormattingType = void 0;\nvar RuleFormattingType;\n(function (RuleFormattingType) {\n    RuleFormattingType[RuleFormattingType[\"FORMATTING\"] = 0] = \"FORMATTING\";\n    RuleFormattingType[RuleFormattingType[\"DATA_GRAPHICS\"] = 1] = \"DATA_GRAPHICS\";\n    RuleFormattingType[RuleFormattingType[\"STENCIL\"] = 2] = \"STENCIL\";\n})(RuleFormattingType || (exports.RuleFormattingType = RuleFormattingType = {}));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/rules/serializedeffect.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/serializeddataerror.js":
/*!**********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/serializeddataerror.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedDataError = void 0;\nconst checks_1 = __webpack_require__(/*! ./checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nfunction isSerializedDataError(raw) {\n    return (0, checks_1.isObjectUnsafe)(raw) && (0, checks_1.isString)(raw['error']) && (0, checks_1.isNumber)(raw['type']);\n}\nexports.isSerializedDataError = isSerializedDataError;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/serializeddataerror.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/shapedatainheritance.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/shapedatainheritance.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShapeDataInheritance = void 0;\nvar ShapeDataInheritance;\n(function (ShapeDataInheritance) {\n    ShapeDataInheritance[ShapeDataInheritance[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * Really just a UI level of inheritance, where the shape data panel should show the ability for\n     * you to enter a value under this name, and the name isn't editable. Because the default value\n     * for missing data is already empty, there's no need to actually do much down here in the model\n     * layer.\n     */\n    ShapeDataInheritance[ShapeDataInheritance[\"NAME\"] = 1] = \"NAME\";\n    /**\n     * This is true inheritance, where the formula/value of the shape data is available on all\n     * descendant elements. i.e. if a page has a VALUE-inheritable shape data entry, that appears on\n     * every single Element on the page, including all groups and items inside those groups.\n     */\n    ShapeDataInheritance[ShapeDataInheritance[\"VALUE\"] = 2] = \"VALUE\";\n})(ShapeDataInheritance || (exports.ShapeDataInheritance = ShapeDataInheritance = {}));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/shapedatainheritance.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegration.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegration.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidSpreadsheetIntegration = exports.isImportedResults = exports.lucidSpreadsheetIntegrationFailureTypeValidator = exports.LucidSpreadsheetIntegrationFailureType = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst serializedupstreamconfig_1 = __webpack_require__(/*! ../data/datasource/serializedupstreamconfig */ \"./node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js\");\nconst serializedschema_1 = __webpack_require__(/*! ../data/serializedfield/serializedschema */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js\");\nconst jsonserializable_1 = __webpack_require__(/*! ../jsonserializable */ \"./node_modules/lucid-extension-sdk/core/jsonserializable.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nvar LucidSpreadsheetIntegrationFailureType;\n(function (LucidSpreadsheetIntegrationFailureType) {\n    LucidSpreadsheetIntegrationFailureType[\"AuthorizationFailure\"] = \"AuthorizationFailure\";\n    LucidSpreadsheetIntegrationFailureType[\"GenericFailure\"] = \"GenericFailure\";\n    LucidSpreadsheetIntegrationFailureType[\"UserCancelled\"] = \"UserCanceled\";\n})(LucidSpreadsheetIntegrationFailureType || (exports.LucidSpreadsheetIntegrationFailureType = LucidSpreadsheetIntegrationFailureType = {}));\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nexports.lucidSpreadsheetIntegrationFailureTypeValidator = (0, validators_1.stringEnumValidator)(LucidSpreadsheetIntegrationFailureType);\nexports.isImportedResults = (0, validators_1.strictObjectValidator)({\n    'dataSourceId': checks_1.isString,\n    'syncDataSourceId': checks_1.isString,\n    'upstreamConfig': serializedupstreamconfig_1.isSerializedUpstreamConfig,\n    'collections': (0, validators_1.arrayValidator)((0, validators_1.strictObjectValidator)({\n        'collectionId': checks_1.isString,\n        'headerRow': checks_1.isNumber,\n        'schema': serializedschema_1.isSerializedSchema,\n        'upstreamConfig': jsonserializable_1.isJsonSerializable,\n    })),\n});\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nclass LucidSpreadsheetIntegration {\n}\nexports.LucidSpreadsheetIntegration = LucidSpreadsheetIntegration;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegration.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegrationregistry.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegrationregistry.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LucidSpreadsheetIntegrationRegistry = void 0;\nconst lucidspreadsheetintegration_1 = __webpack_require__(/*! ./lucidspreadsheetintegration */ \"./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegration.js\");\n/** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\nclass LucidSpreadsheetIntegrationRegistry {\n    static nextHookName() {\n        return '__lucidspreadsheet__hook' + this.nextHookId++;\n    }\n    /**\n     * Register a spreadsheet integration.\n     */\n    static addSpreadsheetIntegration(client, spreadsheetIntegration) {\n        const getSpreadsheetDetailsToImportActionName = LucidSpreadsheetIntegrationRegistry.nextHookName();\n        client.registerAction(getSpreadsheetDetailsToImportActionName, async () => {\n            try {\n                return await spreadsheetIntegration.getSpreadsheetDetailsToImport();\n            }\n            catch (error) { }\n            return lucidspreadsheetintegration_1.LucidSpreadsheetIntegrationFailureType.GenericFailure;\n        });\n        const getMultipleSheetsForSpreadsheetDetailsActionName = LucidSpreadsheetIntegrationRegistry.nextHookName();\n        client.registerAction(getMultipleSheetsForSpreadsheetDetailsActionName, async (message) => {\n            try {\n                const result = await spreadsheetIntegration.getMultipleSheetsForSpreadsheetDetails(message['spreadsheetDetails']);\n                if ((0, lucidspreadsheetintegration_1.lucidSpreadsheetIntegrationFailureTypeValidator)(result)) {\n                    return result;\n                }\n                else {\n                    // Serialize the Map\n                    return Array.from(result);\n                }\n            }\n            catch (error) { }\n            return lucidspreadsheetintegration_1.LucidSpreadsheetIntegrationFailureType.GenericFailure;\n        });\n        const serialized = {\n            'ld': spreadsheetIntegration.labelDescription,\n            'li': spreadsheetIntegration.labelIconUrl,\n            'dc': spreadsheetIntegration.dataConnectorName,\n            'gs': getSpreadsheetDetailsToImportActionName,\n            'gm': getMultipleSheetsForSpreadsheetDetailsActionName,\n        };\n        client.sendCommand(\"asi\" /* CommandName.AddSpreadsheetIntegration */, serialized);\n    }\n}\nexports.LucidSpreadsheetIntegrationRegistry = LucidSpreadsheetIntegrationRegistry;\nLucidSpreadsheetIntegrationRegistry.nextHookId = 0;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegrationregistry.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/unfurl/unfurlcallbacks.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/unfurl/unfurlcallbacks.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UnfurlCallbackType = void 0;\nvar UnfurlCallbackType;\n(function (UnfurlCallbackType) {\n    UnfurlCallbackType[\"Unfurl\"] = \"u\";\n    UnfurlCallbackType[\"AfterUnfurl\"] = \"a\";\n})(UnfurlCallbackType || (exports.UnfurlCallbackType = UnfurlCallbackType = {}));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/unfurl/unfurlcallbacks.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/unfurl/unfurldetails.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/unfurl/unfurldetails.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeUnfurlDetails = exports.deserializeUnfurlDetails = exports.isValidUnfurlDetails = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst unfurliframe_1 = __webpack_require__(/*! ./unfurliframe */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js\");\nconst unfurlthumbnail_1 = __webpack_require__(/*! ./unfurlthumbnail */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurlthumbnail.js\");\n/** @ignore */\nexports.isValidUnfurlDetails = (0, validators_1.objectValidator)({\n    'ProviderName': checks_1.isString,\n    'ProviderFaviconUrl': checks_1.isString,\n    'UnfurlTitle': (0, validators_1.option)(checks_1.isString),\n    'Iframe': (0, validators_1.option)(unfurliframe_1.isValidUnfurlIframe),\n    'Thumbnails': (0, validators_1.option)((0, validators_1.arrayValidator)(unfurlthumbnail_1.isValidUnfurlThumbnail)),\n    'PreviewImageUrl': (0, validators_1.option)(checks_1.isString),\n});\n/** @ignore */\nfunction deserializeUnfurlDetails(raw) {\n    var _a;\n    return {\n        providerName: raw['ProviderName'],\n        providerFaviconUrl: raw['ProviderFaviconUrl'],\n        unfurlTitle: raw['UnfurlTitle'],\n        iframe: raw['Iframe'] && (0, unfurliframe_1.deserializeUnfurlIframe)(raw['Iframe']),\n        thumbnails: (_a = raw['Thumbnails']) === null || _a === void 0 ? void 0 : _a.map((raw) => (0, unfurlthumbnail_1.deserializeUnfurlThumbnail)(raw)),\n        previewImageUrl: raw['PreviewImageUrl'],\n    };\n}\nexports.deserializeUnfurlDetails = deserializeUnfurlDetails;\n/** @ignore */\nfunction serializeUnfurlDetails(concrete) {\n    var _a;\n    return {\n        'ProviderName': concrete.providerName,\n        'ProviderFaviconUrl': concrete.providerFaviconUrl,\n        'UnfurlTitle': concrete.unfurlTitle,\n        'Iframe': concrete.iframe && (0, unfurliframe_1.serializeUnfurlIframe)(concrete.iframe),\n        'Thumbnails': (_a = concrete.thumbnails) === null || _a === void 0 ? void 0 : _a.map((raw) => (0, unfurlthumbnail_1.serializeUnfurlThumbnail)(raw)),\n        'PreviewImageUrl': concrete.previewImageUrl,\n    };\n}\nexports.serializeUnfurlDetails = serializeUnfurlDetails;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/unfurl/unfurldetails.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js":
/*!**********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.generateIframeAttributes = exports.getIFrameWidth = exports.getIFrameHeight = exports.serializeUnfurlIframe = exports.deserializeUnfurlIframe = exports.isValidUnfurlIframe = exports.UnfurlIframeAspectRatio = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst iframeutils_1 = __webpack_require__(/*! ../iframe/iframeutils */ \"./node_modules/lucid-extension-sdk/core/iframe/iframeutils.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/**\n * An enumeration of of the supported unfurl Iframe aspect ratio.\n * The iframe will be maximized to fit the screen responsively\n */\nvar UnfurlIframeAspectRatio;\n(function (UnfurlIframeAspectRatio) {\n    /**\n     * Aspect ratio 1:1, square\n     */\n    UnfurlIframeAspectRatio[\"Square\"] = \"1:1\";\n    /**\n     * Aspect ratio 16:9, wider rectangle\n     * This will be the default setting if not provided\n     */\n    UnfurlIframeAspectRatio[\"SixteenToNine\"] = \"16:9\";\n    /**\n     * Aspect ratio 9:16, taller rectangle\n     */\n    UnfurlIframeAspectRatio[\"NineToSixteen\"] = \"9:16\";\n    /**\n     * Aspect ratio 4:3, wider rectangle\n     */\n    UnfurlIframeAspectRatio[\"FourToThree\"] = \"4:3\";\n    /**\n     * Aspect ratio 3:4, taller rectangle\n     */\n    UnfurlIframeAspectRatio[\"ThreeToFour\"] = \"3:4\";\n})(UnfurlIframeAspectRatio || (exports.UnfurlIframeAspectRatio = UnfurlIframeAspectRatio = {}));\n/** @ignore */\nexports.isValidUnfurlIframe = (0, validators_1.objectValidator)({\n    'IframeUrl': checks_1.isString,\n    'AspectRatio': (0, validators_1.option)((0, validators_1.stringEnumValidator)(UnfurlIframeAspectRatio)),\n    'IframeTitle': (0, validators_1.option)(checks_1.isString),\n});\n/** @ignore */\nfunction deserializeUnfurlIframe(raw) {\n    return {\n        iframeUrl: raw['IframeUrl'],\n        aspectRatio: raw['AspectRatio'],\n        iframeTitle: raw['IframeTitle'],\n    };\n}\nexports.deserializeUnfurlIframe = deserializeUnfurlIframe;\n/** @ignore */\nfunction serializeUnfurlIframe(concrete) {\n    return {\n        'IframeUrl': concrete.iframeUrl,\n        'AspectRatio': concrete.aspectRatio,\n        'IframeTitle': concrete.iframeTitle,\n    };\n}\nexports.serializeUnfurlIframe = serializeUnfurlIframe;\n/** @ignore */\nfunction getIFrameHeight(unfurlIframeAspectRatio) {\n    switch (unfurlIframeAspectRatio) {\n        case UnfurlIframeAspectRatio.Square:\n            return 1;\n        case UnfurlIframeAspectRatio.SixteenToNine:\n            return 9;\n        case UnfurlIframeAspectRatio.NineToSixteen:\n            return 16;\n        case UnfurlIframeAspectRatio.FourToThree:\n            return 3;\n        case UnfurlIframeAspectRatio.ThreeToFour:\n            return 4;\n        default:\n            return 9;\n    }\n}\nexports.getIFrameHeight = getIFrameHeight;\n/** @ignore */\nfunction getIFrameWidth(unfurlIframeAspectRatio) {\n    switch (unfurlIframeAspectRatio) {\n        case UnfurlIframeAspectRatio.Square:\n            return 1;\n        case UnfurlIframeAspectRatio.SixteenToNine:\n            return 16;\n        case UnfurlIframeAspectRatio.NineToSixteen:\n            return 9;\n        case UnfurlIframeAspectRatio.FourToThree:\n            return 4;\n        case UnfurlIframeAspectRatio.ThreeToFour:\n            return 3;\n        default:\n            return 16;\n    }\n}\nexports.getIFrameWidth = getIFrameWidth;\nfunction generateIframeAttributes(unfurlIframe) {\n    const iframeAttributes = {\n        src: unfurlIframe.iframeUrl,\n        height: unfurlIframe.aspectRatio ? getIFrameHeight(unfurlIframe.aspectRatio) : iframeutils_1.DEFAULT_IFRAME_HEIGHT,\n        width: unfurlIframe.aspectRatio ? getIFrameWidth(unfurlIframe.aspectRatio) : iframeutils_1.DEFAULT_IFRAME_WIDTH,\n        title: unfurlIframe.iframeTitle,\n    };\n    return iframeAttributes;\n}\nexports.generateIframeAttributes = generateIframeAttributes;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/unfurl/unfurlrefresherrortype.js":
/*!********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/unfurl/unfurlrefresherrortype.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unfurlRefreshErrorTypeValidator = exports.UnfurlRefreshErrorType = void 0;\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nvar UnfurlRefreshErrorType;\n(function (UnfurlRefreshErrorType) {\n    UnfurlRefreshErrorType[\"AuthorizationFailure\"] = \"Authorization failure\";\n    UnfurlRefreshErrorType[\"GenericFailure\"] = \"Generic failure\";\n})(UnfurlRefreshErrorType || (exports.UnfurlRefreshErrorType = UnfurlRefreshErrorType = {}));\nexports.unfurlRefreshErrorTypeValidator = (0, validators_1.stringEnumValidator)(UnfurlRefreshErrorType);\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/unfurl/unfurlrefresherrortype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/unfurl/unfurlthumbnail.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/unfurl/unfurlthumbnail.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeUnfurlThumbnail = exports.deserializeUnfurlThumbnail = exports.isValidUnfurlThumbnail = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/** @ignore */\nexports.isValidUnfurlThumbnail = (0, validators_1.objectValidator)({\n    'url': checks_1.isString,\n    'width': (0, validators_1.nullableOption)(checks_1.isNumber),\n    'height': (0, validators_1.nullableOption)(checks_1.isNumber),\n});\n/** @ignore */\nfunction deserializeUnfurlThumbnail(raw) {\n    var _a, _b;\n    return {\n        url: raw['url'],\n        width: (_a = raw['width']) !== null && _a !== void 0 ? _a : undefined,\n        height: (_b = raw['height']) !== null && _b !== void 0 ? _b : undefined,\n    };\n}\nexports.deserializeUnfurlThumbnail = deserializeUnfurlThumbnail;\n/** @ignore */\nfunction serializeUnfurlThumbnail(concrete) {\n    return {\n        'url': concrete.url,\n        'width': concrete.width,\n        'height': concrete.height,\n    };\n}\nexports.serializeUnfurlThumbnail = serializeUnfurlThumbnail;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/unfurl/unfurlthumbnail.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/validators/validators.js":
/*!************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/validators/validators.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.asAssertion = exports.validatorWithMessage = exports.minLengthValidator = exports.maxLengthValidator = exports.isDate = exports.isPositiveNumber = exports.isSize = exports.isPanelSize = exports.isBoundingBox = exports.isPointLike = exports.isOpacity = exports.isTrue = exports.isFlag = exports.isRestrictions = exports.isStringOrNegativeOne = exports.isBooleanOrEmptyString = exports.isNumberOrEmptyString = exports.isSet = exports.propertyValidator = exports.exclude = exports.both = exports.either = exports.isNullOption = exports.nullableOption = exports.option = exports.nullable = exports.objectOfValidator = exports.recordValidator = exports.strictObjectValidator = exports.partialObjectValidator = exports.objectValidator = exports.mapValidator = exports.someValidator = exports.someValue = exports.tupleValidator = exports.arrayValidator = exports.rangeValidator = exports.enumValidator = exports.stringEnumValidator = void 0;\nconst checks_1 = __webpack_require__(/*! ../checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst object_1 = __webpack_require__(/*! ../object */ \"./node_modules/lucid-extension-sdk/core/object.js\");\n/*********************************************************************************\n * Validator generators:  These functions construct new composite validators\n *from elemental validators.\n ********************************************************************************/\n/**\n * Creates a validator which tests if the target is a string\n * and is one of the values in the specified enum (object).\n */\nfunction stringEnumValidator(enumMap) {\n    const enumValues = new Set();\n    for (const key in enumMap) {\n        const enumValue = enumMap[key];\n        if ((0, checks_1.isString)(enumValue)) {\n            enumValues.add(enumValue);\n        }\n    }\n    // this allows using Set:has on unknown type\n    const unknownEnumValues = enumValues;\n    return (x) => {\n        return unknownEnumValues.has(x);\n    };\n}\nexports.stringEnumValidator = stringEnumValidator;\n/**\n * Creates a validator which tests if the target is a value in the specified enum.\n * Note that numbers in enums are reverse-mapped by the TS transpiler, so the specified keys are also values.\n */\nfunction enumValidator(enumMap) {\n    return (x) => {\n        for (const key in enumMap) {\n            if (enumMap[key] === x) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexports.enumValidator = enumValidator;\n/**\n * Creates a validator which tests if the target is a number\n * and is equal to or between the min and max values.\n *\n */\nfunction rangeValidator(min, max) {\n    return (x) => {\n        return (0, checks_1.isNumber)(x) && x >= min && x <= max;\n    };\n}\nexports.rangeValidator = rangeValidator;\n/**\n * Creates a validator which tests if the target is an array\n * and if all elements of the array satisfy the given\n * sub-validator.\n *\n * @return A validator for the array type\n */\nfunction arrayValidator(subValidator) {\n    return (x) => {\n        return (0, checks_1.isArray)(x) && x.every(subValidator);\n    };\n}\nexports.arrayValidator = arrayValidator;\n/**\n * Creates a validator for a fixed width array where each entry\n * in the array can have a separate validator\n */\nfunction tupleValidator(...tupleValidators) {\n    return (x) => {\n        return (typeof x === 'object' &&\n            tupleValidators.length === x.length &&\n            tupleValidators.every((subX, index) => subX(x[index])));\n    };\n}\nexports.tupleValidator = tupleValidator;\n/**\n * Creates a validator that the given unknown is one of the supplied values\n */\nfunction someValue(...values) {\n    return (x) => {\n        for (const value of values) {\n            if (x === value) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexports.someValue = someValue;\n/**\n * Creates a validator that the given unknown matches at least one of the given validators\n */\nfunction someValidator(...validators) {\n    return (x) => {\n        for (const validator of validators) {\n            if (validator(x)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nexports.someValidator = someValidator;\n/**\n * Creates a validator which tests if the target is an object\n * and if all values in the object satisfy the given sub-validator.\n * This does *not* perform any tests on the object keys, which\n * are allowed to be arbitrary strings.\n *\n * @return A validator for the map\n * Note that unlike objectValidator, this performs no validation on the names or\n * number of the keys and treats all values equally\n */\nfunction mapValidator(subValidator) {\n    return (x) => {\n        return (0, checks_1.isObject)(x) && !(0, checks_1.isArray)(x) && (0, object_1.objectEvery)(x, subValidator);\n    };\n}\nexports.mapValidator = mapValidator;\n/**\n * Creates a validator which tests if the target is an object\n * and if the structure of the object matches the structure of the passed-in\n * validator object.  The values in the validator object are in turn\n * validators.  This means that if the validator object has a (key,value)\n * pair of the form ('key', keyValidator), then in order for the target object\n * (x) to match, keyValidator(x['key']) must return true for all keys in the\n * validatorStructure.\n *\n * Note that you can use `lucid.validators.option` to create optional parameters\n * in validation structure.\n */\nfunction objectValidator(validatorStructure) {\n    return (subject) => {\n        if ((0, checks_1.isArray)(subject) || !(0, checks_1.isObjectUnsafe)(subject)) {\n            return false;\n        }\n        else {\n            return (0, object_1.objectEvery)(validatorStructure, (validator, key) => {\n                return validator(subject[key]);\n            });\n        }\n    };\n}\nexports.objectValidator = objectValidator;\n/**\n * Creates a validator which tests if the target is an object\n * and if the structure of the object matches the structure of the passed-in\n * validator object, but with every entry being optional.\n */\nfunction partialObjectValidator(validatorStructure) {\n    return (subject) => {\n        if ((0, checks_1.isArray)(subject) || !(0, checks_1.isObjectUnsafe)(subject)) {\n            return false;\n        }\n        else {\n            return (0, object_1.objectEvery)(validatorStructure, (validator, key) => {\n                return subject[key] === undefined || validator(subject[key]);\n            });\n        }\n    };\n}\nexports.partialObjectValidator = partialObjectValidator;\n/**\n * Similar to {@link objectValidator}, but if the object has any non-undefined keys, they must also be present in the validator structure.\n * This is useful for things where extra data is unwanted, like Property serialization.\n * the loose version is often prefered because this one makes backwards compatible changes to the data harder,\n * because it requires an additional PR when the data transfers between services:\n * 1. A PR that adds the option() to this validator; 2. A PR that sends the new data; 3. A PR to remove the option();\n * compared to the (non-strict)objectValidator steps:\n * 1. A PR that adds the option() to this validator and sends the new data; 2. A PR to remove the option();\n */\nfunction strictObjectValidator(validatorStructure) {\n    const looseValidator = objectValidator(validatorStructure);\n    return (subject) => {\n        return (looseValidator(subject) &&\n            (0, object_1.objectEvery)(subject, (subx, key) => subx === undefined || validatorStructure.hasOwnProperty(key)));\n    };\n}\nexports.strictObjectValidator = strictObjectValidator;\nfunction recordValidator(keyList, valueValidator) {\n    return (x) => {\n        return ((0, checks_1.isObject)(x) &&\n            !(0, checks_1.isArray)(x) &&\n            keyList.every((k) => k in x) &&\n            (0, object_1.objectEvery)(x, (val, key) => {\n                return valueValidator(val);\n            }));\n    };\n}\nexports.recordValidator = recordValidator;\nfunction objectOfValidator(subValidator) {\n    return (x) => {\n        if ((0, checks_1.isArray)(x) || !(0, checks_1.isObject)(x)) {\n            return false;\n        }\n        return Object.values(x).every((val) => subValidator(val));\n    };\n}\nexports.objectOfValidator = objectOfValidator;\n/**\n * Create a validator which allows the target to be either null or satisfy the\n * sub-validator.\n *\n * @return A validator for the array type\n */\nfunction nullable(subValidator) {\n    return (x) => {\n        return x === null || subValidator(x);\n    };\n}\nexports.nullable = nullable;\n/**\n * Create a validator which allows the target to be undefined or satisfy the\n * sub-validator.\n *\n * @return A validator for the array type\n */\nfunction option(subValidator) {\n    return (x) => {\n        return x === undefined || subValidator(x);\n    };\n}\nexports.option = option;\n/**\n * Create a validator which allows the target to be undefined, null, or satisfy\n * the sub-validator.\n *\n * @return A validator for the array type\n */\nfunction nullableOption(subValidator) {\n    return (x) => {\n        return x === null || x === undefined || subValidator(x);\n    };\n}\nexports.nullableOption = nullableOption;\nconst isNullOption = (value) => {\n    return value == null;\n};\nexports.isNullOption = isNullOption;\n/**\n * Create a validator that merges two validators.\n * This is useful for validating properties that have 2 disjoint sets of possible values.\n * e.g. {someObject: string}|false\n */\nfunction either(validatorA, validatorB) {\n    return (x) => {\n        return validatorA(x) || validatorB(x);\n    };\n}\nexports.either = either;\n/**\n * Create a validator that combines two validators.\n * This is useful for validating properties that have been composed of a generic and more specific values.\n */\nfunction both(validatorA, validatorB) {\n    return (x) => {\n        return validatorA(x) && validatorB(x);\n    };\n}\nexports.both = both;\n/**\n * Create a validator that allows types excluding those that satisfy an excludeValidator.\n */\nfunction exclude(validator, excludeValidator) {\n    return (x) => validator(x) && !excludeValidator(x);\n}\nexports.exclude = exclude;\n/**\n * Get a validator which returns whether the property calculation structure is\n * correct.\n */\nfunction propertyValidator(subValidator, preSaveActions) {\n    const processedValidator = (x) => {\n        const y = preSaveActions.reduce((px, psa) => psa(px), x);\n        return subValidator(y);\n    };\n    return strictObjectValidator({ 'Equation': checks_1.isString, 'StaticValue': processedValidator });\n}\nexports.propertyValidator = propertyValidator;\n/*********************************************************************************\n * Validators:  Some useful predefined validator functions.\n ********************************************************************************/\n/**\n * This validator only allows objects whose values are all booleans set to true.\n *\n * @return A validator for the map\n */\nfunction isSet(x) {\n    return (0, checks_1.isObject)(x) && !(0, checks_1.isArray)(x) && (0, object_1.objectEvery)(x, (val) => (0, checks_1.isBoolean)(val) && !!val);\n}\nexports.isSet = isSet;\n/**\n * This validator validates that value is either number or empty string\n */\nexports.isNumberOrEmptyString = either(checks_1.isNumber, (v) => v === '');\n/**\n * This validator validates that value is either boolean or empty string\n */\nexports.isBooleanOrEmptyString = either(checks_1.isBoolean, (v) => v === '');\n/**\n * This validator validates that value is either string or -1\n */\nexports.isStringOrNegativeOne = either(checks_1.isString, (v) => v === -1);\n/**\n * This validator validates model of lucid.model.restrictions\n */\nexports.isRestrictions = strictObjectValidator({\n    'b': nullableOption(checks_1.isBoolean),\n    'p': nullableOption(checks_1.isBoolean),\n    'c': nullableOption(checks_1.isBoolean),\n    'f': nullableOption(checks_1.isBoolean),\n    'o': nullableOption(checks_1.isBoolean),\n    'e': nullableOption(checks_1.isBoolean),\n    'fc': nullableOption(checks_1.isBoolean),\n    'fs': nullableOption(checks_1.isBoolean),\n    'l': nullableOption(checks_1.isBoolean),\n    'i': nullableOption(checks_1.isBoolean),\n    'u': nullableOption(checks_1.isBoolean),\n    'acap': nullableOption(checks_1.isBoolean),\n    'scap': nullableOption(checks_1.isBoolean),\n    'imageCategory': nullableOption(checks_1.isBoolean),\n    'pcad': nullableOption(checks_1.isBoolean),\n});\n/**\n * Returns true if the target is equal to either zero or one or is a boolean.\n *\n */\nfunction isFlag(x) {\n    return x === 0 || x === 1 || (0, checks_1.isBoolean)(x);\n}\nexports.isFlag = isFlag;\nfunction isTrue(x) {\n    return x === true;\n}\nexports.isTrue = isTrue;\n/**\n * Returns if an object is a number between 0 and 100.\n *\n */\nexports.isOpacity = rangeValidator(0, 100);\n/**\n * Tests if the given target satisfies the PointLike interface.\n *\n */\nexports.isPointLike = objectValidator({ x: checks_1.isNumber, y: checks_1.isNumber });\n/**\n * Tests if the given target is a bounding box.\n *\n */\nexports.isBoundingBox = objectValidator({\n    x: checks_1.isNumber,\n    y: checks_1.isNumber,\n    w: checks_1.isNumber,\n    h: checks_1.isNumber,\n});\n/**\n * Tests if the given target is a panel size.\n *\n */\nexports.isPanelSize = objectValidator({\n    x: checks_1.isNumber,\n    y: checks_1.isNumber,\n    w: checks_1.isNumber,\n    h: checks_1.isNumber,\n    'identifier': nullableOption(checks_1.isString),\n});\nexports.isSize = objectValidator({\n    w: checks_1.isNumber,\n    h: checks_1.isNumber,\n});\nfunction isPositiveNumber(x) {\n    return (0, checks_1.isNumber)(x) && x >= 0;\n}\nexports.isPositiveNumber = isPositiveNumber;\nfunction isDate(x) {\n    return x instanceof Date;\n}\nexports.isDate = isDate;\nfunction maxLengthValidator(max) {\n    return (x) => (0, checks_1.isString)(x) && x.length <= max;\n}\nexports.maxLengthValidator = maxLengthValidator;\nfunction minLengthValidator(min) {\n    return (x) => (0, checks_1.isString)(x) && x.length >= min;\n}\nexports.minLengthValidator = minLengthValidator;\nfunction validatorWithMessage(validator, message, sub) {\n    return (x) => (validator(x) ? (sub ? sub(x) : true) : message);\n}\nexports.validatorWithMessage = validatorWithMessage;\nfunction asAssertion(validator) {\n    return (val) => {\n        if (!validator(val)) {\n            throw new Error();\n        }\n    };\n}\nexports.asAssertion = asAssertion;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/validators/validators.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/core/xhr.js":
/*!******************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/core/xhr.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isXHRResponse = exports.isBinaryXHRResponse = exports.isTextXHRResponse = void 0;\nconst checks_1 = __webpack_require__(/*! ./checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ./validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst isBaseXHRResponse = (0, validators_1.objectValidator)({\n    url: checks_1.isString,\n    status: checks_1.isNumber,\n    headers: (0, validators_1.objectOfValidator)(checks_1.isString),\n    timeout: (0, validators_1.option)(checks_1.isBoolean),\n});\nexports.isTextXHRResponse = (0, validators_1.both)(isBaseXHRResponse, (0, validators_1.objectValidator)({\n    responseFormat: (0, checks_1.isLiteral)('utf8'),\n    responseText: checks_1.isString,\n}));\nexports.isBinaryXHRResponse = (0, validators_1.both)(isBaseXHRResponse, (0, validators_1.objectValidator)({\n    responseFormat: (0, checks_1.isLiteral)('binary'),\n    responseData: (0, checks_1.isInstanceOf)(Uint8Array),\n}));\nexports.isXHRResponse = (0, validators_1.either)(exports.isTextXHRResponse, exports.isBinaryXHRResponse);\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/core/xhr.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/branchedcollectionid.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/branchedcollectionid.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.patchCollectionIdFromPossibleBranchedCollectionId = exports.branchedCollectionId = void 0;\n/** @ignore */\nfunction branchedCollectionId(upstreamId) {\n    return upstreamId + '_b';\n}\nexports.branchedCollectionId = branchedCollectionId;\n/** @ignore */\nfunction patchCollectionIdFromPossibleBranchedCollectionId(branchId) {\n    if (branchId && branchId.endsWith('_b')) {\n        return branchId.substring(0, branchId.length - 2);\n    }\n    return undefined;\n}\nexports.patchCollectionIdFromPossibleBranchedCollectionId = patchCollectionIdFromPossibleBranchedCollectionId;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/data/branchedcollectionid.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/collectiondefinition.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/collectiondefinition.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeCollectionDefinition = exports.serializeCollectionDefinition = void 0;\nconst schemadefinition_1 = __webpack_require__(/*! ./schemadefinition */ \"./node_modules/lucid-extension-sdk/data/schemadefinition.js\");\n/** @ignore */\nfunction serializeCollectionDefinition(def) {\n    return {\n        'Schema': (0, schemadefinition_1.serializeSchemaDefinition)(def.schema),\n        'Items': [...def.items.entries()],\n    };\n}\nexports.serializeCollectionDefinition = serializeCollectionDefinition;\n/** @ignore */\nfunction deserializeCollectionDefinition(raw) {\n    return {\n        schema: (0, schemadefinition_1.parseSchemaDefinition)(raw['Schema']),\n        items: new Map(raw['Items']),\n    };\n}\nexports.deserializeCollectionDefinition = deserializeCollectionDefinition;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/data/collectiondefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/collectionerrortypes.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/collectionerrortypes.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CollectionUpstreamSchemaStatus = void 0;\nexports.CollectionUpstreamSchemaStatus = '__CollectionUpstreamSchemaStatus__';\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/data/collectionerrortypes.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/collectionproxy.js":
/*!******************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/collectionproxy.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CollectionProxy = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst mapproxy_1 = __webpack_require__(/*! ../document/mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst propertystoreproxy_1 = __webpack_require__(/*! ../document/propertystoreproxy */ \"./node_modules/lucid-extension-sdk/document/propertystoreproxy.js\");\nconst branchedcollectionid_1 = __webpack_require__(/*! ./branchedcollectionid */ \"./node_modules/lucid-extension-sdk/data/branchedcollectionid.js\");\nconst dataitemproxy_1 = __webpack_require__(/*! ./dataitemproxy */ \"./node_modules/lucid-extension-sdk/data/dataitemproxy.js\");\nconst patchcollectionproxy_1 = __webpack_require__(/*! ./patchcollectionproxy */ \"./node_modules/lucid-extension-sdk/data/patchcollectionproxy.js\");\nconst schemadefinition_1 = __webpack_require__(/*! ./schemadefinition */ \"./node_modules/lucid-extension-sdk/data/schemadefinition.js\");\n/**\n * A collection is a set of data items, each with the same set of fields (though some data items may not have all\n * fields defined).\n */\nclass CollectionProxy extends propertystoreproxy_1.PropertyStoreProxy {\n    /**\n     *\n     * @param id ID of this collection on the current document\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n        /**\n         * The data items in this collection, organized by their primary key. The primary key is usually calculated\n         * from the content of the data item, but may differ from the expected value in some circumstances, e.g. if\n         * there are two data items that would have the same primary key.\n         */\n        this.items = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"ldi\" /* CommandName.ListDataItems */, { 'id': this.id }), (primaryKey) => new dataitemproxy_1.DataItemProxy(primaryKey, this, this.client));\n    }\n    /**\n     * @returns a human-readable name for this collection\n     */\n    getName() {\n        return this.properties.get('Name');\n    }\n    getSyncCollectionId() {\n        const upstreamConfig = this.properties.get('UpstreamConfig');\n        if ((0, checks_1.isObjectUnsafe)(upstreamConfig) && (0, checks_1.isString)(upstreamConfig['SyncId'])) {\n            return upstreamConfig['SyncId'];\n        }\n        return undefined;\n    }\n    /**\n     * Some data collections may have local branches on the document, to store the set of changes that have been\n     * made by the user since the time the data was last refreshed from its source. For those collections, you\n     * can use this method to get the original data collection as it was last imported or refreshed.\n     *\n     * @returns the original collection from which this collection was branched, or undefined if this collection\n     * is not a branch\n     */\n    getBranchedFrom() {\n        const id = this.properties.get('BranchedFrom');\n        return id ? new CollectionProxy(id, this.client) : undefined;\n    }\n    /**\n     * @returns information about any changes made locally to the collection that have not been synchronized\n     * with the external data source.\n     */\n    getLocalChanges() {\n        const patchCollectionId = (0, branchedcollectionid_1.patchCollectionIdFromPossibleBranchedCollectionId)(this.id);\n        const original = this.getBranchedFrom();\n        if (!patchCollectionId || !original) {\n            return undefined;\n        }\n        return new patchcollectionproxy_1.PatchCollectionProxy(this.client, this, new CollectionProxy(patchCollectionId, this.client), original);\n    }\n    patchItems(patch) {\n        var _a, _b;\n        const changed = {};\n        if (patch.changed) {\n            for (const [primaryKey, record] of patch.changed) {\n                changed[primaryKey] = record;\n            }\n        }\n        return this.client.sendCommand(\"pdi\" /* CommandName.PatchDataItems */, {\n            'id': this.id,\n            'a': (_a = patch.added) !== null && _a !== void 0 ? _a : [],\n            'c': changed,\n            'd': (_b = patch.deleted) !== null && _b !== void 0 ? _b : [],\n        });\n    }\n    /**\n     * @returns an array of field names that are accessible on the items in this collection\n     */\n    getFields() {\n        return this.client.sendCommand(\"lcf\" /* CommandName.ListCollectionFields */, { 'id': this.id });\n    }\n    getSchema() {\n        // we wave to cast as unknown because of readonly being used in the type\n        return (0, schemadefinition_1.parseSchemaDefinition)(this.properties.get('Schema'));\n    }\n}\nexports.CollectionProxy = CollectionProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/data/collectionproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/dataerror.js":
/*!************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/dataerror.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataError = void 0;\n/**\n * The requested data or formula result couldn't be calculated.\n */\nclass DataError {\n    /**\n     * @param error A human-readable description of the reason why the error occurred\n     * @param type The kind of error that occurred\n     */\n    constructor(error, type) {\n        this.error = error;\n        this.type = type;\n    }\n}\nexports.DataError = DataError;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/data/dataerror.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/dataitemproxy.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/dataitemproxy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataItemProxy = void 0;\nconst mapproxy_1 = __webpack_require__(/*! ../document/mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * One data item in a collection, consisting of key-value pairs\n */\nclass DataItemProxy {\n    /**\n     * @param primaryKey The current primary key of the data item. This may change if the fields on the data item change, rendering this proxy inoperable.\n     * @param collection The collection that contains this data item.\n     * @param client\n     */\n    constructor(primaryKey, collection, client) {\n        this.primaryKey = primaryKey;\n        this.collection = collection;\n        this.client = client;\n        /**\n         * The fields on this data item, organized by their name.\n         */\n        this.fields = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lcf\" /* CommandName.ListCollectionFields */, { 'id': this.collection.id }), (name) => this.client.sendCommand(\"gdif\" /* CommandName.GetDataItemField */, {\n            'c': this.collection.id,\n            'pk': this.primaryKey,\n            'f': name,\n        }));\n    }\n    /**\n     * @returns True if a data item exists in this collection at this primary key\n     */\n    exists() {\n        return this.client.sendCommand(\"die\" /* CommandName.DataItemExists */, { 'c': this.collection.id, 'pk': this.primaryKey });\n    }\n}\nexports.DataItemProxy = DataItemProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/data/dataitemproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/dataproxy.js":
/*!************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/dataproxy.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataProxy = void 0;\nconst mapproxy_1 = __webpack_require__(/*! ../document/mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst datasourceproxy_1 = __webpack_require__(/*! ./datasourceproxy */ \"./node_modules/lucid-extension-sdk/data/datasourceproxy.js\");\n/**\n * The DataProxy class gives access to the tabular and graph data on the current Lucid document.\n *\n * Data collections are organized into data sources. One data sources is typically produced for\n * each data import, and may contain multiple collections.\n */\nclass DataProxy {\n    constructor(client) {\n        this.client = client;\n        /**\n         * Data sources on the current document, organized by their ID on this document. The ID will\n         * remain stable for as long as the data source exists on this document, but will vary from\n         * the data source ID on other documents if the same data is imported there.\n         */\n        this.dataSources = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lds\" /* CommandName.ListDataSources */, undefined), (dataSourceId) => new datasourceproxy_1.DataSourceProxy(dataSourceId, this.client));\n    }\n    /**\n     * Creates a new empty data source, which you can then add collections of data to.\n     *\n     * @param name Human-readable name of the new data source\n     * @param sourceConfig Any configuration values that might be useful to reference later, such\n     *  as the upstream origin of this data source\n     * @returns the newly created data source\n     */\n    addDataSource(name, sourceConfig) {\n        return new datasourceproxy_1.DataSourceProxy(this.client.sendCommand(\"cds\" /* CommandName.CreateDataSource */, { 'n': name, 's': sourceConfig }), this.client);\n    }\n}\nexports.DataProxy = DataProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/data/dataproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/datasourceproxy.js":
/*!******************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/datasourceproxy.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataSourceProxy = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../core/data/fieldtypedefinition/fieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst mapproxy_1 = __webpack_require__(/*! ../document/mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst propertystoreproxy_1 = __webpack_require__(/*! ../document/propertystoreproxy */ \"./node_modules/lucid-extension-sdk/document/propertystoreproxy.js\");\nconst collectionproxy_1 = __webpack_require__(/*! ./collectionproxy */ \"./node_modules/lucid-extension-sdk/data/collectionproxy.js\");\n/**\n * A data source represents a set of related data collections on a document. Typically one data source\n * is produced for each data import.\n */\nclass DataSourceProxy extends propertystoreproxy_1.PropertyStoreProxy {\n    /**\n     * @param id ID of the dataSource on the current document\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n        /**\n         * The set of data collections in this data source, organized by ID on this document. The IDs will\n         * remain stable for as long as the collection exists on this document, but will vary from\n         * the collection ID on other documents if the same data is imported there.\n         */\n        this.collections = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lc\" /* CommandName.ListCollections */, { 'id': this.id }), (id) => new collectionproxy_1.CollectionProxy(id, this.client));\n    }\n    /**\n     * Create a new collection as part of this data source.\n     * @param name\n     * @param schema\n     * @returns The newly created collection\n     */\n    addCollection(name, schema) {\n        return new collectionproxy_1.CollectionProxy(this.client.sendCommand(\"cc\" /* CommandName.CreateCollection */, {\n            's': this.id,\n            'n': name,\n            'f': schema.fields.map((field) => {\n                return { 'n': field.name, 't': (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(field.type) };\n            }),\n            'p': schema.primaryKey,\n            'fl': schema.fieldLabels,\n        }), this.client);\n    }\n    /**\n     * @returns A human-readable name for this data source\n     */\n    getName() {\n        return this.properties.get('Name');\n    }\n    /**\n     * @returns The source configuration values set when this data source was created\n     */\n    getSourceConfig() {\n        const upstream = this.properties.get('Upstream');\n        if ((0, checks_1.isObjectUnsafe)(upstream)) {\n            return upstream['SourceConfig'];\n        }\n        return {};\n    }\n}\nexports.DataSourceProxy = DataSourceProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/data/datasourceproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataUpdateFilterType = void 0;\n/** Allows Lucid documents to determine what updates they will receive when changes happen in the data source */\nvar DataUpdateFilterType;\n(function (DataUpdateFilterType) {\n    /** All updates relevant to the data source will be sent to the document, new items created in the data source will be added to the document. Note that the in the `documentCollections` mapping in the `DataConnectorActionContext` will not have a list of all items in it with the DataUpdateFilterType selected */\n    DataUpdateFilterType[\"AllUpdates\"] = \"AllUpdates\";\n    /** All updates relevant to collections already present on the document will be sent to that document, new items added to those collections in the data source will be added to the document. Note that the `documentCollections` mapping in the `DataConnectorActionContext` will not have a list of all items in it with the DataUpdateFilterType selected */\n    DataUpdateFilterType[\"CurrentCollectionUpdates\"] = \"CurrentCollectionUpdates\";\n    /** All updates to items already present on the document will be sent to the document. New items created in the data source will not be created on the document. */\n    DataUpdateFilterType[\"CurrentItemUpdates\"] = \"CurrentItemUpdates\";\n})(DataUpdateFilterType || (exports.DataUpdateFilterType = DataUpdateFilterType = {}));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/patchcollectionproxy.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/patchcollectionproxy.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PatchCollectionProxy = exports.PatchedDataItemProxy = void 0;\nconst dataitemproxy_1 = __webpack_require__(/*! ./dataitemproxy */ \"./node_modules/lucid-extension-sdk/data/dataitemproxy.js\");\nclass PatchedDataItemProxy extends dataitemproxy_1.DataItemProxy {\n    constructor(primaryKey, collection, \n    /**\n     * The names of all fields that have been changed locally on this data item and\n     * not yet synced back to the external data source.\n     */\n    changedFields, \n    /**\n     * The original data item, before local changes. You can query the original values\n     * for the changedFields from this data item.\n     */\n    original, client) {\n        super(primaryKey, collection, client);\n        this.changedFields = changedFields;\n        this.original = original;\n    }\n}\nexports.PatchedDataItemProxy = PatchedDataItemProxy;\nclass PatchCollectionProxy {\n    /**\n     * Use CollectionProxy.getLocalChanges() to get a PatchCollectionProxy rather\n     * than constructing one directly.\n     */\n    constructor(client, branchedCollection, patchCollection, originalCollection) {\n        this.client = client;\n        this.branchedCollection = branchedCollection;\n        this.patchCollection = patchCollection;\n        this.originalCollection = originalCollection;\n    }\n    /**\n     * @returns all data items that have been added to this collection locally, but that\n     * have not yet been synced back to the external data source.\n     */\n    getAddedItems() {\n        //Note: We could get this list directly from the metadata collection associated with the\n        //patch collection, but at this time we're not sure we want to expose metadata collections\n        //to the extension API, so this somewhat less-performance-optimal solution seems like the\n        //best overall answer.\n        return this.patchCollection.items.filter((item, primaryKey) => !this.originalCollection.items.get(primaryKey).exists());\n    }\n    /**\n     * @returns all data items that were deleted from this collection locally, but that\n     * have not yet been deleted in the external data source.\n     */\n    getDeletedItems() {\n        //See comment in getAddedItems\n        return this.originalCollection.items.filter((item, primaryKey) => !this.branchedCollection.items.get(primaryKey).exists());\n    }\n    /**\n     * @returns all data items that have been changed locally, but that have not\n     * yet been synced back to the external data source.\n     */\n    getChangedItems() {\n        const changed = [];\n        for (const [primaryKey, patchItem] of this.patchCollection.items) {\n            const original = this.originalCollection.items.get(primaryKey);\n            if (original.exists()) {\n                //Not just using .keys() because we want to filter out undefined values,\n                //which the `for...of` iterator on patchItem.fields (MapProxy) does for us.\n                const changedFields = [];\n                for (const [key] of patchItem.fields) {\n                    changedFields.push(key);\n                }\n                changed.push(new PatchedDataItemProxy(primaryKey, this.branchedCollection, changedFields, original, this.client));\n            }\n        }\n        return changed;\n    }\n}\nexports.PatchCollectionProxy = PatchCollectionProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/data/patchcollectionproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/referencekeydefinition.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/referencekeydefinition.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseReferenceKeyDefinition = exports.serializeReferenceKeyDefinition = exports.isCollectionReferenceKeyDefinition = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst serializedreferencekey_1 = __webpack_require__(/*! ../core/data/referencekeys/serializedreferencekey */ \"./node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js\");\nconst schemadefinition_1 = __webpack_require__(/*! ./schemadefinition */ \"./node_modules/lucid-extension-sdk/data/schemadefinition.js\");\n/** @ignore */\nfunction isCollectionReferenceKeyDefinition(def) {\n    return (0, checks_1.isString)(def.collectionId);\n}\nexports.isCollectionReferenceKeyDefinition = isCollectionReferenceKeyDefinition;\n/** @ignore */\nfunction serializeReferenceKeyDefinition(def) {\n    if (isCollectionReferenceKeyDefinition(def)) {\n        return {\n            'cid': def.collectionId,\n            'pk': def.primaryKey,\n            'wl': def.fieldWhitelist,\n            'ro': def.readonly,\n        };\n    }\n    else {\n        return {\n            'sc': (0, schemadefinition_1.serializeSchemaDefinition)(def.schema),\n            'n': def.name,\n            'd': def.data,\n        };\n    }\n}\nexports.serializeReferenceKeyDefinition = serializeReferenceKeyDefinition;\n/** @ignore */\nfunction parseReferenceKeyDefinition(def) {\n    if ((0, serializedreferencekey_1.isTypedSerializedFlattenedReference)(def)) {\n        return {\n            schema: (0, schemadefinition_1.parseSchemaDefinition)(def['sc']),\n            name: def['n'],\n            data: def['d'],\n        };\n    }\n    else if ((0, serializedreferencekey_1.isUnTypedSerializedFlattenedReference)(def)) {\n        throw new Error('Untyped serialized flattened references not implemented');\n    }\n    else {\n        return {\n            collectionId: def['cid'],\n            primaryKey: def['pk'],\n            fieldWhitelist: def['wl'],\n            readonly: def['ro'],\n        };\n    }\n}\nexports.parseReferenceKeyDefinition = parseReferenceKeyDefinition;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/data/referencekeydefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/referencekeyproxy.js":
/*!********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/referencekeyproxy.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReferenceKeyProxy = void 0;\nconst serializedreferencekey_1 = __webpack_require__(/*! ../core/data/referencekeys/serializedreferencekey */ \"./node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js\");\nconst collectionproxy_1 = __webpack_require__(/*! ./collectionproxy */ \"./node_modules/lucid-extension-sdk/data/collectionproxy.js\");\nconst referencekeydefinition_1 = __webpack_require__(/*! ./referencekeydefinition */ \"./node_modules/lucid-extension-sdk/data/referencekeydefinition.js\");\nclass ReferenceKeyProxy {\n    constructor(elementId, key, client, settings) {\n        this.elementId = elementId;\n        this.key = key;\n        this.client = client;\n        this.settings = settings;\n    }\n    get collectionId() {\n        if ((0, serializedreferencekey_1.isSerializedFlattenedReference)(this.settings)) {\n            return undefined;\n        }\n        return this.settings['cid'];\n    }\n    get primaryKey() {\n        if ((0, serializedreferencekey_1.isSerializedFlattenedReference)(this.settings)) {\n            return undefined;\n        }\n        return this.settings['pk'];\n    }\n    get definition() {\n        return (0, referencekeydefinition_1.parseReferenceKeyDefinition)(this.settings);\n    }\n    getItem() {\n        const collectionId = this.collectionId;\n        if ((0, serializedreferencekey_1.isSerializedFlattenedReference)(this.settings) || !collectionId) {\n            throw new Error('Not implemented for flattened references');\n        }\n        return new collectionproxy_1.CollectionProxy(collectionId, this.client).items.get(this.settings['pk']);\n    }\n}\nexports.ReferenceKeyProxy = ReferenceKeyProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/data/referencekeyproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/data/schemadefinition.js":
/*!*******************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/data/schemadefinition.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseSchemaDefinition = exports.parseFieldDefinition = exports.serializeSchemaDefinition = exports.serializeFieldDefinition = exports.serializeFieldConstraintDefinition = exports.isFieldConstraintDefinition = exports.minMaxFieldConstraintValidator = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../core/data/fieldtypedefinition/fieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst serializedfielddefinition_1 = __webpack_require__(/*! ../core/data/serializedfield/serializedfielddefinition */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js\");\nconst validators_1 = __webpack_require__(/*! ../core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nfunction minMaxFieldConstraintValidator(val) {\n    return val === serializedfielddefinition_1.FieldConstraintType.MIN_VALUE || val === serializedfielddefinition_1.FieldConstraintType.MAX_VALUE;\n}\nexports.minMaxFieldConstraintValidator = minMaxFieldConstraintValidator;\nexports.isFieldConstraintDefinition = (0, validators_1.both)((0, validators_1.objectValidator)({\n    'type': serializedfielddefinition_1.isFieldConstraintType,\n}), (0, validators_1.either)((0, validators_1.objectValidator)({ 'type': minMaxFieldConstraintValidator, 'value': checks_1.isNumber }), (0, validators_1.objectValidator)({ 'type': (0, validators_1.exclude)(serializedfielddefinition_1.isFieldConstraintType, minMaxFieldConstraintValidator), 'value': checks_1.isUndefined })));\n/** @ignore */\nfunction serializeFieldConstraintDefinition(constraint) {\n    return {\n        'Type': constraint.type,\n        'Details': constraint.value,\n    };\n}\nexports.serializeFieldConstraintDefinition = serializeFieldConstraintDefinition;\n/** @ignore */\nfunction serializeFieldDefinition(field) {\n    const serialized = {\n        'Name': field.name,\n        'Type': (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(field.type),\n    };\n    if (field.constraints) {\n        serialized['Constraints'] = field.constraints.map(serializeFieldConstraintDefinition);\n    }\n    if (field.mapping) {\n        serialized['Mapping'] = field.mapping;\n    }\n    return serialized;\n}\nexports.serializeFieldDefinition = serializeFieldDefinition;\n/** @ignore */\nfunction serializeSchemaDefinition(def) {\n    return {\n        'Fields': def.fields.map(serializeFieldDefinition),\n        'PrimaryKey': def.primaryKey,\n        'FieldLabelOverrides': def.fieldLabels,\n    };\n}\nexports.serializeSchemaDefinition = serializeSchemaDefinition;\n/** @ignore */\nfunction parseFieldDefinition(field) {\n    var _a;\n    return {\n        name: field['Name'],\n        type: (0, fieldtypedefinition_1.deserializeFieldTypeDefinition)(field['Type']),\n        constraints: (_a = field['Constraints']) === null || _a === void 0 ? void 0 : _a.map((constraint) => {\n            switch (constraint['Type']) {\n                case serializedfielddefinition_1.FieldConstraintType.MIN_VALUE:\n                case serializedfielddefinition_1.FieldConstraintType.MAX_VALUE:\n                    if (!(0, checks_1.isNumber)(constraint['Details'])) {\n                        throw new Error('Invalid constraint format');\n                    }\n                    return { type: constraint['Type'], value: constraint['Details'] };\n                case serializedfielddefinition_1.FieldConstraintType.REQUIRED:\n                case serializedfielddefinition_1.FieldConstraintType.LOCKED:\n                case serializedfielddefinition_1.FieldConstraintType.SINGLE_LINE_ONLY:\n                case serializedfielddefinition_1.FieldConstraintType.NO_WHITESPACE:\n                case serializedfielddefinition_1.FieldConstraintType.UNIQUE_EDIT:\n                    return { type: constraint['Type'] };\n                default:\n                    throw new Error('Invalid constraint format');\n            }\n        }),\n        mapping: field['Mapping'],\n    };\n}\nexports.parseFieldDefinition = parseFieldDefinition;\n/** @ignore */\nfunction parseSchemaDefinition(def) {\n    return {\n        fields: def['Fields'].map(parseFieldDefinition),\n        primaryKey: def['PrimaryKey'],\n        fieldLabels: def['FieldLabelOverrides'],\n    };\n}\nexports.parseSchemaDefinition = parseSchemaDefinition;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/data/schemadefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/actions/action.js":
/*!**************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/actions/action.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataConnectorManageWebhookAction = exports.Webhook = exports.DataConnectorPatchAction = exports.Patch = exports.DataConnectorSynchronousAction = exports.DataConnectorAsynchronousAction = exports.DataConnectorAction = exports.DataConnectorActionContext = void 0;\nconst dataconnectoractionkeys_1 = __webpack_require__(/*! ./dataconnectoractionkeys */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js\");\nconst patchresponsebody_1 = __webpack_require__(/*! ./patchresponsebody */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js\");\n/**\n * This holds all the contextual information about a give data action.\n */\nclass DataConnectorActionContext {\n    constructor(\n    /** The package ID of the extension that triggered this action */\n    packageId, \n    /** The version of the extension that triggered this action */\n    packageVersion, \n    /** The authorized OAuth2 credential that Lucid has for the 3rd party this extension works with */\n    userCredential, \n    /** The data connector name from manifest.json that triggered this action */\n    dataConnectorName, \n    /** The installation id of the extension/user that triggered this action */\n    installationId, \n    /** Set of items this document is tracking as a `Record<CollectionId, ItemPrimaryKey[]>` */\n    documentCollections, \n    /** Update filter type for this document */\n    updateFilterType) {\n        this.packageId = packageId;\n        this.packageVersion = packageVersion;\n        this.userCredential = userCredential;\n        this.dataConnectorName = dataConnectorName;\n        this.installationId = installationId;\n        this.documentCollections = documentCollections;\n        this.updateFilterType = updateFilterType;\n    }\n}\nexports.DataConnectorActionContext = DataConnectorActionContext;\n/** Base class for actions to be performed by data connectors */\nclass DataConnectorAction {\n    constructor(name, context) {\n        this.name = name;\n        this.context = context;\n    }\n}\nexports.DataConnectorAction = DataConnectorAction;\n/**\n * A generic \"asynchronous\" action to be performed by the data connector. This is an action that reports back to Lucid\n * by calling back in the DataSourceClient rather than returning a meaningful value.\n **/\nclass DataConnectorAsynchronousAction extends DataConnectorAction {\n    constructor(name, context, client, data) {\n        super(name, context);\n        this.client = client;\n        this.data = data;\n    }\n}\nexports.DataConnectorAsynchronousAction = DataConnectorAsynchronousAction;\n/**\n * A generic \"synchronous\" action to be performed by the data connector.\n **/\nclass DataConnectorSynchronousAction extends DataConnectorAction {\n    constructor(name, context, data) {\n        super(name, context);\n        this.data = data;\n    }\n}\nexports.DataConnectorSynchronousAction = DataConnectorSynchronousAction;\n/** A patch to be applied against the 3rd party datasource with changes coming from Lucid */\nclass Patch {\n    constructor(\n    /** The id of the patch */\n    id, \n    /** Mapping of item primary keys to new items introduced by Lucid */\n    itemsAdded, \n    /** Mapping of item primary keys to sparse changesets of pre-existing items changed by Lucid */\n    itemsChanged, \n    /** List of item primary keys deleted by Lucid */\n    itemsDeleted, \n    /** */\n    itemOrderChanged, \n    /** The syncSourceId of the changed data source */\n    syncSourceId, \n    /** The syncCollectionId of the changed collection */\n    syncCollectionId) {\n        this.id = id;\n        this.itemsAdded = itemsAdded;\n        this.itemsChanged = itemsChanged;\n        this.itemsDeleted = itemsDeleted;\n        this.itemOrderChanged = itemOrderChanged;\n        this.syncSourceId = syncSourceId;\n        this.syncCollectionId = syncCollectionId;\n    }\n    getChange(collections = []) {\n        return new patchresponsebody_1.PatchChange(this.id, this.syncSourceId, collections);\n    }\n}\nexports.Patch = Patch;\n/**\n * A patch action is a kind of synchronous style action. It occurs when data is changed in the Lucid editor. All the\n * changes are collected in the patches field.\n **/\nclass DataConnectorPatchAction extends DataConnectorAction {\n    constructor(context, \n    /** changes applied by Lucid */ patches, client, name = dataconnectoractionkeys_1.DataConnectorActionKeys.Patch) {\n        super(name, context);\n        this.patches = patches;\n        this.client = client;\n    }\n}\nexports.DataConnectorPatchAction = DataConnectorPatchAction;\n/**\n * A description of an existing webhook that Lucid is keeping track of.\n **/\nclass Webhook {\n    constructor(\n    /** Set of items this webhook is tracking as a `Record<CollectionId, ItemPrimaryKey[]>` */\n    documentCollections, \n    /** Arbitrary extra data to allow the data connector to better identitify the webhook. */\n    webhookData) {\n        this.documentCollections = documentCollections;\n        this.webhookData = webhookData;\n    }\n}\nexports.Webhook = Webhook;\n/**\n * A \"synchronous\" style action indicating that Lucid would like to setup a webhook in the third party.\n */\nclass DataConnectorManageWebhookAction extends DataConnectorAction {\n    constructor(context, \n    /**\n     * Token to be added to the newly created webhook so that when it fires it will have permissions to make changes\n     * to Lucid documents.\n     */\n    webhookToken, \n    /**\n     * A list of existing webhooks so you can be more granular about what you track. You may also find it useful to\n     * delete some of the existing webhooks. The response back to Lucid should include all existing webhooks (newly\n     * created or any of these that were not deleted).\n     **/\n    webhooks) {\n        super(dataconnectoractionkeys_1.DataConnectorActionKeys.ManageWebhook, context);\n        this.webhookToken = webhookToken;\n        this.webhooks = webhooks;\n    }\n}\nexports.DataConnectorManageWebhookAction = DataConnectorManageWebhookAction;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/dataconnector/actions/action.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/** List of keys that are special kinds of actions and thus have more specific result types than just unknown */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataConnectorActionKeys = void 0;\nvar DataConnectorActionKeys;\n(function (DataConnectorActionKeys) {\n    DataConnectorActionKeys[\"ManageWebhook\"] = \"ManageWebhook\";\n    DataConnectorActionKeys[\"Patch\"] = \"Patch\";\n    DataConnectorActionKeys[\"UnbatchedPatch\"] = \"UnbatchedPatch\";\n})(DataConnectorActionKeys || (exports.DataConnectorActionKeys = DataConnectorActionKeys = {}));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/actions/managewebhookresponsebody.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/actions/managewebhookresponsebody.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeManageWebhookResponse = void 0;\n/** Convert the ManageWebhookResponse to Lucid's wire format */\nfunction serializeManageWebhookResponse(webhookResponse) {\n    return {\n        'documentCollections': webhookResponse.documentCollections,\n        'webhookData': webhookResponse.webhookData,\n    };\n}\nexports.serializeManageWebhookResponse = serializeManageWebhookResponse;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/dataconnector/actions/managewebhookresponsebody.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializePatchChanges = exports.serializePatchResponse = exports.PatchErrorTooltipField = exports.PatchChange = void 0;\nconst object_1 = __webpack_require__(/*! ../../core/object */ \"./node_modules/lucid-extension-sdk/core/object.js\");\nconst datasourceupdatetypes_1 = __webpack_require__(/*! ../datasourceupdatetypes */ \"./node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js\");\n/**\n * Reports a completed change back to Lucid\n */\nclass PatchChange {\n    constructor(patchId, syncId, collections) {\n        this.patchId = patchId;\n        this.syncId = syncId;\n        this.collections = collections;\n        this.errors = {};\n    }\n    setError(primaryKey, fieldName, error) {\n        if (!(primaryKey in this.errors)) {\n            this.errors[primaryKey] = {};\n        }\n        this.errors[primaryKey][fieldName] = error;\n    }\n    setTooltipError(primaryKey, error) {\n        this.setError(primaryKey, exports.PatchErrorTooltipField, error);\n    }\n    getErrors() {\n        return this.errors;\n    }\n}\nexports.PatchChange = PatchChange;\n/** Placeholder field name for tool tip errors */\nexports.PatchErrorTooltipField = '__canvasTooltipDataSyncError__';\n/** Convert a Patch change to our wire format */\nfunction serializePatchResponse(patchChange) {\n    return {\n        'syncId': patchChange.syncId,\n        'collections': patchChange.collections.map((c) => {\n            return {\n                'collectionId': c.collectionId,\n                'itemsPatch': (0, datasourceupdatetypes_1.serializeItemsPatch)(c.itemsPatch),\n            };\n        }),\n    };\n}\nexports.serializePatchResponse = serializePatchResponse;\nfunction serializePatchChanges(changes) {\n    const joinedErrors = {};\n    for (const changeGroup of changes) {\n        for (const change of changeGroup) {\n            for (const [primaryKey, fieldNames] of Object.entries(change.getErrors())) {\n                for (const [fieldName, error] of Object.entries(fieldNames)) {\n                    if (!(change.patchId in joinedErrors)) {\n                        joinedErrors[change.patchId] = {};\n                    }\n                    const patchErrors = joinedErrors[change.patchId];\n                    if (!(primaryKey in patchErrors)) {\n                        patchErrors[primaryKey] = {};\n                    }\n                    const primaryKeyErrors = patchErrors[primaryKey];\n                    primaryKeyErrors[fieldName] = error;\n                }\n            }\n        }\n    }\n    return {\n        'changes': (0, object_1.flatten)(changes.map((changeList) => changeList.map((change) => serializePatchResponse(change)))),\n        'errors': joinedErrors,\n    };\n}\nexports.serializePatchChanges = serializePatchChanges;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/actions/serializedactions.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/actions/serializedactions.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeActions = exports.actionsHeaderValidator = void 0;\nconst dataupdatefiltertype_1 = __webpack_require__(/*! ../../data/dataupdatefiltertype */ \"./node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js\");\nconst checks_1 = __webpack_require__(/*! ../../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst action_1 = __webpack_require__(/*! ./action */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/action.js\");\nconst dataconnectoractionkeys_1 = __webpack_require__(/*! ./dataconnectoractionkeys */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js\");\nexports.actionsHeaderValidator = (0, validators_1.objectValidator)({\n    'x-lucid-rsa-nonce': checks_1.isString,\n    'x-lucid-signature': checks_1.isString,\n});\nconst serializedActionsBaseValidator = (0, validators_1.objectValidator)({\n    action: (0, validators_1.objectValidator)({ name: checks_1.isString, data: checks_1.isUnknown }),\n    packageId: checks_1.isString,\n    packageVersion: (0, validators_1.nullableOption)(checks_1.isString),\n    dataConnectorName: checks_1.isString,\n    installationId: (0, validators_1.nullableOption)(checks_1.isString),\n    userCredential: (0, validators_1.nullableOption)(checks_1.isString),\n    documentUpdateToken: (0, validators_1.nullableOption)(checks_1.isString),\n    documentCollections: (0, validators_1.objectOfValidator)((0, validators_1.arrayValidator)(checks_1.isString)),\n    updateFilterType: (0, validators_1.enumValidator)(dataupdatefiltertype_1.DataUpdateFilterType),\n});\nconst serializedPatchDataValidator = (0, validators_1.objectValidator)({\n    packageVersion: checks_1.isString,\n    patches: (0, validators_1.arrayValidator)((0, validators_1.objectValidator)({\n        patch: (0, validators_1.objectValidator)({\n            itemsAdded: (0, validators_1.objectOfValidator)(checks_1.isObjectUnsafe),\n            itemsChanged: (0, validators_1.objectOfValidator)(checks_1.isObjectUnsafe),\n            itemsDeleted: (0, validators_1.arrayValidator)(checks_1.isString),\n            itemOrderChanged: (0, validators_1.nullableOption)((0, validators_1.arrayValidator)((0, validators_1.tupleValidator)(checks_1.isString, (0, validators_1.nullable)(checks_1.isString)))),\n            syncSourceId: checks_1.isString,\n            syncCollectionId: checks_1.isString,\n            adapterType: (0, checks_1.isLiteral)('EXTENSION_API'),\n            syncSchema: checks_1.isUnknown,\n        }),\n        id: checks_1.isString,\n    })),\n    userCredential: checks_1.isString,\n    documentUpdateToken: checks_1.isString,\n});\nconst parseSerializedPatches = (patches) => {\n    return patches.map((patch) => {\n        var _a;\n        const p = patch['patch'];\n        return new action_1.Patch(patch['id'], p['itemsAdded'], p['itemsChanged'], p['itemsDeleted'], (_a = p['itemOrderChanged']) !== null && _a !== void 0 ? _a : undefined, p['syncSourceId'], p['syncCollectionId']);\n    });\n};\nconst serializedManageWebhookDataValidator = (0, validators_1.objectValidator)({\n    webhooks: (0, validators_1.arrayValidator)((0, validators_1.objectValidator)({\n        documentCollections: (0, validators_1.objectOfValidator)((0, validators_1.arrayValidator)(checks_1.isString)),\n        webhookData: (0, validators_1.option)(checks_1.isUnknown),\n    })),\n    webhookToken: checks_1.isString,\n});\n/** Function to convert the lucid action wire format into a clean list of actions */\nfunction deserializeActions(client, actions) {\n    if (!serializedActionsBaseValidator(actions)) {\n        return;\n    }\n    const name = actions['action']['name'];\n    const data = actions['action']['data'];\n    if (name === dataconnectoractionkeys_1.DataConnectorActionKeys.Patch) {\n        if (!(0, validators_1.arrayValidator)(serializedPatchDataValidator)(data)) {\n            console.log(`Failing validation step`);\n            return;\n        }\n        return data.map((item) => {\n            const context = new action_1.DataConnectorActionContext(actions['packageId'], item['packageVersion'], item['userCredential'], actions['dataConnectorName'], actions['dataConnectorName'], actions['documentCollections'], actions['updateFilterType']);\n            const patches = parseSerializedPatches(item['patches']);\n            return new action_1.DataConnectorPatchAction(context, patches, client.getDataSourceClient(item['documentUpdateToken']));\n        });\n    }\n    if (!actions['packageVersion'] || !actions['userCredential']) {\n        return;\n    }\n    if (name === dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch) {\n        if (!serializedPatchDataValidator(data)) {\n            return;\n        }\n        const context = new action_1.DataConnectorActionContext(actions['packageId'], actions['packageVersion'], actions['userCredential'], actions['dataConnectorName'], actions['dataConnectorName'], actions['documentCollections'], actions['updateFilterType']);\n        return [\n            new action_1.DataConnectorPatchAction(context, parseSerializedPatches(data['patches']), client.getDataSourceClient(data['documentUpdateToken']), dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch),\n        ];\n    }\n    const context = new action_1.DataConnectorActionContext(actions['packageId'], actions['packageVersion'], actions['userCredential'], actions['dataConnectorName'], actions['dataConnectorName'], actions['documentCollections'], actions['updateFilterType']);\n    if (name == 'ManageWebhook') {\n        if (!serializedManageWebhookDataValidator(data)) {\n            return;\n        }\n        const webhooks = data['webhooks'].map((webhook) => new action_1.Webhook(webhook['documentCollections'], webhook['webhookData']));\n        return [new action_1.DataConnectorManageWebhookAction(context, data['webhookToken'], webhooks)];\n    }\n    if (actions['documentUpdateToken']) {\n        return [\n            new action_1.DataConnectorAsynchronousAction(name, context, client.getDataSourceClient(actions['documentUpdateToken']), data),\n        ];\n    }\n    return [new action_1.DataConnectorSynchronousAction(name, context, data)];\n}\nexports.deserializeActions = deserializeActions;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/dataconnector/actions/serializedactions.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/dataconnector.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/dataconnector.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataConnector = exports.DataConnectorResponseError = exports.DataConnectorRequestError = exports.DataConnectorRunError = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst action_1 = __webpack_require__(/*! ./actions/action */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/action.js\");\nconst dataconnectoractionkeys_1 = __webpack_require__(/*! ./actions/dataconnectoractionkeys */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/dataconnectoractionkeys.js\");\nconst managewebhookresponsebody_1 = __webpack_require__(/*! ./actions/managewebhookresponsebody */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/managewebhookresponsebody.js\");\nconst patchresponsebody_1 = __webpack_require__(/*! ./actions/patchresponsebody */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js\");\nconst debugserver_1 = __webpack_require__(/*! ./debugserver */ \"./node_modules/lucid-extension-sdk/dataconnector/debugserver.js\");\n/** Throw this from an action request handler to produce a non-200 response code and not have to return the expected\n * result type */\nclass DataConnectorRunError extends Error {\n    constructor(status, body, message) {\n        super(message !== null && message !== void 0 ? message : JSON.stringify(body));\n        this.status = status;\n        this.body = body;\n    }\n    static withMessage(status, message) {\n        return new DataConnectorRunError(status, { error: message }, message);\n    }\n}\nexports.DataConnectorRunError = DataConnectorRunError;\n/** Thrown by any failable http APIs */\nclass DataConnectorRequestError extends Error {\n    constructor(status, message, response, statusText) {\n        super(message);\n        this.status = status;\n        this.response = response;\n        this.statusText = statusText;\n    }\n    toString() {\n        return `${this.message} ${this.statusText ? this.statusText + ' ' : ''}(${this.status}) ${this.response}`;\n    }\n}\nexports.DataConnectorRequestError = DataConnectorRequestError;\n/** Thrown by any APIs the client didn't recognize when parsing */\nclass DataConnectorResponseError extends Error {\n    constructor(message, response) {\n        super(message);\n        this.response = response;\n    }\n}\nexports.DataConnectorResponseError = DataConnectorResponseError;\n/** Factory class to define a bunch of action handlers. */\nclass DataConnector {\n    constructor(client) {\n        this.client = client;\n        this.actions = {};\n        this.routes = {};\n    }\n    /** Factory to define an action request handler */\n    defineAction(name, request, asynchronous = false) {\n        this.actions[name] = { actionResponder: request, asynchronous };\n        return this;\n    }\n    /** Factory to define an asynchronous action request handler */\n    defineAsynchronousAction(name, request) {\n        return this.defineAction(name, request, true);\n    }\n    /** Factory to define a route handler */\n    defineRoute(name, request) {\n        this.routes[name] = request;\n        return this;\n    }\n    /** Call a defined action handler and gather its serialized response */\n    async runAction(url, headers, body) {\n        const actions = await this.client.parseActions(url, headers, body);\n        if (!actions) {\n            console.warn('Received bad request', url, headers, body);\n            return { status: 404, body: { error: 'Bad request' } };\n        }\n        const actionName = actions[0].name;\n        try {\n            const responses = [];\n            for (const action of actions) {\n                if (!(action.name in this.actions)) {\n                    throw DataConnectorRunError.withMessage(404, `Action ${action.name} is not implemented`);\n                }\n                const { actionResponder, asynchronous } = this.actions[action.name];\n                const response = (() => {\n                    if (asynchronous) {\n                        if (!(action instanceof action_1.DataConnectorAsynchronousAction)) {\n                            throw DataConnectorRunError.withMessage(400, `Passing uncredentialed action to ${action.name} which is defined to be asynchronous`);\n                        }\n                        return actionResponder(action);\n                    }\n                    else {\n                        return actionResponder(action);\n                    }\n                })();\n                responses.push(await response);\n            }\n            if (actionName === dataconnectoractionkeys_1.DataConnectorActionKeys.ManageWebhook) {\n                const response = responses[0];\n                // leave the type on this variable because our return type isn't strict. This means that\n                // changes to serializeManageWebhookResponse's return type will need to consider this point\n                const body = (0, managewebhookresponsebody_1.serializeManageWebhookResponse)(response);\n                return { status: 200, body };\n            }\n            if (actionName === dataconnectoractionkeys_1.DataConnectorActionKeys.Patch || actionName === dataconnectoractionkeys_1.DataConnectorActionKeys.UnbatchedPatch) {\n                const responsesCasted = responses;\n                // leave the type on this variable because our return type isn't strict. This means that\n                // changes to serializePatchChanges's return type will need to consider this point\n                const body = (0, patchresponsebody_1.serializePatchChanges)(responsesCasted);\n                return { status: 200, body };\n            }\n            else if (responses.length === 1) {\n                return { status: 200, body: responses[0] };\n            }\n            else {\n                return { status: 200, body: responses };\n            }\n        }\n        catch (e) {\n            const errorLogger = console.error ? console.error : console.log;\n            errorLogger(`Error running ${actionName} action`, e);\n            if (isDataConnectorRunError(e)) {\n                return { status: e.status, body: e.body };\n            }\n            else {\n                return { status: 500, body: { error: `error running ${actionName} action` } };\n            }\n        }\n    }\n    /** Add a route to the given express app (or generate a new app) to serve this data connector */\n    routeDebugServer(options) {\n        return (0, debugserver_1.routeDebugServer)(this, options);\n    }\n    /**\n     * Serve this data connector as a simple express app for debugging purposes\n     */\n    runDebugServer(options) {\n        (0, debugserver_1.runDebugServer)(this, options);\n    }\n}\nexports.DataConnector = DataConnector;\n// instanceof DataConnectorRunError will not work in some environments\nconst isDataConnectorRunError = (0, validators_1.objectValidator)({\n    status: checks_1.isNumber,\n    body: checks_1.isUnknown,\n});\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/dataconnector/dataconnector.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/dataconnectorclient.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/dataconnectorclient.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MockDataConnectorClient = exports.DataConnectorClient = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst serializedactions_1 = __webpack_require__(/*! ./actions/serializedactions */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/serializedactions.js\");\nconst datasourceclient_1 = __webpack_require__(/*! ./datasourceclient */ \"./node_modules/lucid-extension-sdk/dataconnector/datasourceclient.js\");\nconst defaultfetchfunction_1 = __webpack_require__(/*! ./defaultfetchfunction */ \"./node_modules/lucid-extension-sdk/dataconnector/defaultfetchfunction.js\");\nconst signaturevalidator_1 = __webpack_require__(/*! ./signaturevalidator */ \"./node_modules/lucid-extension-sdk/dataconnector/signaturevalidator.js\");\nconst throwunsuccessful_1 = __webpack_require__(/*! ./throwunsuccessful */ \"./node_modules/lucid-extension-sdk/dataconnector/throwunsuccessful.js\");\nconst LUCID_URLS = { main: 'https://lucid.app/', api: 'https://api.lucid.co/' };\n/**\n * Client for requests to and from Lucid\n */\nclass DataConnectorClient {\n    constructor(cryptoDependencies, urls = LUCID_URLS, fetchMethod = defaultfetchfunction_1.globalFetch) {\n        this.cryptoDependencies = cryptoDependencies;\n        this.urls = urls;\n        this.fetchMethod = fetchMethod;\n        this.cachedPublicKey = undefined;\n    }\n    /** Get a client for DataSource related requests to Lucid */\n    getDataSourceClient(updateToken) {\n        return new datasourceclient_1.DataSourceClient(this.urls, updateToken, this.fetchMethod);\n    }\n    /** Get a validator to prove a given request came from Lucid */\n    async getSignatureValidator() {\n        return new signaturevalidator_1.SignatureValidator(this.cryptoDependencies, await this.getPublicKey());\n    }\n    /** Get Lucid's public key to verify requests came from Lucid if you don't want to use the SignatureValidator. Maybe\n     * you're not running in a NodeJS environment */\n    async getPublicKey() {\n        if (!this.cachedPublicKey) {\n            const url = `${this.urls.main}.well-known/pem/TPCP`;\n            const result = await this.fetchMethod(url);\n            await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'getting public key');\n            this.cachedPublicKey = await result.text();\n        }\n        return this.cachedPublicKey;\n    }\n    /** Validate and parse an action request from Lucid */\n    async parseActions(url, headers, actions) {\n        if (!(0, serializedactions_1.actionsHeaderValidator)(headers)) {\n            return;\n        }\n        if (!(await this.getSignatureValidator()).validate(actions, headers, url)) {\n            return;\n        }\n        return (0, serializedactions_1.deserializeActions)(this, actions);\n    }\n    /** @ignore */\n    async getSecretFromWebhook(webhookUpdateToken, WebhookValidationSecret) {\n        // todo: this should be using the public API\n        const result = await this.fetchMethod(`${this.urls.dataSync}webhookAuthorization`, {\n            headers: {\n                'data-update-token': webhookUpdateToken,\n                'webhook-validation-secret': JSON.stringify(WebhookValidationSecret),\n            },\n        });\n        await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'getting secret from webhook');\n        const responseBody = await result.json();\n        if ((0, checks_1.isString)(responseBody)) {\n            return responseBody;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /** @ignore */\n    async getCustomWebhookData(webhookUpdateToken) {\n        const result = await this.fetchMethod(`${this.urls.dataSync}customWebhookData`, {\n            headers: { 'data-update-token': webhookUpdateToken },\n        });\n        await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'getting custom webhook data');\n        return (await result.json());\n    }\n    /** @ignore */\n    async patchCustomWebhookData(webhookUpdateToken, patch) {\n        // todo: this should be using the public API\n        const result = await this.fetchMethod(`${this.urls.dataSync}customWebhookData`, {\n            method: 'PATCH',\n            'headers': {\n                'Content-Type': 'application/json',\n                'data-update-token': webhookUpdateToken,\n                'Lucid-Api-Version': '1',\n            },\n            body: JSON.stringify(patch),\n        });\n        await (0, throwunsuccessful_1.throwUnsuccessful)(result, 'patching custom webhook data');\n        return (await result.json());\n    }\n}\nexports.DataConnectorClient = DataConnectorClient;\n/** Use this for writing automated tests for your data connector */\nclass MockDataConnectorClient extends DataConnectorClient {\n    constructor() {\n        super(undefined);\n        /** set properties on this to modify how data source updates are mocked */\n        this.dataSourceClient = new datasourceclient_1.MockDataSourceClient();\n    }\n    /** @ignore */\n    getDataSourceClient(updateToken) {\n        return this.dataSourceClient;\n    }\n    /** Mocked version just always returns successful */\n    getSignatureValidator() {\n        return Promise.resolve(new signaturevalidator_1.MockSignatureValidator());\n    }\n    /** Mocked version returns an empty string */\n    getPublicKey() {\n        return Promise.resolve('');\n    }\n}\nexports.MockDataConnectorClient = MockDataConnectorClient;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/dataconnector/dataconnectorclient.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/datasourceclient.js":
/*!****************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/datasourceclient.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MockDataSourceClient = exports.DataSourceClient = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst datasourcetype_1 = __webpack_require__(/*! ../core/data/datasource/datasourcetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js\");\nconst upstreamconfig_1 = __webpack_require__(/*! ../core/data/datasource/upstreamconfig */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreamconfig.js\");\nconst upstreampatchtype_1 = __webpack_require__(/*! ../core/data/datasource/upstreampatchtype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js\");\nconst upstreamupdatetype_1 = __webpack_require__(/*! ../core/data/datasource/upstreamupdatetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js\");\nconst result_1 = __webpack_require__(/*! ../core/result */ \"./node_modules/lucid-extension-sdk/core/result.js\");\nconst validators_1 = __webpack_require__(/*! ../core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst dataconnector_1 = __webpack_require__(/*! ./dataconnector */ \"./node_modules/lucid-extension-sdk/dataconnector/dataconnector.js\");\nconst datasourcemetadatatypes_1 = __webpack_require__(/*! ./datasourcemetadatatypes */ \"./node_modules/lucid-extension-sdk/dataconnector/datasourcemetadatatypes.js\");\nconst datasourceupdatetypes_1 = __webpack_require__(/*! ./datasourceupdatetypes */ \"./node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js\");\nconst defaultfetchfunction_1 = __webpack_require__(/*! ./defaultfetchfunction */ \"./node_modules/lucid-extension-sdk/dataconnector/defaultfetchfunction.js\");\nconst throwunsuccessful_1 = __webpack_require__(/*! ./throwunsuccessful */ \"./node_modules/lucid-extension-sdk/dataconnector/throwunsuccessful.js\");\nconst QueryParamLengthLimit = 2000;\n/**\n * Authenticated client for DataSource related requests to Lucid.\n */\nclass DataSourceClient {\n    constructor(urls, updateToken, fetchMethod = defaultfetchfunction_1.globalFetch) {\n        this.urls = urls;\n        this.updateToken = updateToken;\n        this.fetchMethod = fetchMethod;\n        const dataSyncUrl = urls.dataSync;\n        this.metadataUrl = (0, checks_1.isString)(dataSyncUrl) ? `${dataSyncUrl}dataSource/metadata` : undefined;\n    }\n    formatBody({ dataSourceName, collections, updateFilterType, dataSourceConfiguration }) {\n        var _a;\n        const updateData = {};\n        for (const collectionId in collections) {\n            updateData[collectionId] = (0, datasourceupdatetypes_1.serializeCollectionPatch)(collections[collectionId]);\n        }\n        const updateFilterTypeObj = updateFilterType ? { 'UpdateFilterType': updateFilterType } : {};\n        const upstreamConfig = {\n            dataSourceType: datasourcetype_1.DataSourceType.DataService,\n            updateType: upstreamupdatetype_1.UpstreamUpdateType.EVENTPULL,\n            patchType: (_a = dataSourceConfiguration === null || dataSourceConfiguration === void 0 ? void 0 : dataSourceConfiguration.patchType) !== null && _a !== void 0 ? _a : upstreampatchtype_1.UpstreamPatchType.AUTO,\n            sourceConfig: Object.assign({}, updateFilterTypeObj),\n        };\n        return {\n            'updateData': updateData,\n            'name': dataSourceName,\n            'upstreamConfig': (0, upstreamconfig_1.serializeUpstreamConfig)(upstreamConfig),\n        };\n    }\n    /** Create or update a datasource. If you create a new collection it must be fully specified in terms of schema and\n     * and items. If it's just an update then the schema can be omitted (if unchanged) and items that already exist can\n     * be partial.*/\n    async update(request) {\n        const response = await this.fetchMethod(`${this.urls.api}data/dataSource/update`, {\n            'method': 'POST',\n            'headers': {\n                'Content-Type': 'application/json',\n                'data-update-token': this.updateToken,\n                'Lucid-Api-Version': '1',\n            },\n            'body': JSON.stringify(this.formatBody(request)),\n        });\n        await (0, throwunsuccessful_1.throwUnsuccessful)(response, 'updating data source');\n        // webhooks return 200 with an empty body\n        // document updates return valid json\n        // we can't use .json because that will fail for webhooks\n        // if we update the response type for webhook updates\n        // we can handle that here too. We should probably unify the responses\n        // to be meaningful\n        // we could just:\n        // return await response.text();\n        // but lets avoid users trying to interpret the response\n    }\n    /**\n     * When dealing with data, we can often have a very large number of collections in a single data source, and in\n     * turn, we may well end up get the values for a very large number of metadata values per collection.\n     * Because the endpoints for metadata use query params to encode the metadata names, and because metadata value\n     * reads can be easily parallelized, and because URLs have length limits, this function constructs an array of\n     * query params that are certain to be short enough that each individual query will be a safe length, while still\n     * getting *all* of the requested data.\n     * @param keys The metadata keys we are requesting from the data sync service for the corresponding data source.\n     * @param prefixes The metadata prefixes we are requesting from the data sync service for the corresponding data source.\n     * @returns An array of query params such that each query param is short enough to be safe, but all params combined\n     *             cover all requested metadata.\n     */\n    getLengthLimitedQueryParams(keys, prefixes) {\n        const keyQueryParams = keys.map(encodeURIComponent).map((keyVal) => `metadataKeys=${keyVal}`);\n        const prefixQueryParams = prefixes.map(encodeURIComponent).map((prefixVal) => `metadataPrefixes=${prefixVal}`);\n        const fullQueryParams = [];\n        let currentQueryParam = '';\n        let delimiter = '?';\n        [...keyQueryParams, ...prefixQueryParams].forEach((param) => {\n            currentQueryParam = currentQueryParam.concat(`${delimiter}${param}`);\n            if (currentQueryParam.length > QueryParamLengthLimit) {\n                fullQueryParams.push(currentQueryParam);\n                currentQueryParam = '';\n                delimiter = '?';\n            }\n            else {\n                delimiter = '&';\n            }\n        });\n        if (currentQueryParam.length > 0) {\n            fullQueryParams.push(currentQueryParam);\n        }\n        return fullQueryParams;\n    }\n    async getResponseOrError(url) {\n        const response = await this.fetchMethod(url, {\n            'method': 'GET',\n            'headers': {\n                'Content-Type': 'application/json',\n                'data-update-token': this.updateToken,\n                'Lucid-Api-Version': '1',\n            },\n        });\n        try {\n            await (0, throwunsuccessful_1.throwUnsuccessful)(response, 'getting data source`s metadata');\n        }\n        catch (e) {\n            if (e instanceof dataconnector_1.DataConnectorResponseError) {\n                return { error: { url, body: e.response } };\n            }\n            throw e;\n        }\n        const responseBody = await response.json();\n        if ((0, validators_1.arrayValidator)(datasourcemetadatatypes_1.isSerializedMetadataRecord)(responseBody)) {\n            return {\n                value: responseBody.map((rawResponse) => {\n                    return {\n                        key: rawResponse['key'],\n                        value: rawResponse['value'],\n                    };\n                }),\n            };\n        }\n        else {\n            return {\n                error: { url, body: responseBody },\n            };\n        }\n    }\n    /** @ignore until metadata endpoints are made part of the public API */\n    async getMetadata(keys, prefixes = []) {\n        if (this.metadataUrl == null) {\n            throw new Error('Attempted to access data sync service metadata endpoints in environment where the URL does not exist!');\n        }\n        const queryParamsList = this.getLengthLimitedQueryParams(keys, prefixes);\n        const urlsWithParams = queryParamsList.map((query) => `${this.metadataUrl}${query}`);\n        const responsePromises = urlsWithParams.map((url) => this.getResponseOrError(url));\n        const responses = await Promise.all(responsePromises);\n        const records = [];\n        const errors = [];\n        responses.forEach((response) => {\n            if ((0, result_1.isSuccess)(response)) {\n                records.push(...response.value);\n            }\n            else {\n                errors.push(response.error);\n            }\n        });\n        if (errors.length > 0) {\n            const message = `Error(s) received accessing URL(s): ${errors.map(({ url }) => url).join(',')}`;\n            const allBodies = errors.map(({ body }) => body);\n            throw new dataconnector_1.DataConnectorResponseError(message, JSON.stringify(allBodies));\n        }\n        return records;\n    }\n    /** @ignore until metadata endpoints are made part of the public API */\n    async patchMetadata(patches) {\n        if (this.metadataUrl == null) {\n            throw new Error('Attempted to access data sync service metadata endpoints in environment where the URL does not exist!');\n        }\n        const serializedPatches = patches.map((patch) => {\n            return {\n                'key': patch.key,\n                'oldValue': patch.oldValue,\n                'newValue': patch.newValue,\n            };\n        });\n        const response = await this.fetchMethod(this.metadataUrl, {\n            'method': 'PATCH',\n            'headers': {\n                'Content-Type': 'application/json',\n                'data-update-token': this.updateToken,\n                'Lucid-Api-Version': '1',\n            },\n            body: JSON.stringify(serializedPatches),\n        });\n        if (response.status === 409) {\n            const responseBody = await response.json();\n            if ((0, validators_1.arrayValidator)(datasourcemetadatatypes_1.isSerializedMetadataRecord)(responseBody)) {\n                return {\n                    status: 'Conflict',\n                    records: responseBody.map((record) => {\n                        return {\n                            key: record['key'],\n                            value: record['value'],\n                        };\n                    }),\n                };\n            }\n            throw new dataconnector_1.DataConnectorResponseError(`Invalid conflict response to query at '${this.metadataUrl}'! Expected an array of serialized metadata records`, JSON.stringify(responseBody));\n        }\n        await (0, throwunsuccessful_1.throwUnsuccessful)(response, 'patching data source`s metadata');\n        return { status: 'NoContent' };\n    }\n}\nexports.DataSourceClient = DataSourceClient;\n/**\n * A version of the DataSourceClient that you can use for any automated tests of your data connector.\n * Modify the `gotUpdate` field to change the behaviour of the update method.\n **/\nclass MockDataSourceClient extends DataSourceClient {\n    constructor() {\n        super({ main: '', api: '' }, '');\n        /** Assign this to your mocked update function */\n        this.gotUpdate = (request) => {\n            throw new Error(`Didn't mock request: ${JSON.stringify(request)}`);\n        };\n        /** Assign this to your mocked update function */\n        this.gotMetadata = (request) => {\n            throw new Error(`Didn't mock request: ${JSON.stringify(request)}`);\n        };\n        /** Assign this to your mocked update function */\n        this.patchedMetadata = (request) => {\n            throw new Error(`Didn't mock request: ${JSON.stringify(request)}`);\n        };\n    }\n    /** @ignore */\n    update(request) {\n        return Promise.resolve(this.gotUpdate(request));\n    }\n    /** @ignore */\n    getMetadata(keys, prefixes = []) {\n        return Promise.resolve(this.gotMetadata(keys, prefixes));\n    }\n    /** @ignore */\n    patchMetadata(patches) {\n        return Promise.resolve(this.patchedMetadata(patches));\n    }\n}\nexports.MockDataSourceClient = MockDataSourceClient;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/dataconnector/datasourceclient.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/datasourcemetadatatypes.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/datasourcemetadatatypes.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSerializedMetadataRecord = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nexports.isSerializedMetadataRecord = (0, validators_1.objectValidator)({\n    'key': checks_1.isString,\n    'value': checks_1.isUnknown,\n});\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/dataconnector/datasourcemetadatatypes.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.schemaOKStatus = exports.schemaOutOfSyncStatus = exports.serializeCollectionPatch = exports.serializeFieldDefinitionForApi = exports.serializeItemsPatch = exports.ItemsPatchExhaustive = exports.ItemsPatchInexhaustive = void 0;\nconst fieldtypedefinition_1 = __webpack_require__(/*! ../core/data/fieldtypedefinition/fieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\");\nconst object_1 = __webpack_require__(/*! ../core/object */ \"./node_modules/lucid-extension-sdk/core/object.js\");\nconst collectionerrortypes_1 = __webpack_require__(/*! ../data/collectionerrortypes */ \"./node_modules/lucid-extension-sdk/data/collectionerrortypes.js\");\nclass ItemsPatchInexhaustive {\n    constructor(\n    /**\n     * Items to be added or changed in the collection. Mapping from item serialized primary key to\n     * the sparse patch of the item. See FormattedPrimaryKey.forItem.\n     **/\n    items, \n    /** Items to remove from the collection, based on the same primary key algorithm. */\n    itemsDeleted, errors) {\n        this.items = items;\n        this.itemsDeleted = itemsDeleted;\n        this.errors = errors;\n    }\n}\nexports.ItemsPatchInexhaustive = ItemsPatchInexhaustive;\nclass ItemsPatchExhaustive {\n    constructor(items, renamingMap, errors) {\n        this.items = items;\n        this.renamingMap = renamingMap;\n        this.errors = errors;\n    }\n}\nexports.ItemsPatchExhaustive = ItemsPatchExhaustive;\nfunction serializeErrors(errors) {\n    return errors && { 'errors': (0, object_1.fromEntries)(errors) };\n}\nfunction serializeRenamingMap(renamingMap) {\n    return renamingMap && { 'renamingMap': (0, object_1.fromEntries)(renamingMap) };\n}\nfunction serializeItemsPatch(patch) {\n    var _a;\n    if (patch instanceof ItemsPatchExhaustive) {\n        return Object.assign(Object.assign({ 'exhaustiveItems': (0, object_1.fromEntries)(patch.items.entries()) }, serializeRenamingMap(patch.renamingMap)), serializeErrors(patch.errors));\n    }\n    else {\n        return Object.assign({ 'items': (0, object_1.fromEntries)(patch.items.entries()), 'itemsDeleted': (_a = patch.itemsDeleted) !== null && _a !== void 0 ? _a : [] }, serializeErrors(patch.errors));\n    }\n}\nexports.serializeItemsPatch = serializeItemsPatch;\nfunction serializeFieldConstraintForApi(constraint) {\n    return {\n        'type': constraint.type,\n        'details': constraint.value,\n    };\n}\n/** @ignore */\nfunction serializeFieldDefinitionForApi(field) {\n    var _a;\n    return {\n        'name': field.name,\n        'type': (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(field.type),\n        'constraints': ((_a = field.constraints) !== null && _a !== void 0 ? _a : []).map((x) => serializeFieldConstraintForApi(x)),\n        'mapping': field.mapping,\n    };\n}\nexports.serializeFieldDefinitionForApi = serializeFieldDefinitionForApi;\nfunction serializeSchemaForApi(schema) {\n    return {\n        'fields': schema.fields.map((x) => serializeFieldDefinitionForApi(x)),\n        'primaryKey': schema.primaryKey,\n        'fieldLabelOverrides': schema.fieldLabels,\n    };\n}\nfunction serializeRepresentsAsPropertyForApi(represents) {\n    return {\n        'Represents': represents, // key needs to match 'Represents' key in cake/app/webroot/ts/property/collection/collectionproperties.ts\n    };\n}\nfunction serializeCollectionPatch(patch) {\n    return {\n        'schema': patch.schema && serializeSchemaForApi(patch.schema),\n        'itemsPatch': serializeItemsPatch(patch.patch),\n        'properties': patch.represents && serializeRepresentsAsPropertyForApi(patch.represents),\n    };\n}\nexports.serializeCollectionPatch = serializeCollectionPatch;\n/**\n * For the moment, when the upstream Google Sheet is changed in such a way that the schema has changed, we simply\n * stop updates from happening. We do need to alert the user that this has happened, though. This is a utility function\n * for creating the appropriate entry in the errors map so that the user can be alerted that updates have stopped\n * and what they need to do to fix it.\n *\n * The eventual, proposed fix is to allow schemas to have version numbers so that changes to the schema from Google\n * can simply be folded in to the on-document copies of the data and all following edits.\n *\n * @param oldPrimaryKey The primary key stored in the data sync service and which currently is used to interpret\n * patches.\n * @param newPrimaryKey The primary key as it has been changed in the real Google Sheets.\n * @returns The error map entry which alerts the document that this problem has happened.\n */\nfunction schemaOutOfSyncStatus(oldPrimaryKey, newPrimaryKey) {\n    return [\n        collectionerrortypes_1.CollectionUpstreamSchemaStatus,\n        {\n            'dict': {\n                'status': 'broken',\n                'onDocumentKey': JSON.stringify(oldPrimaryKey),\n                'upstreamKey': JSON.stringify(newPrimaryKey),\n            },\n        },\n    ];\n}\nexports.schemaOutOfSyncStatus = schemaOutOfSyncStatus;\n/**\n * For the moment, when the upstream Google Sheet is changed in such a way that the schema has changed, we simply\n * stop updates from happening. We do need to alert the user that this has happened, though. We also need to know when\n * the updates are happening properly so we can clear the error once the user has resolved the problem. Since the\n * only way to delete errors is to overwrite them, we simply overwrite the error to be OK on every successful\n * import.\n * @returns The error map entry which alerts the document that this problem has been resolved.\n */\nfunction schemaOKStatus() {\n    return [\n        collectionerrortypes_1.CollectionUpstreamSchemaStatus,\n        {\n            'dict': {\n                'status': 'ok',\n                'onDocumentKey': null,\n                'upstreamKey': null,\n            },\n        },\n    ];\n}\nexports.schemaOKStatus = schemaOKStatus;\nconst assertIsJustRenamed = () => undefined;\nassertIsJustRenamed();\nassertIsJustRenamed();\nassertIsJustRenamed();\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/debugserver.js":
/*!***********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/debugserver.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.runDebugServer = exports.routeDebugServer = void 0;\nconst object_1 = __webpack_require__(/*! ../core/object */ \"./node_modules/lucid-extension-sdk/core/object.js\");\n/** @ignore */\nfunction routeDebugServer(dataConnector, options) {\n    var _a, _b;\n    const { express } = options;\n    const app = (_a = options.app) !== null && _a !== void 0 ? _a : options.express();\n    // We can't use Express's JSON parsing because we need to send the string of the request body\n    // directly for the route style flows. Some extensions compute a HMAC of from this data\n    app.use(express.raw({ type: () => true, limit: '100mb' }));\n    // CORS\n    app.use((req, res, next) => {\n        var _a, _b;\n        if ((_b = (_a = req.headers) === null || _a === void 0 ? void 0 : _a.origin) === null || _b === void 0 ? void 0 : _b.match(/.lucid(dev|staging|preprod|).app$/)) {\n            res.header('Access-Control-Allow-Origin', req.headers.origin);\n            res.header('Vary', 'Origin');\n            res.header('Access-Control-Allow-Methods', 'GET, OPTIONS');\n            res.header('Access-Control-Allow-Headers', '*');\n        }\n        next();\n    });\n    const prefix = (_b = options.prefix) !== null && _b !== void 0 ? _b : '/';\n    console.log(`Routing ${prefix} (${Object.keys(dataConnector.actions).join(', ')})`);\n    if (dataConnector.routes) {\n        for (const routeName of Object.keys(dataConnector.routes)) {\n            console.log(`Routing ${prefix}?kind=route&name=${routeName}`);\n        }\n    }\n    app.post(prefix, async (req, res) => {\n        try {\n            const routeKind = req.query['kind'];\n            if (routeKind === 'action' || routeKind == undefined || routeKind === '') {\n                const { body, status } = await dataConnector.runAction(req.url, req.headers, JSON.parse(req.body.toString()));\n                res.status(status).json(body);\n            }\n            if (routeKind === 'route') {\n                const routeName = req.query['name'];\n                if (typeof routeName === 'string') {\n                    const route = dataConnector.routes[routeName];\n                    const reqHeaders = req.headers;\n                    const { body, status, headers } = await route({\n                        body: req.body.toString(),\n                        headers: reqHeaders,\n                        query: (0, object_1.fromEntries)(Object.entries(req.query).map(([key, value]) => [\n                            key,\n                            typeof value === 'string' ? value : undefined,\n                        ])),\n                    });\n                    for (const [name, value] of Object.entries(headers !== null && headers !== void 0 ? headers : {})) {\n                        if (typeof value === 'string') {\n                            res.setHeader(name, value);\n                        }\n                    }\n                    res.status(status);\n                    res.send(body);\n                }\n            }\n        }\n        catch (e) {\n            console.log(`Error serving Connector: ${prefix} Flow: ${req.query['name']}, Exception:`, e);\n            res.status(500).end();\n        }\n    });\n    return app;\n}\nexports.routeDebugServer = routeDebugServer;\n/** @ignore */\nfunction runDebugServer(dataConnector, options) {\n    var _a;\n    const port = (_a = options.port) !== null && _a !== void 0 ? _a : 3001;\n    const server = routeDebugServer(dataConnector, options).listen(port, () => {\n        const address = server.address();\n        const port = typeof address === 'string' ? address : address === null || address === void 0 ? void 0 : address.port;\n        console.log(`Listening on port ${port}`);\n    });\n}\nexports.runDebugServer = runDebugServer;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/dataconnector/debugserver.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/defaultfetchfunction.js":
/*!********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/defaultfetchfunction.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.globalFetch = void 0;\n// this is used to allow extensions to compile without fetch existing for them.\n/** @ignore */\nexports.globalFetch = globalThis['fetch'];\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/dataconnector/defaultfetchfunction.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/signaturevalidator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/signaturevalidator.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MockSignatureValidator = exports.SignatureValidator = void 0;\n/**\n * Allows validation that requests originated from Lucid. This class can only be instanciated in a NodeJS environment.\n * Technically any environment that provides NodeJS compatible implementations of `globalThis.Buffer` and\n * `globalThis.require('crypto')` will work.\n */\nclass SignatureValidator {\n    constructor(dependencies, publicKey) {\n        this.dependencies = dependencies;\n        this.publicKey = dependencies.crypto.createPublicKey(publicKey);\n    }\n    /**\n     * Validate a given request came from Lucid.\n     * @param body The body of the request as a plain JavaScript object. This should be JSON.parse called on exactly the\n     *             request body that came from Lucid.\n     * @param headers The headers that are associated with the request. Only 'x-lucid-rsa-nonce' and 'x-lucid-signature'\n     *                are required.\n     * @param url     The url of the current endpoint that is being requested.\n     * @returns true if the request is valid\n     */\n    validate(body, headers, url) {\n        const [, params = ''] = url.split('?');\n        const nonce = headers['x-lucid-rsa-nonce'];\n        const signature = this.dependencies.Buffer.from(headers['x-lucid-signature'], 'base64');\n        const data = this.dependencies.Buffer.from(JSON.stringify(body) + nonce + params);\n        const verified = this.dependencies.crypto.verify('SHA384', data, this.publicKey, signature);\n        return verified;\n    }\n}\nexports.SignatureValidator = SignatureValidator;\n/** Mock signature validator, always returns true. */\nclass MockSignatureValidator {\n    validate() {\n        return true;\n    }\n}\nexports.MockSignatureValidator = MockSignatureValidator;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/dataconnector/signaturevalidator.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/dataconnector/throwunsuccessful.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/dataconnector/throwunsuccessful.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.throwUnsuccessful = void 0;\nconst dataconnector_1 = __webpack_require__(/*! ./dataconnector */ \"./node_modules/lucid-extension-sdk/dataconnector/dataconnector.js\");\n/** @ignore */\nasync function throwUnsuccessful(result, message) {\n    if (Math.floor(result.status / 100) !== 2) {\n        throw new dataconnector_1.DataConnectorRequestError(result.status, message, await result.text(), result.statusText);\n    }\n}\nexports.throwUnsuccessful = throwUnsuccessful;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/dataconnector/throwunsuccessful.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/blockproxyregistry.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/blockproxyregistry.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.findProxyClass = void 0;\nconst cardblockproxy_1 = __webpack_require__(/*! ./cardblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/cardblockproxy.js\");\nconst customblockproxy_1 = __webpack_require__(/*! ./customblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js\");\nconst erdblockproxy_1 = __webpack_require__(/*! ./erdblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/erdblockproxy.js\");\nconst legendblockproxy_1 = __webpack_require__(/*! ./legendblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/legendblockproxy.js\");\nconst linkunfurlblockproxy_1 = __webpack_require__(/*! ./linkunfurlblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js\");\nconst swimlaneblockproxy_1 = __webpack_require__(/*! ./swimlaneblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/swimlaneblockproxy.js\");\nconst tableblockproxy_1 = __webpack_require__(/*! ./tableblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/tableblockproxy.js\");\nconst allProxyClasses = [\n    cardblockproxy_1.CardBlockProxy,\n    customblockproxy_1.CustomBlockProxy,\n    erdblockproxy_1.ERDBlockProxy,\n    legendblockproxy_1.LegendBlockProxy,\n    linkunfurlblockproxy_1.LinkUnfurlBlockProxy,\n    swimlaneblockproxy_1.SwimLaneBlockProxy,\n    tableblockproxy_1.TableBlockProxy,\n];\nfunction findProxyClass(className) {\n    return allProxyClasses.find((proxy) => proxy.classNameRegex.test(className));\n}\nexports.findProxyClass = findProxyClass;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/blockclasses/blockproxyregistry.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/cardblockproxy.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/cardblockproxy.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CardBlockProxy = void 0;\nconst cardfielddisplaysettings_1 = __webpack_require__(/*! ../../core/cardintegration/cardfielddisplaysettings */ \"./node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js\");\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\n/**\n * A generic lucid card block.\n * This shape has all of the base functionality as a BlockProxy, as well as additional card specific properties.\n */\nclass CardBlockProxy extends blockproxy_1.BlockProxy {\n    getSettings() {\n        return this.referenceKeys.get(this.referenceKeys.keys()[0]).definition;\n    }\n    getTitle() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.Title];\n    }\n    getDescription() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.Description];\n    }\n    getStatus() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.Status];\n    }\n    getAssignee() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.Assignee];\n    }\n    getStartTime() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.StartTime];\n    }\n    getEndTime() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.EndTime];\n    }\n    getEstimate() {\n        return this.getSettings().data[cardfielddisplaysettings_1.LucidCardFields.Estimate];\n    }\n    /**\n     * @param title The title that you want to set for this card.\n     */\n    setTitle(title) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.Title] = title;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param description The description that you want to set for this card.\n     */\n    setDescription(description) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.Description] = description;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param status The status that you want to set for this card.\n     * This can be one of three values: \"To Do\", \"In Progress\", or \"Done\".\n     */\n    setStatus(status) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.Status] = status;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param assignee The assignee that you want to set for this card.\n     */\n    setAssignee(assignee) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.Assignee] = assignee;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param startTime The start time that you want to set for this card.\n     */\n    setStartTime(startTime) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.StartTime] = startTime;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param endTime The end time that you want to set for this card.\n     */\n    setEndTime(endTime) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.EndTime] = endTime;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n    /**\n     * @param estimate The estimate that you want to set for this card.\n     */\n    setEstimate(estimate) {\n        const settings = this.getSettings();\n        settings.data[cardfielddisplaysettings_1.LucidCardFields.Estimate] = estimate;\n        this.setReferenceKey(this.referenceKeys.keys()[0], settings);\n    }\n}\nexports.CardBlockProxy = CardBlockProxy;\nCardBlockProxy.classNameRegex = /^LucidCardBlock$/;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/blockclasses/cardblockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js":
/*!************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CustomBlockProxy = void 0;\nconst checks_1 = __webpack_require__(/*! ../../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\n/**\n * Custom shapes defined in extension packages (or other stencil-providing means like Visio stencil imports)\n * are represented by a CustomBlockProxy.\n */\nclass CustomBlockProxy extends blockproxy_1.BlockProxy {\n    static registerCustomBlockClass(klass) {\n        let byLibrary = CustomBlockProxy.subclassRegistry.get(klass.library);\n        if (!byLibrary) {\n            byLibrary = new Map();\n            CustomBlockProxy.subclassRegistry.set(klass.library, byLibrary);\n        }\n        byLibrary.set(klass.shape, klass);\n    }\n    /**\n     * @ignore\n     */\n    static getCustomBlockClass(client, id) {\n        if (this.subclassRegistry.size > 0) {\n            const stencil = client.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'id': id, 'p': 'Stencil' });\n            if ((0, checks_1.isObjectUnsafe)(stencil)) {\n                const sourceStencil = client.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'p': 'Stencil-' + stencil['id'] });\n                if ((0, checks_1.isObjectUnsafe)(sourceStencil) && (0, checks_1.isObjectUnsafe)(sourceStencil['sourcePackage'])) {\n                    if (sourceStencil['sourcePackage']['packageId'] === lucid.getPackageId()) {\n                        const byLibrary = CustomBlockProxy.subclassRegistry.get(String(sourceStencil['sourcePackage']['library']));\n                        const klass = byLibrary === null || byLibrary === void 0 ? void 0 : byLibrary.get(String(sourceStencil['sourcePackage']['shape']));\n                        if (klass) {\n                            return klass;\n                        }\n                    }\n                }\n            }\n        }\n        return CustomBlockProxy;\n    }\n    isFromStencil(library, shape) {\n        const stencil = this.properties.get('Stencil');\n        if ((0, checks_1.isObjectUnsafe)(stencil)) {\n            const sourceStencil = this.client.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'p': 'Stencil-' + stencil['id'] });\n            if ((0, checks_1.isObjectUnsafe)(sourceStencil) && (0, checks_1.isObjectUnsafe)(sourceStencil['sourcePackage'])) {\n                return (sourceStencil['sourcePackage']['packageId'] === lucid.getPackageId() &&\n                    sourceStencil['sourcePackage']['library'] === library &&\n                    sourceStencil['sourcePackage']['shape'] === shape);\n            }\n        }\n        return false;\n    }\n    getStencilTextAreaName(stencilTextAreaName) {\n        return this.textAreas.keys().find((name) => name.endsWith('_' + stencilTextAreaName));\n    }\n}\nexports.CustomBlockProxy = CustomBlockProxy;\nCustomBlockProxy.classNameRegex = /^CustomBlock$/;\nCustomBlockProxy.subclassRegistry = new Map();\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/erdblockproxy.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/erdblockproxy.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ERDBlockProxy = exports.ERDFieldProxy = void 0;\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\nclass ERDFieldProxy {\n    constructor(block, index) {\n        this.block = block;\n        this.index = index;\n    }\n    getName() {\n        return this.block.properties.get('Field' + this.index);\n    }\n    getType() {\n        var _a;\n        return (_a = this.block.properties.get('Type' + this.index)) !== null && _a !== void 0 ? _a : '';\n    }\n    getKey() {\n        var _a;\n        return (_a = this.block.properties.get('Key' + this.index)) !== null && _a !== void 0 ? _a : '';\n    }\n}\nexports.ERDFieldProxy = ERDFieldProxy;\nclass ERDBlockProxy extends blockproxy_1.BlockProxy {\n    getName() {\n        return this.properties.get('Name');\n    }\n    getFieldCount() {\n        return this.properties.get('Fields');\n    }\n    getFields() {\n        const fields = [];\n        const fieldCount = this.getFieldCount();\n        for (let i = 1; i <= fieldCount; i++) {\n            //These are 1-indexed in the property store\n            fields.push(new ERDFieldProxy(this, i));\n        }\n        return fields;\n    }\n}\nexports.ERDBlockProxy = ERDBlockProxy;\nERDBlockProxy.classNameRegex = /^ERDEntityBlock(2|3|4)?$/;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/blockclasses/erdblockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/legendblockproxy.js":
/*!************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/legendblockproxy.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LegendBlockProxy = exports.ShapeLegendEntryProxy = exports.ColorLegendEntryProxy = exports.LegendEntryProxy = exports.LegendItemType = void 0;\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\nvar LegendItemType;\n(function (LegendItemType) {\n    LegendItemType[\"Color\"] = \"color\";\n    LegendItemType[\"Shape\"] = \"shape\";\n})(LegendItemType || (exports.LegendItemType = LegendItemType = {}));\nclass LegendEntryProxy {\n    constructor(legend, index, type) {\n        this.legend = legend;\n        this.index = index;\n        this.type = type;\n    }\n    getText() {\n        return this.legend.textAreas.get('LegendText_' + this.index);\n    }\n    setText(text) {\n        this.legend.textAreas.set('LegendText_' + this.index, text);\n    }\n}\nexports.LegendEntryProxy = LegendEntryProxy;\nclass ColorLegendEntryProxy extends LegendEntryProxy {\n    constructor(legend, index) {\n        super(legend, index, LegendItemType.Color);\n    }\n    getColor() {\n        return this.legend.properties.get('LegendItem_' + this.index)['Value'];\n    }\n}\nexports.ColorLegendEntryProxy = ColorLegendEntryProxy;\nclass ShapeLegendEntryProxy extends LegendEntryProxy {\n    constructor(legend, index) {\n        super(legend, index, LegendItemType.Shape);\n    }\n}\nexports.ShapeLegendEntryProxy = ShapeLegendEntryProxy;\nclass LegendBlockProxy extends blockproxy_1.BlockProxy {\n    getHeader() {\n        return this.textAreas.get('t_header');\n    }\n    getItems() {\n        const itemOrder = this.properties.get('ItemOrder');\n        return itemOrder.map((index) => {\n            const settings = this.properties.get('LegendItem_' + index);\n            switch (settings['Type']) {\n                case LegendItemType.Color:\n                    return new ColorLegendEntryProxy(this, index);\n                case LegendItemType.Shape:\n                    return new ShapeLegendEntryProxy(this, index);\n                default:\n                    return new LegendEntryProxy(this, index, settings['Type']);\n            }\n        });\n    }\n}\nexports.LegendBlockProxy = LegendBlockProxy;\nLegendBlockProxy.classNameRegex = /^LegendBlockV2$/;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/blockclasses/legendblockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExperimentalLinkUnfurlBlockProxy = exports.LinkUnfurlBlockProxy = void 0;\nconst iframeutils_1 = __webpack_require__(/*! ../../core/iframe/iframeutils */ \"./node_modules/lucid-extension-sdk/core/iframe/iframeutils.js\");\nconst unfurliframe_1 = __webpack_require__(/*! ../../core/unfurl/unfurliframe */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js\");\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\n/**\n * This is the kind of block that appears when a link is pasted onto the canvas of a Lucid editor.\n */\nclass LinkUnfurlBlockProxy extends blockproxy_1.BlockProxy {\n    /**\n     * Returns the title on the block, which is the main text shown on the block.\n     */\n    getTitle() {\n        return this.textAreas.get('t_LinkUnfurlTitle');\n    }\n    /**\n     * Sets the title on the block, which is the main text shown on the block.\n     */\n    setTitle(title) {\n        this.textAreas.set('t_LinkUnfurlTitle', title, { force: true });\n    }\n    /**\n     * Returns the description on the block.\n     */\n    getDescription() {\n        return this.textAreas.get('t_LinkUnfurlDescription');\n    }\n    /**\n     * Sets the description on the block.\n     */\n    setDescription(description) {\n        this.textAreas.set('t_LinkUnfurlDescription', description, { force: true });\n    }\n    /**\n     * Returns the name of the service the link belongs to, such as \"Lucid\" or \"Google\", as displayed below the title on\n     * the block.\n     */\n    getProviderName() {\n        return this.textAreas.get('t_LinkUnfurlProviderName');\n    }\n    /**\n     * Gets the URL the user will be redirected to when the user clicks the \"Pop Out\" action on the block.\n     */\n    getUrl() {\n        return this.properties.get('LinkUnfurlUrl');\n    }\n    /**\n     * Sets the URL the user will be redirected to when the user clicks the \"Pop Out\" action on the block.\n     */\n    setUrl(url) {\n        this.properties.set('LinkUnfurlUrl', url);\n    }\n    /**\n     * Sets the URL to be loaded in an iframe when the user clicks the \"Expand\" action on the block.\n     */\n    setIframe(unfurlIframe) {\n        const iframeAttributes = (0, unfurliframe_1.generateIframeAttributes)(unfurlIframe);\n        this.properties.set('LinkUnfurlIframeHtml', (0, iframeutils_1.generateIFrameHTML)(iframeAttributes));\n        this.properties.set('LinkUnfurlIframeHeight', iframeAttributes.height);\n        this.properties.set('LinkUnfurlIframeWidth', iframeAttributes.width);\n    }\n    /**\n     * Sets the main thumbnail on the block\n     */\n    setPreviewThumbnailUrl(thumbnailUrl) {\n        this.properties.set('LinkUnfurlThumbnailUrl', thumbnailUrl);\n    }\n    /**\n     * Gets the main thumbnail on the block\n     */\n    getPreviewThumbnailUrl() {\n        return this.properties.get('LinkUnfurlThumbnailUrl');\n    }\n    /**\n     * Sets additional thumbnails on the block\n     */\n    setThumbnailUrls(thumbnails) {\n        this.properties.set('LinkUnfurlThumbnailUrls', thumbnails);\n    }\n    /**\n     * Gets the url for the favicon on the block\n     */\n    getFaviconUrl() {\n        return this.properties.get('LinkUnfurlFaviconUrl');\n    }\n    /**\n     * Sets the favicon on the block\n     */\n    setFaviconUrl(faviconUrl) {\n        this.properties.set('LinkUnfurlFaviconUrl', faviconUrl);\n    }\n    /**\n     * @ignore\n     * Initiates the PDF upload for this block. The result includes an uploadUrl which you can use to upload the PDF.\n     * The PDF uploaded at that url will be assocaite with this block (and any copy of it) in the editor until it is refreshed.\n     */\n    async experimentalStartPDFUpload() {\n        const result = await this.client.sendCommand(\"pdf\" /* CommandName.StartPDFUploadRequest */, this.id);\n        return result;\n    }\n}\nexports.LinkUnfurlBlockProxy = LinkUnfurlBlockProxy;\nLinkUnfurlBlockProxy.classNameRegex = /^LinkUnfurlBlock$/;\n/**\n * @ignore\n * @deprecated Use LinkUnfurlBlockProxy instead.\n */\nexports.ExperimentalLinkUnfurlBlockProxy = LinkUnfurlBlockProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/swimlaneblockproxy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/swimlaneblockproxy.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SwimLaneBlockProxy = exports.SwimLanePrimaryLaneProxy = void 0;\nconst fillcolor_1 = __webpack_require__(/*! ../../core/properties/fillcolor */ \"./node_modules/lucid-extension-sdk/core/properties/fillcolor.js\");\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\nclass SwimLanePrimaryLaneProxy {\n    constructor(swimlane, index) {\n        this.swimlane = swimlane;\n        this.index = index;\n    }\n    /**\n     * For horizontal lanes, the lane height.\n     * For vertical lanes, the lane width.\n     */\n    getSize() {\n        return this.swimlane.getPrimaryLaneSizes()[this.index];\n    }\n    getBoundingBox() {\n        const bb = this.swimlane.getBoundingBox();\n        const sizes = this.swimlane.getPrimaryLaneSizes();\n        if (this.swimlane.getPrimaryLanesVertical()) {\n            return {\n                x: bb.x + sizes.slice(0, this.index).reduce((a, b) => a + b, 0),\n                y: bb.y,\n                w: sizes[this.index],\n                h: bb.h,\n            };\n        }\n        else {\n            return {\n                x: bb.x,\n                y: bb.y + sizes.slice(0, this.index).reduce((a, b) => a + b, 0),\n                w: bb.w,\n                h: sizes[this.index],\n            };\n        }\n    }\n    getTitleTextAreaId() {\n        const existing = this.swimlane.properties.get('PrimaryLaneTextAreaIds')[this.index];\n        if (existing) {\n            return existing;\n        }\n        this.swimlane.updateTextAreaNames();\n        return this.swimlane.properties.get('PrimaryLaneTextAreaIds')[this.index];\n    }\n    getTitle() {\n        return this.swimlane.textAreas.get(this.getTitleTextAreaId());\n    }\n    setTitle(title) {\n        return this.swimlane.textAreas.set(this.getTitleTextAreaId(), title);\n    }\n    setFill(fill) {\n        this.swimlane.properties.set(`CellFill_0,${this.index}`, (0, fillcolor_1.serializeSimpleFill)(fill));\n    }\n}\nexports.SwimLanePrimaryLaneProxy = SwimLanePrimaryLaneProxy;\nclass SwimLaneBlockProxy extends blockproxy_1.BlockProxy {\n    getPrimaryLaneSizes() {\n        return this.properties.get('PrimaryLane');\n    }\n    setPrimaryLaneSizes(sizes) {\n        this.properties.set('PrimaryLane', sizes);\n        this.updateTextAreaNames();\n    }\n    getPrimaryLanes() {\n        return this.getPrimaryLaneSizes().map((size, index) => new SwimLanePrimaryLaneProxy(this, index));\n    }\n    getPrimaryLanesVertical() {\n        return this.properties.get('IsPrimaryLaneVertical');\n    }\n    getMagnetized() {\n        return this.properties.get('Magnetize');\n    }\n    setMagnetized(magnetize) {\n        this.properties.set('Magnetize', magnetize);\n    }\n    /** @ignore */\n    updateTextAreaNames() {\n        this.properties.set('PrimaryLaneTextAreaIds', this.getPrimaryLaneSizes().map((_, index) => 'Primary_' + index));\n    }\n    /**\n     * Swim lanes only use the normal BoundingBox property for location.\n     * For size, it uses the PrimaryLane and SecondaryLane properties.\n     */\n    setBoundingBox(bb) {\n        super.setBoundingBox(bb); //To get position correct\n        const minLaneSize = 40;\n        const oldBB = this.getBoundingBox();\n        const primarySizes = this.getPrimaryLaneSizes();\n        const secondarySizes = this.properties.get('SecondaryLane');\n        const adjustLanesByDelta = (lanes, delta, laneIndex = lanes.length - 1) => {\n            if (laneIndex >= 0 && laneIndex < lanes.length) {\n                lanes[laneIndex] += delta;\n                if (lanes[laneIndex] < minLaneSize) {\n                    const deltaLeft = minLaneSize - lanes[laneIndex];\n                    lanes[laneIndex] = minLaneSize;\n                    adjustLanesByDelta(lanes, deltaLeft, laneIndex - 1);\n                }\n            }\n        };\n        if (bb.w != oldBB.w) {\n            if (this.getPrimaryLanesVertical()) {\n                adjustLanesByDelta(primarySizes, bb.w - oldBB.w);\n                this.setPrimaryLaneSizes(primarySizes);\n            }\n            else {\n                adjustLanesByDelta(secondarySizes, bb.w - oldBB.w);\n                this.properties.set('SecondaryLane', secondarySizes);\n            }\n        }\n        if (bb.h != oldBB.h) {\n            if (this.getPrimaryLanesVertical()) {\n                adjustLanesByDelta(secondarySizes, bb.h - oldBB.h);\n                this.properties.set('SecondaryLane', secondarySizes);\n            }\n            else {\n                adjustLanesByDelta(primarySizes, bb.h - oldBB.h);\n                this.setPrimaryLaneSizes(primarySizes);\n            }\n        }\n    }\n}\nexports.SwimLaneBlockProxy = SwimLaneBlockProxy;\nSwimLaneBlockProxy.classNameRegex = /^AdvancedSwimLaneBlock$/;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/blockclasses/swimlaneblockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockclasses/tableblockproxy.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockclasses/tableblockproxy.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TableBlockProxy = exports.TableColumnProxy = exports.TableRowProxy = exports.TableCellProxy = void 0;\nconst fillcolor_1 = __webpack_require__(/*! ../../core/properties/fillcolor */ \"./node_modules/lucid-extension-sdk/core/properties/fillcolor.js\");\nconst blockproxy_1 = __webpack_require__(/*! ../blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\nclass TableCellProxy {\n    constructor(table, row, column) {\n        this.table = table;\n        this.row = row;\n        this.column = column;\n    }\n    getText() {\n        return this.table.textAreas.get(`Cell_${this.row},${this.column}`);\n    }\n    setText(text) {\n        return this.table.textAreas.set(`Cell_${this.row},${this.column}`, text);\n    }\n    getTextStyle() {\n        return this.table.textStyles.get(`Cell_${this.row},${this.column}`);\n    }\n    setTextStyle(style) {\n        this.table.textStyles.set(`Cell_${this.row},${this.column}`, style);\n    }\n    setFill(fill) {\n        this.table.properties.set(`CellFill_${this.row},${this.column}`, (0, fillcolor_1.serializeSimpleFill)(fill));\n    }\n    /**\n     * Cells in a table can be merged together with adjacent cells into one larger cell. In this case, the upper-\n     * left cell remains visible but is enlarged to cover additional cells, and the other cells are hidden.\n     *\n     * @returns the size of this cell, in how many cells horizontally and vertically have been merged into it.\n     * For most cells, this will be {w:1, h:1}, but if it has been merged with the cell to the right of it, it\n     * would be {w:2, h:1}.\n     */\n    getMergedCellSize() {\n        var _a;\n        return ((_a = this.table.properties.get(`CellSize_${this.row},${this.column}`)) !== null && _a !== void 0 ? _a : { w: 1, h: 1 });\n    }\n    /**\n    /**\n     * Cells in a table can be merged together with adjacent cells into one larger cell. In this case, the upper-\n     * left cell remains visible but is enlarged to cover additional cells, and the other cells are hidden.\n     *\n     * @param size the desired size of this cell, in how many cells horizontally and vertically are merged into it.\n     * This normally {w:1, h:1} for a normal cell, or {w:2, h:1} to merge a cell with the one to the right of it, etc.\n     */\n    setMergedCellSize(size) {\n        this.table.properties.set(`CellSize_${this.row},${this.column}`, size);\n    }\n    /**\n     * @returns the pixel width of the cell, including any cells it is merged with.\n     */\n    getWidth() {\n        return this.table\n            .getColumnWidths()\n            .slice(this.column, this.column + this.getMergedCellSize().w)\n            .reduce((a, b) => a + b, 0);\n    }\n    /**\n     * @returns the pixel height of the cell, including any cells it is merged with.\n     */\n    getHeight() {\n        return this.table\n            .getRowHeights()\n            .slice(this.row, this.row + this.getMergedCellSize().h)\n            .reduce((a, b) => a + b, 0);\n    }\n    getBoundingBox() {\n        const tableBB = this.table.getBoundingBox();\n        const x = tableBB.x +\n            this.table\n                .getColumnWidths()\n                .slice(0, this.column)\n                .reduce((a, b) => a + b, 0);\n        const y = tableBB.y +\n            this.table\n                .getRowHeights()\n                .slice(0, this.row)\n                .reduce((a, b) => a + b, 0);\n        return { x, y, w: this.getWidth(), h: this.getHeight() };\n    }\n}\nexports.TableCellProxy = TableCellProxy;\nclass TableRowProxy {\n    constructor(table, row) {\n        this.table = table;\n        this.row = row;\n    }\n    getCells() {\n        return this.table.getColumnWidths().map((_, index) => new TableCellProxy(this.table, this.row, index));\n    }\n    getHeight() {\n        var _a;\n        return (_a = this.table.getRowHeights()[this.row]) !== null && _a !== void 0 ? _a : 1;\n    }\n}\nexports.TableRowProxy = TableRowProxy;\nclass TableColumnProxy {\n    constructor(table, col) {\n        this.table = table;\n        this.col = col;\n    }\n    getCells() {\n        return this.table.getRowHeights().map((_, index) => new TableCellProxy(this.table, this.col, index));\n    }\n    getWidth() {\n        var _a;\n        return (_a = this.table.getColumnWidths()[this.col]) !== null && _a !== void 0 ? _a : 1;\n    }\n}\nexports.TableColumnProxy = TableColumnProxy;\nclass TableBlockProxy extends blockproxy_1.BlockProxy {\n    /**\n     *\n     * @param referenceCell The cell to add the new column before or after.\n     * @param before If true, the new column will be added before the reference cell, otherwise it will be added after.\n     * @returns The TableColumnProxy for the newly added column.\n     */\n    addColumn(referenceCell, before = false) {\n        const col = this.client.sendCommand(\"atc\" /* CommandName.AddTableColumn */, {\n            'id': this.id,\n            'r': referenceCell.row,\n            'c': referenceCell.column,\n            'b': before,\n        });\n        return new TableColumnProxy(this, col);\n    }\n    /**\n     *\n     * @param referenceCell The cell to add the new row before or after.\n     * @param before If true, the new row will be added before the reference cell, otherwise it will be added after.\n     * @returns The TableRowProxy for the newly added row.\n     */\n    addRow(referenceCell, before = false) {\n        const row = this.client.sendCommand(\"atr\" /* CommandName.AddTableRow */, {\n            'id': this.id,\n            'r': referenceCell.row,\n            'c': referenceCell.column,\n            'b': before,\n        });\n        return new TableRowProxy(this, row);\n    }\n    /**\n     * @param column The index of the column to delete.\n     */\n    deleteColumn(column) {\n        return this.client.sendCommand(\"dtc\" /* CommandName.DeleteTableColumn */, { 'id': this.id, 'i': column });\n    }\n    /**\n     * @param row The index of the row to delete.\n     */\n    deleteRow(row) {\n        return this.client.sendCommand(\"dtr\" /* CommandName.DeleteTableRow */, { 'id': this.id, 'i': row });\n    }\n    /**\n     * @param textAreaKey The text area key of a cell in the table\n     * @returns The TableCellProxy represented by the text area key, or undefined if the text area key does not exist in the table.\n     */\n    getCellByTextAreaKey(textAreaKey) {\n        const value = textAreaKey.match(/(\\d+)/g);\n        if (value && value.length === 2) {\n            const row = +value[0];\n            const column = +value[1];\n            return new TableCellProxy(this, row, column);\n        }\n        return undefined;\n    }\n    getRowCount() {\n        return this.getRowHeights().length;\n    }\n    getColumnCount() {\n        return this.getColumnWidths().length;\n    }\n    getRows() {\n        return this.getRowHeights().map((_, index) => new TableRowProxy(this, index));\n    }\n    getRowHeights() {\n        return this.properties.get('RowHeights');\n    }\n    getColumnWidths() {\n        return this.properties.get('ColWidths');\n    }\n    setColumnWidths(widths) {\n        this.properties.set('ColWidths', widths);\n    }\n    setRowHeights(heights) {\n        this.properties.set('RowHeights', heights);\n    }\n    getAutoResizeColumns() {\n        return this.properties.get('AutoColWidth');\n    }\n    getAutoResizeRows() {\n        return this.properties.get('AutoRowHeight');\n    }\n    setAutoResizeColumns(auto) {\n        this.properties.set('AutoColWidth', auto);\n    }\n    setAutoResizeRows(auto) {\n        this.properties.set('AutoRowHeight', auto);\n    }\n    /**\n     * @param margin The inset margin to be used, it control the margin for each table cell.\n     */\n    setInsetMargin(margin) {\n        this.properties.set('InsetMargin', margin);\n    }\n}\nexports.TableBlockProxy = TableBlockProxy;\nTableBlockProxy.classNameRegex = /^DefaultTableBlock$/;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/blockclasses/tableblockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockdefinition.js":
/*!**********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockdefinition.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/blockdefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/blockproxy.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/blockproxy.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BlockProxy = void 0;\nconst badgeposition_1 = __webpack_require__(/*! ../core/properties/datagraphic/badgeposition */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\");\nconst staticdatagraphicsettings_1 = __webpack_require__(/*! ../core/properties/datagraphic/staticdatagraphicsettings */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/staticdatagraphicsettings.js\");\nconst fillcolor_1 = __webpack_require__(/*! ../core/properties/fillcolor */ \"./node_modules/lucid-extension-sdk/core/properties/fillcolor.js\");\nconst shadow_1 = __webpack_require__(/*! ../core/properties/shadow */ \"./node_modules/lucid-extension-sdk/core/properties/shadow.js\");\nconst math_1 = __webpack_require__(/*! ../math */ \"./node_modules/lucid-extension-sdk/math.js\");\nconst itemproxy_1 = __webpack_require__(/*! ./itemproxy */ \"./node_modules/lucid-extension-sdk/document/itemproxy.js\");\n/**\n * A block is a single shape on the document. A BlockProxy provides an interface to\n * read and write the content of an existing block, and is typically accessed through\n * [PageProxy.blocks](#classes_document_pageproxy-PageProxy_blocks) or another\n * similar mechanism.\n */\nclass BlockProxy extends itemproxy_1.ItemProxy {\n    /**\n     * @returns The class name of this block. This name is not necessarily human-readable,\n     * and will remain consistent over time, e.g. \"ProcessBlock\"..\n     */\n    getClassName() {\n        return this.properties.get('ClassName');\n    }\n    /**\n     * @returns The amount this block is rotated around its own center, in radians.\n     */\n    getRotation() {\n        return this.properties.get('Rotation');\n    }\n    /**\n     * @returns An axis-aligned bounding box containing this full item after any rotation it might have\n     */\n    getRotatedBoundingBox() {\n        return (0, math_1.rotatedBoundingBox)(this.getBoundingBox(), this.getRotation());\n    }\n    /**\n     * @param radians Angle the block should be rotated\n     */\n    setRotation(radians) {\n        this.properties.set('Rotation', radians);\n    }\n    /**\n     * @returns The current drop shadow on this block, or undefined if no shadow is set\n     */\n    getShadow() {\n        const raw = this.properties.get('Shadow');\n        if (!raw) {\n            return undefined;\n        }\n        return (0, shadow_1.deserializeShadow)(raw);\n    }\n    /**\n     * @param shadow The drop shadow to set on the block, or undefined to clear the drop shadow\n     */\n    setShadow(shadow) {\n        if (shadow) {\n            this.properties.set('Shadow', (0, shadow_1.serializeShadow)(shadow));\n        }\n        else {\n            this.properties.set('Shadow', null);\n        }\n    }\n    /**\n     * Set the fill style used (by most kinds of blocks) to fill in their main opaque areas.\n     * This can be a string color (e.g. `'#ff00ff80'`) or an image fill.\n     */\n    setFillStyle(fillStyle) {\n        this.properties.set('FillColor', (0, fillcolor_1.serializeSimpleFill)(fillStyle));\n    }\n    /**\n     * @returns An array of lines that have one or both endpoints connected to this block.\n     */\n    getConnectedLines() {\n        const ids = this.client.sendCommand(\"gcl\" /* CommandName.GetConnectedLines */, this.id);\n        return ids.map((id) => this.client.getLineProxy(id));\n    }\n    /**\n     * @param settings Information about the static data graphic icon to set on this block.\n     */\n    setSimpleStaticDataGraphic(settings) {\n        if (settings) {\n            this.properties.set('StaticDataGraphic', (0, staticdatagraphicsettings_1.serializeSimpleStaticDataGraphicSettings)(settings));\n        }\n        else {\n            this.properties.set('StaticDataGraphic', undefined);\n        }\n    }\n    /**\n     * @returns Settings for the simple static data graphic currently set on this block, or undefined\n     * if no simple data graphic is currently set. Note that if a data graphic exists that is not an\n     * icon, this will return undefined. This function will not consider data graphics set via\n     * conditional formatting rules.\n     */\n    getSimpleStaticDataGraphic() {\n        const settings = this.properties.get('StaticDataGraphic');\n        if ((0, staticdatagraphicsettings_1.isSerializedSimpleStaticDataGraphicSettings)(settings)) {\n            return (0, staticdatagraphicsettings_1.deserializeSimpleStaticDataGraphicSettings)(settings);\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Lock this block's aspect ratio to its current value.\n     * This can be reversed with unlockAspectRatio.\n     */\n    lockAspectRatio() {\n        const bb = this.getBoundingBox();\n        this.properties.set('AspectRatio', bb.w / bb.h);\n    }\n    /**\n     * Unlock the aspect ratio of this block, allowing it to be stretched vertically or horizontally independently.\n     */\n    unlockAspectRatio() {\n        this.properties.set('AspectRatio', undefined);\n    }\n    /**\n     * @returns The line width used by most kinds of blocks to render their outline.\n     */\n    getLineWidth() {\n        return this.properties.get('LineWidth');\n    }\n    /**\n     * @param width The line width to be used (by most kinds of blocks) to render this block's outline\n     */\n    setLineWidth(width) {\n        this.properties.set('LineWidth', width);\n    }\n    /**\n     * Link a text area to a data field, so that editing the text area will also update the\n     * associated data, and vice versa.\n     *\n     * To use this, first establish a reference key on this block with\n     * [setReferenceKey](/extension-sdk/#classes_document_blockproxy-BlockProxy_setreferencekey).\n     *\n     * @param textAreaKey\n     * @param referenceKey\n     * @param field\n     */\n    linkText(textAreaKey, referenceKey, field) {\n        if (!this.textAreas.keys().includes(textAreaKey)) {\n            throw new Error('Invalid text area key');\n        }\n        if (!this.referenceKeys.keys().includes(referenceKey)) {\n            throw new Error('Invalid reference key');\n        }\n        this.properties.set(textAreaKey + '_Link', {\n            'ref': referenceKey,\n            'f': field,\n        });\n    }\n    /**\n     * @param position The postion where the data sync state icon should be displayed on the block. If this position is\n     * set to undefined then the state icon position will fallback to the default position for the block.\n     */\n    setDataSyncStateIconPosition(position) {\n        this.properties.set('DataSyncStateIconPosition', position ? (0, badgeposition_1.serializeBadgeEnumPosition)(position) : null);\n    }\n}\nexports.BlockProxy = BlockProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/blockproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/documentelement/cardconfigproxy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/documentelement/cardconfigproxy.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CardConfigProxy = void 0;\nconst documentelementproxy_1 = __webpack_require__(/*! ./documentelementproxy */ \"./node_modules/lucid-extension-sdk/document/documentelement/documentelementproxy.js\");\nclass CardConfigProxy extends documentelementproxy_1.DocumentElementProxy {\n    /**\n     * @param id The ID of this card config element\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n    }\n}\nexports.CardConfigProxy = CardConfigProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/documentelement/cardconfigproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/documentelement/documentelementproxy.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/documentelement/documentelementproxy.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DocumentElementProxy = void 0;\nconst propertystoreproxy_1 = __webpack_require__(/*! ../propertystoreproxy */ \"./node_modules/lucid-extension-sdk/document/propertystoreproxy.js\");\nclass DocumentElementProxy extends propertystoreproxy_1.PropertyStoreProxy {\n    /**\n     * @param id The ID of this document element\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n    }\n}\nexports.DocumentElementProxy = DocumentElementProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/documentelement/documentelementproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/documentelement/documentelementtype.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/documentelement/documentelementtype.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DocumentElementType = void 0;\n/**\n * An enumeration of document element types. A Document element represents a collection of data that is stored on a document.\n */\nvar DocumentElementType;\n(function (DocumentElementType) {\n    DocumentElementType[\"DataTransformation\"] = \"DerivedStructure\";\n    DocumentElementType[\"Path\"] = \"Path\";\n    DocumentElementType[\"Tag\"] = \"Tag\";\n    DocumentElementType[\"CommentThreadMetadata\"] = \"ThreadMetadata\";\n    DocumentElementType[\"FontStylePreset\"] = \"FontStylePreset\";\n    DocumentElementType[\"IntraDocumentMutex\"] = \"Mutex\";\n    DocumentElementType[\"Rule\"] = \"Rule\";\n    DocumentElementType[\"DocumentFormula\"] = \"Formula\";\n    DocumentElementType[\"TaskCardFieldsConfig\"] = \"TaskCardFieldsConfig\";\n    DocumentElementType[\"GeneratorView\"] = \"GeneratorView\";\n    DocumentElementType[\"ShapeStylePreset\"] = \"ShapeStylePreset\";\n    DocumentElementType[\"ShapeSpecificDefaultProperties\"] = \"ShapeSpecificDefaultProperties\";\n})(DocumentElementType || (exports.DocumentElementType = DocumentElementType = {}));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/documentelement/documentelementtype.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/documentelement/ruleproxy.js":
/*!********************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/documentelement/ruleproxy.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RuleProxy = exports.RuleEffect = exports.RuleCondition = void 0;\nconst badgeposition_1 = __webpack_require__(/*! ../../core/properties/datagraphic/badgeposition */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\");\nconst mapproxy_1 = __webpack_require__(/*! ../mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst ruledefinition_1 = __webpack_require__(/*! ../ruledefinition */ \"./node_modules/lucid-extension-sdk/document/ruledefinition.js\");\nconst documentelementproxy_1 = __webpack_require__(/*! ./documentelementproxy */ \"./node_modules/lucid-extension-sdk/document/documentelement/documentelementproxy.js\");\nclass RuleCondition {\n    constructor(rule, client, key) {\n        this.rule = rule;\n        this.client = client;\n        this.key = key;\n        this.definition = this.rule.properties.get(this.key);\n        /** What kind of condition is this? e.g. a formula evaluation, checking for non-empty text, etc. */\n        this.type = this.definition['Type'];\n        /**\n         * If this.type == ConditionType.Text, this is a TextConditions.\n         * If this.type == ConditionType.ShapeData, this is a ShapeDataConditions.\n         * If this.type == ConditionType.ShapeType, this is a ShapeTypeConditions.\n         * If this.type == ConditionType.ConnectedShapes, this is a ConnectedShapesConditions.\n         */\n        this.condition = this.definition['Condition'];\n        /**\n         * For formula conditions, the formula string.\n         *\n         * For other conditions,the value against which the condition is tested. For example, a condition with\n         *  type = ConditionType.ShapeData\n         *  condition = ShapeDataConditions.GreaterThan\n         *  field = 'TheField'\n         *  value = 14\n         *\n         * will trigger when the shape data field \"TheField\" has a value that is greater than 14.\n         */\n        this.value = this.definition['Value'];\n        /** For shape data conditions, the name of the shape data field to test */\n        this.field = this.definition['Label'];\n        /** For shape data conditions, the name to display to the end user to identify the field name */\n        this.fieldLabel = this.definition['DisplayLabel'];\n    }\n    /** Update this condition to reflect a new definition */\n    update(definition) {\n        this.rule.properties.set(this.key, (0, ruledefinition_1.serializeConditionDefinition)(definition));\n        this.definition = this.rule.properties.get(this.key);\n    }\n}\nexports.RuleCondition = RuleCondition;\nclass RuleEffect {\n    constructor(rule, client, key) {\n        this.rule = rule;\n        this.client = client;\n        this.key = key;\n        this.definition = this.rule.properties.get(this.key);\n        this.conditions = new mapproxy_1.MapProxy(() => this.definition['ConditionOrder'].map((order) => 'Condition_' + order), (key) => new RuleCondition(this.rule, this.client, key));\n        /** How multiple conditions are combined (AND vs OR) */\n        this.combination = this.definition['Combination'];\n        /** What kind of effect is displayed? Formatting vs. icons vs. dynamic stencil, etc. */\n        this.formatType = this.definition['FormatType'];\n        /** For formatType = RuleFormattingType.FORMATTING, what styles are applied to blocks, lines, and pages? */\n        this.formatting = this.definition['Formatting'];\n        /** For formatType = RuleFormattingType.DATA_GRAPHICS, a description of which icon appears and where */\n        this.dataGraphic = this.definition['DataGraphic'] && {\n            set: this.definition['DataGraphic']['Set'],\n            index: this.definition['DataGraphic']['Index'],\n            position: (0, badgeposition_1.deserializeBadgeEnumPosition)(this.definition['DataGraphic']['Position']),\n            color: this.definition['DataGraphic']['Color'],\n            image: this.definition['DataGraphic']['Image'] && {\n                url: this.definition['DataGraphic']['Image']['url'],\n                w: this.definition['DataGraphic']['Image']['w'],\n                h: this.definition['DataGraphic']['Image']['h'],\n            },\n        };\n    }\n    /** Update this effect to reflect a new definition */\n    update(definition) {\n        //Find the maximum used condition index in the entire rule, in case we need to add more.\n        let nextConditionIndex = 1;\n        for (const effect of this.rule.effects.values()) {\n            nextConditionIndex = Math.max(nextConditionIndex, ...effect.definition.ConditionOrder.map((index) => index + 1));\n        }\n        const conditionIndexes = this.definition.ConditionOrder;\n        definition.conditions.forEach((condition, index) => {\n            let conditionIndex = conditionIndexes[index];\n            if (conditionIndex === undefined) {\n                //Added a new condition\n                conditionIndex = nextConditionIndex;\n                conditionIndexes.push(nextConditionIndex++);\n            }\n            const conditionKey = 'Condition_' + conditionIndex;\n            this.rule.properties.set(conditionKey, (0, ruledefinition_1.serializeConditionDefinition)(condition));\n        });\n        this.rule.properties.set(this.key, (0, ruledefinition_1.serializeEffectDefinition)(definition, conditionIndexes.slice(0, definition.conditions.length)));\n    }\n}\nexports.RuleEffect = RuleEffect;\nclass RuleProxy extends documentelementproxy_1.DocumentElementProxy {\n    /**\n     * @param id The ID of this conditional formatting rule\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n        this.effects = new mapproxy_1.MapProxy(() => this.properties.get('EffectOrder').map((order) => 'Effect_' + order), (key) => new RuleEffect(this, this.client, key));\n    }\n    getName() {\n        return this.properties.get('Name');\n    }\n    setName(name) {\n        this.properties.set('Name', name);\n    }\n    getOrder() {\n        return this.properties.get('Order');\n    }\n    /**\n     * Delete this conditional formatting rule from the document\n     */\n    delete() {\n        this.client.sendCommand(\"dde\" /* CommandName.DeleteDocumentElement */, this.id);\n    }\n    /** @ignore */\n    static getRuleProperties(definition) {\n        const properties = {\n            'EffectOrder': definition.effects.map((effect, index) => index + 1),\n            'SourceType': 0,\n            'Name': definition.name,\n        };\n        let nextConditionIndex = 1;\n        let nextEffectIndex = 1;\n        for (const effect of definition.effects) {\n            const effectKey = 'Effect_' + nextEffectIndex++;\n            const conditionOrder = [];\n            for (const condition of effect.conditions) {\n                conditionOrder.push(nextConditionIndex);\n                const conditionKey = 'Condition_' + nextConditionIndex++;\n                properties[conditionKey] = (0, ruledefinition_1.serializeConditionDefinition)(condition);\n            }\n            properties[effectKey] = (0, ruledefinition_1.serializeEffectDefinition)(effect, conditionOrder);\n        }\n        return properties;\n    }\n    /** Update this rule to reflect a new definition */\n    update(definition) {\n        const properties = RuleProxy.getRuleProperties(definition);\n        for (const key in properties) {\n            this.properties.set(key, properties[key]);\n        }\n    }\n}\nexports.RuleProxy = RuleProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/documentelement/ruleproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/documentproxy.js":
/*!********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/documentproxy.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DocumentProxy = void 0;\nconst cardconfigproxy_1 = __webpack_require__(/*! ./documentelement/cardconfigproxy */ \"./node_modules/lucid-extension-sdk/document/documentelement/cardconfigproxy.js\");\nconst documentelementtype_1 = __webpack_require__(/*! ./documentelement/documentelementtype */ \"./node_modules/lucid-extension-sdk/document/documentelement/documentelementtype.js\");\nconst ruleproxy_1 = __webpack_require__(/*! ./documentelement/ruleproxy */ \"./node_modules/lucid-extension-sdk/document/documentelement/ruleproxy.js\");\nconst elementproxy_1 = __webpack_require__(/*! ./elementproxy */ \"./node_modules/lucid-extension-sdk/document/elementproxy.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst pageproxy_1 = __webpack_require__(/*! ./pageproxy */ \"./node_modules/lucid-extension-sdk/document/pageproxy.js\");\n/**\n * The currently-open Lucid document\n */\nclass DocumentProxy extends elementproxy_1.ElementProxy {\n    static getNextHookName() {\n        return '__documentproxy__hook' + DocumentProxy.nextHookId++;\n    }\n    constructor(client) {\n        super(client.sendCommand(\"gdid\" /* CommandName.GetDocumentId */, undefined), client);\n        /**\n         * The set of pages on this document, organized by ID\n         */\n        this.pages = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lp\" /* CommandName.ListPages */, undefined), (pageId) => new pageproxy_1.PageProxy(pageId, this.client));\n        this.cardIntegrationConfigs = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lde\" /* CommandName.ListDocumentElements */, { 't': documentelementtype_1.DocumentElementType.TaskCardFieldsConfig }), (id) => new cardconfigproxy_1.CardConfigProxy(id, this.client));\n        this.rules = new mapproxy_1.MapProxy(() => this.client\n            .sendCommand(\"lde\" /* CommandName.ListDocumentElements */, { 't': documentelementtype_1.DocumentElementType.Rule })\n            //Filter down to only the rules with source User (i.e. ones visible in the UI, not ones created internally by the app)\n            .filter((id) => this.client.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'id': id, 'p': 'SourceType' }) === 0), (id) => new ruleproxy_1.RuleProxy(id, this.client));\n    }\n    /**\n     * An iterator over all blocks on all pages of the document\n     */\n    *allBlocks() {\n        for (const page of this.pages.values()) {\n            for (const block of page.blocks.values()) {\n                yield block;\n            }\n        }\n    }\n    /**\n     * An iterator over all lines on all pages of the document\n     */\n    *allLines() {\n        for (const page of this.pages.values()) {\n            for (const line of page.lines.values()) {\n                yield line;\n            }\n        }\n    }\n    /**\n     * Add a new page to the current document\n     * @param def Definition of the page to add\n     * @returns The created page\n     */\n    addPage(def) {\n        const id = this.client.sendCommand(\"cp\" /* CommandName.CreatePage */, undefined);\n        const page = new pageproxy_1.PageProxy(id, this.client);\n        page.setTitle(def.title);\n        return page;\n    }\n    /**\n     * Updates the title of this document\n     * @param title The new title for this document\n     */\n    setTitle(title) {\n        this.properties.set('Title', title);\n    }\n    /**\n     * @returns The title of this document\n     */\n    getTitle() {\n        return this.properties.get('Title');\n    }\n    /**\n     * Infrequently, you may need to watch for *any* changes to the document. These changes may be\n     * the local user adding content, or a data integration sending updated records to a data collection,\n     * or a remote user hitting undo, or any user entering or exiting an intra-document mutex.\n     *\n     * Because these changes may happen rapidly, the callback you provide here will only be called on\n     * a heavily-debounced schedule. The callback will happen between 1-10 seconds after changes are\n     * made to the document, depending on the frequency with which changes are happening.\n     * @param callback\n     * @returns A handle that can be passed into `unhookAllChanges`\n     */\n    hookAllChanges(callback) {\n        const actionName = DocumentProxy.getNextHookName();\n        this.client.registerAction(actionName, () => {\n            callback();\n        });\n        this.client.sendCommand(\"hac\" /* CommandName.HookAllChanges */, { 'n': actionName });\n        return actionName;\n    }\n    /**\n     * @param handle Return value from `hookAllChanges`\n     */\n    unhookAllChanges(handle) {\n        this.client.deleteAction(handle);\n        this.client.sendCommand(\"uac\" /* CommandName.UnhookAllChanges */, { 'n': handle });\n    }\n    /**\n     * Watch for new blocks, lines, or groups added to this document. The callback will\n     * be called with new items created by the current user, but will not be called with items\n     * created\n     *\n     *  - As part of a generated diagram, e.g. org chart\n     *  - By another user on the same document\n     *\n     * @param callback\n     * @returns A handle that can be passed to `unhookCreateItems`\n     */\n    hookCreateItems(callback) {\n        const actionName = DocumentProxy.getNextHookName();\n        this.client.registerAction(actionName, (msg) => {\n            callback(msg['ids'].map((id) => this.client.getItemProxy(id)));\n        });\n        this.client.sendCommand(\"hci\" /* CommandName.HookCreateItems */, { 'n': actionName });\n        return actionName;\n    }\n    /**\n     * @param handle Return value from `hookCreateItems`\n     */\n    unhookCreateItems(handle) {\n        this.client.deleteAction(handle);\n        this.client.sendCommand(\"uci\" /* CommandName.UnhookCreateItems */, { 'n': handle });\n    }\n    addRule(definition) {\n        let maxOrder = 0;\n        for (const rule of this.rules.values()) {\n            maxOrder = Math.max(maxOrder, rule.getOrder());\n        }\n        const id = this.client.sendCommand(\"cde\" /* CommandName.CreateDocumentElement */, {\n            't': documentelementtype_1.DocumentElementType.Rule,\n            'p': Object.assign(Object.assign({}, ruleproxy_1.RuleProxy.getRuleProperties(definition)), { 'Order': maxOrder + 1 }),\n        });\n        if (id === undefined) {\n            return undefined;\n        }\n        return new ruleproxy_1.RuleProxy(id, this.client);\n    }\n    /**\n     * Watch for new blocks, lines, or groups deleted from this document. The callback will\n     * be called with items deleted by the current user, but will not be called with items\n     * deleted\n     *\n     *  - As part of a generated diagram, e.g. org chart\n     *  - By another user on the same document\n     *\n     * @param callback\n     * @returns A handle that can be passed to `unhookDeleteItems`\n     */\n    hookDeleteItems(callback) {\n        const actionName = DocumentProxy.getNextHookName();\n        this.client.registerAction(actionName, (msg) => {\n            callback(msg['ids']);\n        });\n        this.client.sendCommand(\"hdi\" /* CommandName.HookDeleteItems */, { 'n': actionName });\n        return actionName;\n    }\n    /**\n     * @param handle Return value from `hookDeleteItems`\n     */\n    unhookDeleteItems(handle) {\n        this.client.deleteAction(handle);\n        this.client.sendCommand(\"udi\" /* CommandName.UnhookDeleteItems */, { 'n': handle });\n    }\n}\nexports.DocumentProxy = DocumentProxy;\nDocumentProxy.nextHookId = 0;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/documentproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/elementproxy.js":
/*!*******************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/elementproxy.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ElementProxy = void 0;\nconst referencekeydefinition_1 = __webpack_require__(/*! ../data/referencekeydefinition */ \"./node_modules/lucid-extension-sdk/data/referencekeydefinition.js\");\nconst referencekeyproxy_1 = __webpack_require__(/*! ../data/referencekeyproxy */ \"./node_modules/lucid-extension-sdk/data/referencekeyproxy.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\nconst propertystoreproxy_1 = __webpack_require__(/*! ./propertystoreproxy */ \"./node_modules/lucid-extension-sdk/document/propertystoreproxy.js\");\nconst shapedataproxy_1 = __webpack_require__(/*! ./shapedataproxy */ \"./node_modules/lucid-extension-sdk/document/shapedataproxy.js\");\n/**\n * An element is anything on a Lucid document that can have properties and shape data:\n *  * [The document itself](#classes_document_documentproxy-DocumentProxy)\n *  * [Pages](#classes_document_pageproxy-PageProxy)\n *  * [Blocks](#classes_document_blockproxy-BlockProxy)\n *  * [Lines](#classes_document_lineproxy-LineProxy)\n *  * [Groups](#classes_document_groupproxy-GroupProxy)\n */\nclass ElementProxy extends propertystoreproxy_1.PropertyStoreProxy {\n    /**\n     * Set a reference key on this element, replacing any existing reference at the specified key.\n     *\n     * @param key\n     * @param settings\n     */\n    setReferenceKey(key, settings) {\n        this.client.sendCommand(\"srk\" /* CommandName.SetReferenceKey */, {\n            'id': this.id,\n            'k': key,\n            'v': (0, referencekeydefinition_1.serializeReferenceKeyDefinition)(settings),\n        });\n    }\n    /**\n     * Remove the specified reference key from this element.\n     * @param key\n     */\n    removeReferenceKey(key) {\n        this.client.sendCommand(\"srk\" /* CommandName.SetReferenceKey */, { 'id': this.id, 'k': key });\n    }\n    /**\n     *\n     * @param id ID of this element\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        /**\n         * The shape data set directly on this element (not including any shape data inherited from the page or a containing group).\n         */\n        this.shapeData = new shapedataproxy_1.ShapeDataProxy(this.id, this.client);\n        /**\n         * All shape data accessible on this element, including shape data inherited from the page or a containing group.\n         * This collection is read-only.\n         */\n        this.allShapeData = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lsd\" /* CommandName.ListShapeData */, { 'id': this.id, 'i': true }), (name) => shapedataproxy_1.ShapeDataProxy.parseData(this.client.sendCommand(\"gsd\" /* CommandName.GetShapeData */, {\n            'id': this.id,\n            'n': name,\n        })));\n        /**\n         * The set of reference keys, organized by their ID, which can be either a string or number.\n         *\n         * For more information, see the [Developer Guide](/extension-api#guide-reference-keys).\n         */\n        this.referenceKeys = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lrk\" /* CommandName.ListReferenceKeys */, { 'id': this.id }), (key) => new referencekeyproxy_1.ReferenceKeyProxy(this.id, key, this.client, this.client.sendCommand(\"grk\" /* CommandName.GetReferenceKey */, { 'id': this.id, 'k': key })));\n    }\n    /**\n     * @returns `true` if this element still exists on the document, or `false` otherwise\n     */\n    exists() {\n        return this.client.sendCommand(\"ee\" /* CommandName.ElementExists */, { 'id': this.id });\n    }\n    /**\n     * Execute a formula in the context of this element\n     * @param formula The formula text, e.g. \"@a + @b\" to add together the shape data values a and b.\n     * @returns The result of the formula, or an error.\n     */\n    executeFormula(formula) {\n        return shapedataproxy_1.ShapeDataProxy.parseData(this.client.sendCommand(\"ef\" /* CommandName.ExecuteFormula */, { 'id': this.id || '', 'f': formula }));\n    }\n}\nexports.ElementProxy = ElementProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/elementproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/groupproxy.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/groupproxy.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GroupProxy = void 0;\nconst itemproxy_1 = __webpack_require__(/*! ./itemproxy */ \"./node_modules/lucid-extension-sdk/document/itemproxy.js\");\nconst lineproxy_1 = __webpack_require__(/*! ./lineproxy */ \"./node_modules/lucid-extension-sdk/document/lineproxy.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * A group of items on a page.\n */\nclass GroupProxy extends itemproxy_1.ItemProxy {\n    constructor() {\n        super(...arguments);\n        /**\n         * The blocks that are directly contained in this group, organized by ID.\n         */\n        this.blocks = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lb\" /* CommandName.ListBlocks */, { 'id': this.id }), (id) => this.client.getBlockProxy(id));\n        /**\n         * The lines that are directly contained in this group, organized by ID.\n         */\n        this.lines = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"ll\" /* CommandName.ListLines */, { 'id': this.id }), (id) => new lineproxy_1.LineProxy(id, this.client));\n        /**\n         * The groups that are directly contained in this group, organized by ID.\n         */\n        this.groups = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lg\" /* CommandName.ListGroups */, { 'id': this.id }), (id) => new GroupProxy(id, this.client));\n        /**\n         * The blocks that are contained in this group, including those nested in deeper groups, organized by ID.\n         */\n        this.allBlocks = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lb\" /* CommandName.ListBlocks */, { 'id': this.id, 'd': true }), (id) => this.client.getBlockProxy(id));\n        /**\n         * The lines that are contained in this group, including those nested in deeper groups, organized by ID.\n         */\n        this.allLines = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"ll\" /* CommandName.ListLines */, { 'id': this.id, 'd': true }), (id) => new lineproxy_1.LineProxy(id, this.client));\n        /**\n         * The groups that are contained in this group, including those nested in deeper groups, organized by ID.\n         */\n        this.allGroups = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lg\" /* CommandName.ListGroups */, { 'id': this.id, 'd': true }), (id) => new GroupProxy(id, this.client));\n    }\n}\nexports.GroupProxy = GroupProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/groupproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/imagedefinition.js":
/*!**********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/imagedefinition.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.imageToBlockDefinition = void 0;\n/**\n * Turns an image definition into a block definition.\n */\nfunction imageToBlockDefinition(definition) {\n    return {\n        className: 'UserImage2Block',\n        boundingBox: definition.boundingBox,\n        fillStyle: definition.fillStyle,\n        properties: {\n            opactiy: definition.opacity,\n            lineColor: definition.lineColor,\n            lineWidth: definition.lineWidth,\n            strokeStyle: definition.strokeStyle,\n            rounding: definition.rounding,\n            rotation: definition.rotation,\n        },\n    };\n}\nexports.imageToBlockDefinition = imageToBlockDefinition;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/imagedefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/itemproxy.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/itemproxy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ItemProxy = void 0;\nconst offsettype_1 = __webpack_require__(/*! ../core/offsettype */ \"./node_modules/lucid-extension-sdk/core/offsettype.js\");\nconst elementproxy_1 = __webpack_require__(/*! ./elementproxy */ \"./node_modules/lucid-extension-sdk/document/elementproxy.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * A block, line, or group on a page of the current document.\n */\nclass ItemProxy extends elementproxy_1.ElementProxy {\n    /**\n     * @param id ID of this item\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n        /**\n         * The plain text in each of the text areas on this item, organized by text area name.\n         */\n        this.textAreas = new mapproxy_1.WriteableMapProxy(() => this.client.sendCommand(\"lta\" /* CommandName.ListTextAreas */, this.id), (name) => this.client.sendCommand(\"gp\" /* CommandName.GetProperty */, {\n            'id': this.id,\n            'p': name,\n        }), (name, plainText, options) => this.client.sendCommand(\"st\" /* CommandName.SetText */, {\n            'id': this.id,\n            'n': name,\n            't': plainText,\n            'f': options === null || options === void 0 ? void 0 : options.force,\n        }));\n        /**\n         * The text style in each of the text areas on this item, organized by text area name.\n         */\n        this.textStyles = new mapproxy_1.WriteableMapProxy(() => this.textAreas.keys(), (name) => this.client.sendCommand(\"gts\" /* CommandName.GetTextStyle */, {\n            'id': this.id,\n            'n': name,\n        }), (name, style) => this.client.sendCommand(\"sts\" /* CommandName.SetTextStyle */, {\n            'id': this.id,\n            'n': name,\n            's': style,\n        }));\n    }\n    /**\n     * @returns The bounding box of this item relative to its containing page. As pages may change size\n     * to fit the content on them, note that these coordinates may be negative or very large.\n     *\n     * If this is a rotated block, the bounding box returned here is where the block would be if it were\n     * unrotated.\n     */\n    getBoundingBox() {\n        return this.properties.get('BoundingBox');\n    }\n    /**\n     * Attempts to move and resize this item to fit into the given bounding box. If this item (or another\n     * item it contains) has size or aspect ratio restrictions, it may not be possible to fit the requested\n     * location exactly.\n     *\n     * This is done by moving this item to the requested location, then attempting to resize it from the\n     * bottom-right corner to the requested size.\n     *\n     * @param bb The bounding box to attempt to make this item fill\n     */\n    setBoundingBox(bb) {\n        const current = this.getBoundingBox();\n        if (current.x !== bb.x || current.y !== bb.y) {\n            this.offset(offsettype_1.OffsetType.MOVE, { x: bb.x - current.x, y: bb.y - current.y });\n        }\n        if (current.w !== bb.w || current.h !== bb.h) {\n            this.offset(offsettype_1.OffsetType.SE, {\n                x: bb.w - current.w,\n                y: bb.h - current.h,\n            });\n        }\n    }\n    /**\n     * @returns The ID of the page containing this item\n     */\n    getPageId() {\n        return this.client.sendCommand(\"gip\" /* CommandName.GetItemPageId */, this.id);\n    }\n    /**\n     * @returns The page containing this item\n     */\n    getPage() {\n        return this.client.getPageProxy(this.getPageId());\n    }\n    /**\n     * @returns The x/y location of this item\n     */\n    getLocation() {\n        const bb = this.getBoundingBox();\n        return { x: bb.x, y: bb.y };\n    }\n    /**\n     * Moves this item so that its upper-left corner is positioned at the given location (prior to any rotation)\n     * @param location The target location\n     */\n    setLocation(location) {\n        const current = this.getBoundingBox();\n        if (current.x !== location.x || current.y !== location.y) {\n            this.offset(offsettype_1.OffsetType.MOVE, { x: location.x - current.x, y: location.y - current.y });\n        }\n    }\n    /**\n     * Offset this item in the given direction by the given amount.\n     * @param type The type of offset to apply to this item\n     * @param offset The amount to offset\n     */\n    offset(type, offset) {\n        this.client.sendCommand(\"oi\" /* CommandName.OffsetItems */, { 'ids': [this.id], 't': type, 'o': offset });\n    }\n    /**\n     * Measure the amount of space necessary to render the text in the given text area, given a\n     * width to measure that text within.\n     * @param name Name of the text area whose content we should measure\n     * @param maxWidth Width of the area in which to measure this text. The result will usually be no wider than this, but if a single word is long enough to go beyond this maxWidth, the width of that word will be returned.\n     * @returns The size of rectangle necessary to render this text area's content.\n     */\n    measureText(name, maxWidth) {\n        return this.client.sendCommand(\"mt\" /* CommandName.MeasureText */, { 'id': this.id, 'n': name, 'w': maxWidth });\n    }\n    /**\n     * Delete this item from the document\n     */\n    delete() {\n        this.client.sendCommand(\"di\" /* CommandName.DeleteItem */, this.id);\n    }\n    /**\n     * @returns An array of blocks whose bounding boxes contain this item's upper-left corner\n     */\n    getContainers() {\n        const containers = this.executeFormula('LABEL(CONTAINEDBY)');\n        return containers.map((id) => this.client.getBlockProxy(id));\n    }\n    /**\n     * @param operation How to adjust the Z order of this item relative to the other items it overlaps on the page\n     */\n    changeZOrder(operation) {\n        this.client.sendCommand(\"z\" /* CommandName.ZOrder */, { 'i': [this.id], 'o': operation });\n    }\n    /**\n     * @param rule Rule to apply to this item\n     */\n    applyRule(rule) {\n        const ids = this.properties.get('RuleList');\n        if (!ids.includes(rule.id)) {\n            ids.push(rule.id);\n            this.properties.set('RuleList', ids);\n        }\n    }\n    /**\n     * @param rule Rule to remove from this item\n     */\n    unapplyRule(rule) {\n        const ids = this.properties.get('RuleList');\n        if (ids.includes(rule.id)) {\n            this.properties.set('RuleList', ids.filter((id) => id !== rule.id));\n        }\n    }\n}\nexports.ItemProxy = ItemProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/itemproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/linedefinition.js":
/*!*********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/linedefinition.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isPositionEndpointDefinition = exports.isLineEndpointDefinition = exports.isBlockEndpointDefinition = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\nconst blockproxy_1 = __webpack_require__(/*! ./blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\nconst lineproxy_1 = __webpack_require__(/*! ./lineproxy */ \"./node_modules/lucid-extension-sdk/document/lineproxy.js\");\n/**\n * Checks if the endpoint is a BlockEndpointDefinition.\n */\nfunction isBlockEndpointDefinition(endpoint) {\n    return (0, validators_1.objectValidator)({\n        connection: (0, checks_1.isInstanceOf)(blockproxy_1.BlockProxy),\n        linkX: checks_1.isNumber,\n        linkY: checks_1.isNumber,\n        inside: (0, validators_1.option)(checks_1.isBoolean),\n        autoLink: (0, validators_1.option)(checks_1.isBoolean),\n        padding: (0, validators_1.option)(checks_1.isNumber),\n    })(endpoint);\n}\nexports.isBlockEndpointDefinition = isBlockEndpointDefinition;\n/**\n * Checks if the endpoint is a LineEndpointDefinition.\n */\nfunction isLineEndpointDefinition(endpoint) {\n    return (0, validators_1.objectValidator)({\n        connection: (0, checks_1.isInstanceOf)(lineproxy_1.LineProxy),\n        position: checks_1.isNumber,\n    })(endpoint);\n}\nexports.isLineEndpointDefinition = isLineEndpointDefinition;\n/**\n * Checks if the endpoint is a PositionEndpointDefinition.\n */\nfunction isPositionEndpointDefinition(endpoint) {\n    return (0, validators_1.objectValidator)({\n        x: checks_1.isNumber,\n        y: checks_1.isNumber,\n    })(endpoint);\n}\nexports.isPositionEndpointDefinition = isPositionEndpointDefinition;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/linedefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/lineproxy.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/lineproxy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LineProxy = exports.LineShape = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst blockproxy_1 = __webpack_require__(/*! ./blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\nconst itemproxy_1 = __webpack_require__(/*! ./itemproxy */ \"./node_modules/lucid-extension-sdk/document/itemproxy.js\");\nconst linetextareapositioning_1 = __webpack_require__(/*! ./linetextareapositioning */ \"./node_modules/lucid-extension-sdk/document/linetextareapositioning.js\");\nvar LineShape;\n(function (LineShape) {\n    LineShape[\"Curve\"] = \"curve\";\n    LineShape[\"Elbow\"] = \"elbow\";\n    LineShape[\"Diagonal\"] = \"diagonal\";\n})(LineShape || (exports.LineShape = LineShape = {}));\n/**\n * A line on the current Lucid document\n */\nclass LineProxy extends itemproxy_1.ItemProxy {\n    getConnection(ep) {\n        let proxy;\n        if (ep['Block']) {\n            proxy = this.client.getBlockProxy(ep['Block']);\n        }\n        if (ep['Line']) {\n            proxy = this.client.getLineProxy(ep['Line']);\n        }\n        if (proxy && !proxy.exists()) {\n            return undefined;\n        }\n        return proxy;\n    }\n    isBlockEndpointDefinition(ep) {\n        return ep.connection instanceof blockproxy_1.BlockProxy;\n    }\n    isLineEndpointDefinition(ep) {\n        return ep.connection instanceof LineProxy;\n    }\n    parseLineEndpointDefinition(raw) {\n        const connection = this.getConnection(raw);\n        if (connection instanceof LineProxy) {\n            return {\n                connection,\n                style: raw['Style'],\n                position: raw['Position'],\n                x: raw['x'],\n                y: raw['y'],\n            };\n        }\n        else if (connection) {\n            return {\n                connection,\n                style: raw['Style'],\n                linkX: raw['LinkX'],\n                linkY: raw['LinkY'],\n                inside: raw['Inside'],\n                autoLink: raw['AutoLink'],\n                padding: raw['Padding'],\n                x: raw['x'],\n                y: raw['y'],\n            };\n        }\n        else {\n            return {\n                style: raw['Style'],\n                x: raw['x'],\n                y: raw['y'],\n            };\n        }\n    }\n    serializeLineEndpointDefinition(ep) {\n        if (this.isBlockEndpointDefinition(ep)) {\n            const bb = ep.connection.getBoundingBox();\n            return {\n                'Style': ep.style,\n                'x': bb.x + bb.w * ep.linkX,\n                'y': bb.y + bb.h * ep.linkY,\n                'Block': ep.connection.id,\n                'LinkX': ep.linkX,\n                'LinkY': ep.linkY,\n                'Inside': ep.inside,\n                'AutoLink': ep.autoLink,\n                'Padding': ep.padding,\n            };\n        }\n        else if (this.isLineEndpointDefinition(ep)) {\n            return Object.assign({ 'Style': ep.style, 'Line': ep.connection.id, 'LineP': ep.position }, ep.connection.getRelativePosition(ep.position));\n        }\n        else {\n            return {\n                'Style': ep.style,\n                'x': ep.x,\n                'y': ep.y,\n            };\n        }\n    }\n    /**\n     * @returns The definition of the first endpoint of this line\n     */\n    getEndpoint1() {\n        return this.parseLineEndpointDefinition(this.properties.get('Endpoint1'));\n    }\n    /**\n     * @returns The definition of the second endpoint of this line\n     */\n    getEndpoint2() {\n        return this.parseLineEndpointDefinition(this.properties.get('Endpoint2'));\n    }\n    /**\n     * Update the first endpoint of this line\n     * @param endpoint Line endpoint definition\n     */\n    setEndpoint1(endpoint) {\n        this.properties.set('Endpoint1', this.serializeLineEndpointDefinition(endpoint));\n    }\n    /**\n     * Update the second endpoint of this line\n     * @param endpoint Line endpoint definition\n     */\n    setEndpoint2(endpoint) {\n        this.properties.set('Endpoint2', this.serializeLineEndpointDefinition(endpoint));\n    }\n    /**\n     * @returns The block or line connected to the first endpoint of this line, or `undefined` if none\n     */\n    getUpstreamConnection() {\n        return this.getEndpoint1().connection;\n    }\n    /**\n     * @returns The block or line connected to the second endpoint of this line, or `undefined` if none\n     */\n    getDownstreamConnection() {\n        return this.getEndpoint2().connection;\n    }\n    /**\n     * @returns A list of lines whose endpoints are connected to this line\n     */\n    getConnectedLines() {\n        const ids = this.client.sendCommand(\"gcl\" /* CommandName.GetConnectedLines */, this.id);\n        return ids.map((id) => this.client.getLineProxy(id));\n    }\n    /**\n     * @param relative A distance, between 0 and 1, between the first and second endpoint of this line\n     * @returns The coordinate of that relative position, relative to the containing page\n     */\n    getRelativePosition(relative) {\n        return this.client.sendCommand(\"grlp\" /* CommandName.GetRelativeLinePosition */, { 'id': this.id, 'p': relative });\n    }\n    /**\n     *\n     * @param name\n     * @returns The position of the given text area on this line, if it exists, or undefined if it does not exist.\n     */\n    getTextAreaPosition(name) {\n        const serializedTextAreas = this.properties.get('TextAreas');\n        if ((0, checks_1.isObjectUnsafe)(serializedTextAreas)) {\n            const rawEntry = serializedTextAreas[name];\n            if ((0, linetextareapositioning_1.isSerializedLineTextAreaPositioning)(rawEntry)) {\n                return (0, linetextareapositioning_1.deserializeLineTextAreaPositioning)(rawEntry);\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Updates the position of the given text area, if it exists. If not, an error is thrown.\n     * @param name\n     * @param position\n     */\n    setTextAreaPosition(name, position) {\n        this.properties.set('TextAreas', { [name]: (0, linetextareapositioning_1.serializeLineTextAreaPositioning)(position) });\n    }\n    /**\n     * Adds a new text area to this line at the given location with the given initial plain text.\n     * The text will be styled with the document theme, if any.\n     * @param text\n     * @param position\n     * @returns The name of the text area added\n     */\n    addTextArea(text, position) {\n        return this.client.sendCommand(\"alta\" /* CommandName.AddLineTextArea */, {\n            'id': this.id,\n            'p': (0, linetextareapositioning_1.serializeLineTextAreaPositioning)(position),\n            't': text,\n        });\n    }\n    /**\n     * Deletes the given text area from the line, if it exists.\n     * @param name\n     */\n    deleteTextArea(name) {\n        this.properties.set('TextAreas', { [name]: null });\n    }\n    getShape() {\n        return this.properties.get('Shape');\n    }\n    setShape(shape) {\n        this.properties.set('Shape', shape);\n    }\n}\nexports.LineProxy = LineProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/lineproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/linetextareapositioning.js":
/*!******************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/linetextareapositioning.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeLineTextAreaPositioning = exports.deserializeLineTextAreaPositioning = exports.isSerializedLineTextAreaPositioning = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\n/** @ignore */\nfunction isSerializedLineTextAreaPositioning(raw) {\n    return ((0, checks_1.isObjectUnsafe)(raw) &&\n        (0, checks_1.isNumber)(raw['Location']) &&\n        (0, checks_1.isNumber)(raw['Side']) &&\n        ((0, checks_1.isBoolean)(raw['AllowOverBlock']) || (0, checks_1.isUndefined)(raw['AllowOverBlock'])));\n}\nexports.isSerializedLineTextAreaPositioning = isSerializedLineTextAreaPositioning;\n/** @ignore */\nfunction deserializeLineTextAreaPositioning(raw) {\n    return {\n        location: raw['Location'],\n        side: raw['Side'],\n        allowOverBlock: raw['AllowOverBlock'],\n    };\n}\nexports.deserializeLineTextAreaPositioning = deserializeLineTextAreaPositioning;\n/** @ignore */\nfunction serializeLineTextAreaPositioning(data) {\n    return {\n        'Location': data.location,\n        'Side': data.side,\n        'AllowOverBlock': data.allowOverBlock,\n    };\n}\nexports.serializeLineTextAreaPositioning = serializeLineTextAreaPositioning;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/linetextareapositioning.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/mapproxy.js":
/*!***************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/mapproxy.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WriteableMapProxy = exports.MapProxy = void 0;\n/**\n * A data structure similar to a normal Map which accesses its data through API\n * commands to the Lucid app. This structure is iterable with `for...of`.\n */\nclass MapProxy {\n    constructor(getKeys, getItem) {\n        this.getKeys = getKeys;\n        this.getItem = getItem;\n    }\n    /** @ignore */\n    *[Symbol.iterator]() {\n        for (const key of this.keys()) {\n            const value = this.get(key);\n            if (value !== undefined) {\n                yield [key, value];\n            }\n        }\n    }\n    *values() {\n        for (const key of this.keys()) {\n            const value = this.get(key);\n            if (value !== undefined) {\n                yield value;\n            }\n        }\n    }\n    find(filter) {\n        for (const [key, value] of this) {\n            if (filter(value, key)) {\n                return value;\n            }\n        }\n        return undefined;\n    }\n    filter(filter) {\n        const filtered = [];\n        for (const [key, value] of this) {\n            if (filter(value, key)) {\n                filtered.push(value);\n            }\n        }\n        return filtered;\n    }\n    map(callback) {\n        const mapped = [];\n        for (const [key, value] of this) {\n            mapped.push(callback(value, key));\n        }\n        return mapped;\n    }\n    keys() {\n        return this.getKeys();\n    }\n    get size() {\n        return this.keys().length;\n    }\n    get(key) {\n        return this.getItem(key);\n    }\n    first() {\n        const keys = this.keys();\n        if (keys.length == 0) {\n            return undefined;\n        }\n        return this.get(keys[0]);\n    }\n}\nexports.MapProxy = MapProxy;\nclass WriteableMapProxy extends MapProxy {\n    constructor(getKeys, getItem, setter) {\n        super(getKeys, getItem);\n        this.setter = setter;\n    }\n    set(key, value, options = {}) {\n        return this.setter(key, value, options);\n    }\n}\nexports.WriteableMapProxy = WriteableMapProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/mapproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/pagedefinition.js":
/*!*********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/pagedefinition.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/pagedefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/pageproxy.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/pageproxy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PageProxy = void 0;\nconst commandtypes_1 = __webpack_require__(/*! ../commandtypes */ \"./node_modules/lucid-extension-sdk/commandtypes.js\");\nconst ruleproxy_1 = __webpack_require__(/*! ./documentelement/ruleproxy */ \"./node_modules/lucid-extension-sdk/document/documentelement/ruleproxy.js\");\nconst elementproxy_1 = __webpack_require__(/*! ./elementproxy */ \"./node_modules/lucid-extension-sdk/document/elementproxy.js\");\nconst groupproxy_1 = __webpack_require__(/*! ./groupproxy */ \"./node_modules/lucid-extension-sdk/document/groupproxy.js\");\nconst imagedefinition_1 = __webpack_require__(/*! ./imagedefinition */ \"./node_modules/lucid-extension-sdk/document/imagedefinition.js\");\nconst lineproxy_1 = __webpack_require__(/*! ./lineproxy */ \"./node_modules/lucid-extension-sdk/document/lineproxy.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * One page in the current Lucid document\n */\nclass PageProxy extends elementproxy_1.ElementProxy {\n    /**\n     * @param id The ID of this page\n     * @param client\n     */\n    constructor(id, client) {\n        super(id, client);\n        this.id = id;\n        /**\n         * The blocks contained directly on this page, not including ones inside groups\n         */\n        this.blocks = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lb\" /* CommandName.ListBlocks */, { id: this.id }), (id) => this.client.getBlockProxy(id));\n        /**\n         * The lines contained directly on this page, not including ones inside groups\n         */\n        this.lines = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"ll\" /* CommandName.ListLines */, { id: this.id }), (id) => new lineproxy_1.LineProxy(id, this.client));\n        /**\n         * The groups contained directly on this page, not including ones inside groups\n         */\n        this.groups = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lg\" /* CommandName.ListGroups */, { id: this.id }), (id) => new groupproxy_1.GroupProxy(id, this.client));\n        /**\n         * The blocks contained on this page, including ones inside groups\n         */\n        this.allBlocks = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lb\" /* CommandName.ListBlocks */, { id: this.id, d: true }), (id) => this.client.getBlockProxy(id));\n        /**\n         * The lines contained on this page, including ones inside groups\n         */\n        this.allLines = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"ll\" /* CommandName.ListLines */, { id: this.id, d: true }), (id) => new lineproxy_1.LineProxy(id, this.client));\n        /**\n         * The groups contained on this page, including ones inside groups\n         */\n        this.allGroups = new mapproxy_1.MapProxy(() => this.client.sendCommand(\"lg\" /* CommandName.ListGroups */, { id: this.id, d: true }), (id) => new groupproxy_1.GroupProxy(id, this.client));\n        /**\n         * All blocks, lines, and groups on the page, including ones inside groups\n         */\n        this.allItems = new mapproxy_1.MapProxy(() => [...this.allBlocks.keys(), ...this.allLines.keys(), ...this.allGroups.keys()], (id) => this.client.getItemProxy(id));\n    }\n    /**\n     * @returns All conditional formatting rules that are applied to every item on this page\n     */\n    getRulesAppliedToAllItems() {\n        const ids = this.properties.get('ChildRuleList');\n        return ids.map((id) => new ruleproxy_1.RuleProxy(id, this.client));\n    }\n    /**\n     * @param rule Rule to apply to all items on this page\n     */\n    applyRuleToAllItems(rule) {\n        const ids = this.properties.get('ChildRuleList');\n        if (!ids.includes(rule.id)) {\n            ids.push(rule.id);\n            this.properties.set('ChildRuleList', ids);\n        }\n    }\n    /**\n     * @param rule Rule to remove from the list applied to all items on this page\n     */\n    unapplyRuleToAllItems(rule) {\n        const ids = this.properties.get('ChildRuleList');\n        if (ids.includes(rule.id)) {\n            this.properties.set('ChildRuleList', ids.filter((id) => id !== rule.id));\n        }\n    }\n    /**\n     * Find available space on this page for adding new content.\n     * @param searchX Place to start the search\n     * @param searchY Place to start the search\n     * @param width\n     * @param height\n     * @returns a reference to the page and origin (upper-left point) of the space you can add new\n     * content of the given size to.\n     */\n    findAvailableSpace(searchX, searchY, width, height) {\n        const result = this.client.sendCommand(\"fas\" /* CommandName.FindAvailableSpace */, {\n            'p': this.id,\n            'x': searchX,\n            'y': searchY,\n            'w': width,\n            'h': height,\n        });\n        return {\n            page: this,\n            x: result['x'],\n            y: result['y'],\n        };\n    }\n    /**\n     * Add a new block to this page.\n     *\n     * IMPORTANT: Because code for block classes are loaded incrementally, you MUST call\n     * EditorClient.loadBlockClasses with the given block class name (and wait for it to\n     * resolve) before attempting to create a block. If you don't, an error will be thrown.\n     *\n     * @param def The definition of the new block to add\n     * @returns The added block\n     */\n    addBlock(def) {\n        const id = this.client.sendCommand(\"cb\" /* CommandName.CreateBlock */, {\n            'p': this.id,\n            'c': def.className,\n            's': def.stencil,\n        });\n        const block = this.client.getBlockProxy(id);\n        block.setBoundingBox(def.boundingBox);\n        if (def.properties) {\n            for (const key in def.properties) {\n                block.properties.set(key, def.properties[key]);\n            }\n        }\n        if (def.fillStyle !== undefined) {\n            block.setFillStyle(def.fillStyle);\n        }\n        if (def.lineWidth !== undefined) {\n            block.setLineWidth(def.lineWidth);\n        }\n        return block;\n    }\n    /**\n     * Add a new line to this page.\n     * @param def The definition of the new line to add\n     * @returns The added line\n     */\n    addLine(def) {\n        const id = this.client.sendCommand(\"cl\" /* CommandName.CreateLine */, {\n            'p': this.id,\n        });\n        const line = new lineproxy_1.LineProxy(id, this.client);\n        line.setEndpoint1(def.endpoint1);\n        line.setEndpoint2(def.endpoint2);\n        return line;\n    }\n    /**\n     * Add a new image to this page.\n     * @param def The definition of the new image to add\n     * @returns The added image\n     */\n    async addImage(def) {\n        await this.client.loadBlockClasses(['UserImage2Block']);\n        return this.addBlock((0, imagedefinition_1.imageToBlockDefinition)(def));\n    }\n    /**\n     * Updates the page of this page\n     * @param title The new title for this page\n     */\n    setTitle(title) {\n        this.properties.set('Title', title);\n    }\n    /**\n     * @returns the title of this page\n     */\n    getTitle() {\n        return this.properties.get('Title');\n    }\n    /**\n     * Delete this page from the document if possible\n     */\n    delete() {\n        this.client.sendCommand(\"dp\" /* CommandName.DeletePage */, this.id);\n    }\n    /**\n     *\n     * @param boundingBox An area of this page to search for blocks, lines, and groups\n     * @param searchType\n     * @returns Items in the given bounding box, based on the search type\n     */\n    findItems(boundingBox, searchType) {\n        return this.client\n            .sendCommand(\"gia\" /* CommandName.GetItemsAt */, { 'p': this.id, 'bb': boundingBox, 's': searchType })\n            .map((id) => this.client.getItemProxy(id));\n    }\n    /**\n     * Import links onto this page as link unfurl blocks\n     *\n     * NOTE: links will be unfurled by Lucid based on extensions installed by user\n     *\n     * @param links links to be imported onto the canvas as link unfurl blocks\n     */\n    async importLinks(links) {\n        return await this.client.sendCommand(\"il\" /* CommandName.ImportLinks */, { 'p': this.id, 'l': links });\n    }\n    /**\n     * @param items\n     * @returns A string representing the content of the items provided, including immediate surrounding context if\n     * necessary, in a format that is easily understandable by LLMs like ChatGPT. Also a map of IDs, from the shortened\n     * IDs provided for the items in the context to the actual Lucid item IDs.\n     */\n    getLLMContextForItems(items, contextType = commandtypes_1.GetLLMContextType.Relational) {\n        //We don't check that the items are on this page here; that is done in the implementation\n        //of the API command. It would be a lot of extra API calls for no benefit.\n        const result = this.client.sendCommand(\"llm\" /* CommandName.GetLLMContextFromItems */, {\n            'p': this.id,\n            'i': items.map((item) => item.id),\n            't': contextType,\n        });\n        return {\n            prompt: result['p'],\n            idToLucidId: new Map(Object.entries(result['id'])),\n        };\n    }\n    /**\n     *\n     * @param items If specified, only include these items in the resulting SVG\n     * @param includeBackground If true, include the background of the page in the SVG. Otherwise the background is transparent.\n     * @param viewBox If specified, crop the resulting SVG to the specified bounding box in page coordinates\n     * @returns A promise resolving to an SVG string\n     */\n    getSvg(items, includeBackground = false, viewBox) {\n        return this.client.sendCommand(\"gsvg\" /* CommandName.GetSvg */, {\n            'p': this.id,\n            'bb': viewBox,\n            'bg': includeBackground,\n            'i': items === null || items === void 0 ? void 0 : items.map((item) => item.id),\n        });\n    }\n}\nexports.PageProxy = PageProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/pageproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/propertystoreproxy.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/propertystoreproxy.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PropertyStoreProxy = void 0;\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * Base class for anything on a Lucid document that has an ID and properties.\n */\nclass PropertyStoreProxy {\n    /**\n     *\n     * @param id ID of this element\n     * @param client\n     */\n    constructor(id, client) {\n        this.id = id;\n        this.client = client;\n        /**\n         * All properties available on this element, organized by name.\n         * Not all properties are writeable (e.g. \"ClassName\" on a block).\n         * To move or resize elements, use setLocation() or setBoundingBox() or offset() instead.\n         */\n        this.properties = new mapproxy_1.WriteableMapProxy(() => this.client.sendCommand(\"lpr\" /* CommandName.ListProperties */, { 'id': this.id }), (name) => this.client.sendCommand(\"gp\" /* CommandName.GetProperty */, {\n            'id': this.id,\n            'p': name,\n        }), (name, value) => {\n            if (name === 'BoundingBox') {\n                throw new Error('Do not use properties.set() to move or resize items; use setLocation() or setBoundingBox() or offset()');\n            }\n            this.client.sendCommand(\"sp\" /* CommandName.SetProperty */, {\n                'id': this.id,\n                'p': name,\n                'v': value,\n            });\n        });\n    }\n}\nexports.PropertyStoreProxy = PropertyStoreProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/propertystoreproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/ruledefinition.js":
/*!*********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/ruledefinition.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeEffectDefinition = exports.serializeConditionDefinition = void 0;\nconst badgeposition_1 = __webpack_require__(/*! ../core/properties/datagraphic/badgeposition */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\");\nconst datagraphicindexes_1 = __webpack_require__(/*! ../core/properties/datagraphic/datagraphicindexes */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/datagraphicindexes.js\");\nconst conditiontype_1 = __webpack_require__(/*! ../core/rules/conditiontype */ \"./node_modules/lucid-extension-sdk/core/rules/conditiontype.js\");\nconst serializedeffect_1 = __webpack_require__(/*! ../core/rules/serializedeffect */ \"./node_modules/lucid-extension-sdk/core/rules/serializedeffect.js\");\n/** @ignore */\nfunction serializeConditionDefinition(condition) {\n    switch (condition.type) {\n        case conditiontype_1.ConditionType.Formula:\n            return {\n                'Type': condition.type,\n                'Source': 'this',\n                'Condition': 0,\n                'Value': condition.formula,\n            };\n        case conditiontype_1.ConditionType.Text:\n            return {\n                'Type': condition.type,\n                'Source': 'this',\n                'Condition': condition.condition,\n                'Value': condition.value,\n            };\n        case conditiontype_1.ConditionType.ShapeData:\n            return {\n                'Type': condition.type,\n                'Source': 'this',\n                'Condition': condition.condition,\n                'Value': condition.value,\n                'Label': condition.field,\n                'DisplayLabel': condition.fieldLabel,\n            };\n        case conditiontype_1.ConditionType.ShapeType:\n            return {\n                'Type': condition.type,\n                'Source': 'this',\n                'Condition': condition.condition,\n                'Value': condition.classNames,\n            };\n        default:\n            throw new Error('Unsupported ConditionType');\n    }\n}\nexports.serializeConditionDefinition = serializeConditionDefinition;\n/** @ignore */\nfunction serializeEffectDefinition(effect, conditionOrder) {\n    var _a;\n    return {\n        'ConditionOrder': conditionOrder,\n        'Combination': effect.combination,\n        'FormatType': effect.formatType,\n        'Formatting': effect.formatType === serializedeffect_1.RuleFormattingType.FORMATTING\n            ? {\n                'Block': {\n                    'FillColor': JSON.stringify(effect.formatting.fillColor),\n                    'LineColor': JSON.stringify(effect.formatting.borderColor),\n                    'LineWidth': JSON.stringify(effect.formatting.borderWidth),\n                    'StrokeStyle': JSON.stringify(effect.formatting.borderStyle),\n                },\n                'Line': {\n                    'LineColor': JSON.stringify(effect.formatting.lineColor),\n                    'LineWidth': JSON.stringify(effect.formatting.lineWidth),\n                    'StrokeStyle': JSON.stringify(effect.formatting.lineStyle),\n                },\n            }\n            : {},\n        'DataGraphic': effect.formatType === serializedeffect_1.RuleFormattingType.DATA_GRAPHICS\n            ? effect.dataGraphic.set === datagraphicindexes_1.DataGraphicIconSets.CUSTOM_ICONS\n                ? {\n                    'Set': effect.dataGraphic.set,\n                    'Index': 0,\n                    'Position': (0, badgeposition_1.serializeBadgeEnumPosition)(effect.dataGraphic.position),\n                    'Image': {\n                        'url': effect.dataGraphic.image.url,\n                        'w': effect.dataGraphic.image.width,\n                        'h': effect.dataGraphic.image.height,\n                    },\n                }\n                : {\n                    'Set': effect.dataGraphic.set,\n                    'Index': (_a = effect.dataGraphic.index) !== null && _a !== void 0 ? _a : 0,\n                    'Position': (0, badgeposition_1.serializeBadgeEnumPosition)(effect.dataGraphic.position),\n                    'Color': effect.dataGraphic.color,\n                }\n            : undefined,\n        'Tooltip': effect.tooltip,\n    };\n}\nexports.serializeEffectDefinition = serializeEffectDefinition;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/ruledefinition.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/shapedataproxy.js":
/*!*********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/shapedataproxy.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ShapeDataProxy = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst serializeddataerror_1 = __webpack_require__(/*! ../core/serializeddataerror */ \"./node_modules/lucid-extension-sdk/core/serializeddataerror.js\");\nconst shapedatainheritance_1 = __webpack_require__(/*! ../core/shapedatainheritance */ \"./node_modules/lucid-extension-sdk/core/shapedatainheritance.js\");\nconst dataerror_1 = __webpack_require__(/*! ../data/dataerror */ \"./node_modules/lucid-extension-sdk/data/dataerror.js\");\nconst mapproxy_1 = __webpack_require__(/*! ./mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\");\n/**\n * The shape data fields on a single element of the current document\n */\nclass ShapeDataProxy extends mapproxy_1.WriteableMapProxy {\n    /**\n     * @param id The ID of the element, or undefined for the document itself\n     * @param client\n     */\n    constructor(id, client) {\n        super(() => this.client.sendCommand(\"lsd\" /* CommandName.ListShapeData */, { 'id': this.id }), (name) => ShapeDataProxy.parseData(this.client.sendCommand(\"gsd\" /* CommandName.GetShapeData */, {\n            'id': this.id,\n            'n': name,\n        })), (name, value) => {\n            if ((0, serializeddataerror_1.isSerializedDataError)(value)) {\n                throw new Error('Cannot store an error value');\n            }\n            if (this.keys().includes(name)) {\n                this.client.sendCommand(\"ssd\" /* CommandName.SetShapeData */, { 'id': this.id, 'n': name, 'v': value });\n            }\n            else {\n                this.client.sendCommand(\"asd\" /* CommandName.AddShapeData */, {\n                    'id': this.id,\n                    'i': shapedatainheritance_1.ShapeDataInheritance.NONE,\n                    'n': name,\n                    'v': value,\n                });\n            }\n        });\n        this.id = id;\n        this.client = client;\n    }\n    /**\n     * Add shape data to this element that is inherited by its descendants.\n     *\n     * If you add an inheritable shape data to a page, whose formula is \"=@Cost * 4\", then\n     * each item on that page will have a new shape data entry (in `allShapeData`) by that\n     * name with the value calculated in the context of that individual item.\n     *\n     * Inheritable shape data on a page affects all items on the page. Inheritable shape\n     * data on a group affects all items inside that group.\n     *\n     * @param name Name of the new shape data\n     * @param value Value (or formula, if starting with \"=\") of the new shape data\n     */\n    addInheritable(name, value) {\n        this.client.sendCommand(\"asd\" /* CommandName.AddShapeData */, {\n            'id': this.id,\n            'i': shapedatainheritance_1.ShapeDataInheritance.VALUE,\n            'n': name,\n            'v': value,\n        });\n    }\n    /**\n     * Delete the specified shape data from this element\n     * @param key\n     */\n    delete(key) {\n        if (this.keys().includes(key)) {\n            this.client.sendCommand(\"dsd\" /* CommandName.DeleteShapeData */, { 'id': this.id, 'n': key });\n        }\n    }\n    /** @ignore */\n    static parseData(raw) {\n        if ((0, serializeddataerror_1.isSerializedDataError)(raw)) {\n            return new dataerror_1.DataError(raw['error'], raw['type']);\n        }\n        //TODO, eventually: parse these\n        return raw;\n    }\n    /**\n     * @param key Name of the shape data to read\n     * @returns The value if it is a string, or an empty string if it does not exist or is not a string.\n     */\n    getString(key) {\n        const val = this.get(key);\n        if (!(0, checks_1.isString)(val)) {\n            return '';\n        }\n        return val;\n    }\n}\nexports.ShapeDataProxy = ShapeDataProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/shapedataproxy.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/document/text/textstyle.js":
/*!*********************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/document/text/textstyle.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isPartialTextStyle = exports.TextMarkupNames = void 0;\nconst checks_1 = __webpack_require__(/*! ../../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst validators_1 = __webpack_require__(/*! ../../core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\");\n/**\n * Text styles that can be read and written with ItemProxy.textStyles.\n */\nvar TextMarkupNames;\n(function (TextMarkupNames) {\n    TextMarkupNames[\"Family\"] = \"font\";\n    TextMarkupNames[\"Bold\"] = \"bold\";\n    TextMarkupNames[\"Italic\"] = \"italic\";\n    TextMarkupNames[\"Underline\"] = \"underline\";\n    TextMarkupNames[\"Size\"] = \"size\";\n    TextMarkupNames[\"Color\"] = \"color\";\n    TextMarkupNames[\"HAlign\"] = \"align\";\n})(TextMarkupNames || (exports.TextMarkupNames = TextMarkupNames = {}));\nexports.isPartialTextStyle = (0, validators_1.partialObjectValidator)({\n    [TextMarkupNames.Family]: checks_1.isString,\n    [TextMarkupNames.Bold]: checks_1.isBoolean,\n    [TextMarkupNames.Italic]: checks_1.isBoolean,\n    [TextMarkupNames.Underline]: checks_1.isBoolean,\n    [TextMarkupNames.Size]: checks_1.isNumber,\n    [TextMarkupNames.Color]: checks_1.isString,\n    [TextMarkupNames.HAlign]: (value) => value === 'left' || value === 'right' || value === 'center',\n});\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/document/text/textstyle.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/editorclient.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/editorclient.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EditorClient = void 0;\nconst commandtypes_1 = __webpack_require__(/*! ./commandtypes */ \"./node_modules/lucid-extension-sdk/commandtypes.js\");\nconst base64_1 = __webpack_require__(/*! ./core/base64 */ \"./node_modules/lucid-extension-sdk/core/base64.js\");\nconst checks_1 = __webpack_require__(/*! ./core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst unfurlcallbacks_1 = __webpack_require__(/*! ./core/unfurl/unfurlcallbacks */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurlcallbacks.js\");\nconst unfurldetails_1 = __webpack_require__(/*! ./core/unfurl/unfurldetails */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurldetails.js\");\nconst unfurlrefresherrortype_1 = __webpack_require__(/*! ./core/unfurl/unfurlrefresherrortype */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurlrefresherrortype.js\");\nconst collectionproxy_1 = __webpack_require__(/*! ./data/collectionproxy */ \"./node_modules/lucid-extension-sdk/data/collectionproxy.js\");\nconst blockproxyregistry_1 = __webpack_require__(/*! ./document/blockclasses/blockproxyregistry */ \"./node_modules/lucid-extension-sdk/document/blockclasses/blockproxyregistry.js\");\nconst customblockproxy_1 = __webpack_require__(/*! ./document/blockclasses/customblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js\");\nconst linkunfurlblockproxy_1 = __webpack_require__(/*! ./document/blockclasses/linkunfurlblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js\");\nconst blockproxy_1 = __webpack_require__(/*! ./document/blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\");\nconst documentproxy_1 = __webpack_require__(/*! ./document/documentproxy */ \"./node_modules/lucid-extension-sdk/document/documentproxy.js\");\nconst elementproxy_1 = __webpack_require__(/*! ./document/elementproxy */ \"./node_modules/lucid-extension-sdk/document/elementproxy.js\");\nconst groupproxy_1 = __webpack_require__(/*! ./document/groupproxy */ \"./node_modules/lucid-extension-sdk/document/groupproxy.js\");\nconst lineproxy_1 = __webpack_require__(/*! ./document/lineproxy */ \"./node_modules/lucid-extension-sdk/document/lineproxy.js\");\nconst pageproxy_1 = __webpack_require__(/*! ./document/pageproxy */ \"./node_modules/lucid-extension-sdk/document/pageproxy.js\");\nconst unfurleventmessage_1 = __webpack_require__(/*! ./message/unfurleventmessage */ \"./node_modules/lucid-extension-sdk/message/unfurleventmessage.js\");\nfunction parseRawXHRResponse(responseFormat, raw) {\n    var _a, _b, _c, _d;\n    return Object.assign({ url: (_a = raw === null || raw === void 0 ? void 0 : raw['url']) !== null && _a !== void 0 ? _a : '', status: (_b = raw === null || raw === void 0 ? void 0 : raw['s']) !== null && _b !== void 0 ? _b : 0, headers: (_c = raw === null || raw === void 0 ? void 0 : raw['h']) !== null && _c !== void 0 ? _c : {}, timeout: raw === null || raw === void 0 ? void 0 : raw['to'] }, (responseFormat === 'utf8'\n        ? {\n            responseFormat,\n            responseText: (_d = raw === null || raw === void 0 ? void 0 : raw['t']) !== null && _d !== void 0 ? _d : 'An unknown error occurred',\n        }\n        : {\n            responseFormat,\n            responseData: (raw === null || raw === void 0 ? void 0 : raw['t']) ? (0, base64_1.decodeBase64)(raw['t']) : new Uint8Array(0),\n        }));\n}\nclass EditorClient {\n    getUniqueActionName() {\n        while (this.actionExists('a' + this.nextId)) {\n            this.nextId++;\n        }\n        return 'a' + this.nextId;\n    }\n    /**\n     * Get which Lucid product this editor extension has been loaded in.\n     */\n    getProduct() {\n        return this.sendCommand(\"gpr\" /* CommandName.GetProduct */, undefined);\n    }\n    /**\n     * Unload this extension immediately, removing any custom menu items etc., until the user refreshes the browser tab.\n     */\n    killExtension() {\n        this.sendCommand(\"k\" /* CommandName.KillExtension */, undefined);\n    }\n    /**\n     * Unload this extension, and then re-execute it.\n     */\n    reloadExtension() {\n        this.sendCommand(\"r\" /* CommandName.ReloadExtension */, undefined);\n    }\n    /**\n     * Initiate a browser file download of custom content\n     * @param filename Filename of the downloaded file\n     * @param data The content to put into the file, either in plain text or as base64-encoded binary data\n     * @param mime The MIME type to tell the browser it is downloading\n     * @param base64 If true, base64 decode the data before downloading it\n     */\n    download(filename, data, mime, base64) {\n        this.sendCommand(\"d\" /* CommandName.Download */, {\n            'f': filename,\n            'd': data,\n            'm': mime,\n            'b64': base64,\n        });\n    }\n    /**\n     * Upload an image and return a URL that can be used for displaying that image on the canvas. Note: the URL is\n     * public - anyone with the URL can access the image.\n     * @param data The binary image contents, or a base64-encoded string\n     * @param mediaType The media type, e.g. 'image/png'\n     * @returns A promise that resolves with the URL of the created image.\n     *\n     */\n    async createUserImage(mediaType, data) {\n        const result = await this.sendCommand(\"cui\" /* CommandName.CreateUserImage */, {\n            't': mediaType,\n            'd': (0, checks_1.isString)(data) ? data : (0, base64_1.encodeBase64)(data),\n        });\n        return result['u'];\n    }\n    /**\n     * @ignore\n     * @deprecated Use createUserImage instead.\n     */\n    experimentalCreateUserImage(mediaType, data) {\n        return this.createUserImage(mediaType, data);\n    }\n    async performDataAction(options) {\n        if (options.asynchronous === undefined) {\n            options.asynchronous = true;\n        }\n        const result = await this.sendCommand(\"da\" /* CommandName.DataAction */, {\n            'fn': options.actionName,\n            'a': options.asynchronous,\n            's': options.syncDataSourceIdNonce,\n            'fd': options.actionData,\n            'n': options.dataConnectorName,\n        });\n        if ('t' in result) {\n            return {\n                'status': result['c'],\n                'text': result['t'],\n            };\n        }\n        return {\n            'status': result['c'],\n            'json': result['j'],\n        };\n    }\n    /**\n     * If the extension package containing this editor extension has configurable settings,\n     * show a standard modal allowing the user to view or change those settings.\n     *\n     * If the user does not have permission to change settings on this installation of this\n     * extension, or if no settings exist, an error is thrown.\n     *\n     * @returns A promise that resolves when the user closes the settings modal.\n     */\n    async showPackageSettingsModal() {\n        return this.sendCommand(\"spsm\" /* CommandName.ShowPackageSettingsModal */, undefined);\n    }\n    /**\n     * If the extension package containing this editor extension has configurable settings, set the\n     * value of those settings for this installation of this extension. A subset of setting values\n     * can be provided to update those values while leaving others unchanged.\n     *\n     * If the user does not have permission to change settings on this installation of this\n     * extension, or if no settings exist, an error is thrown.\n     */\n    async setPackageSettings(settings) {\n        let settingsAsRecord = {};\n        if (settings instanceof Map) {\n            for (const [key, value] of settings.entries()) {\n                settingsAsRecord[key] = value;\n            }\n        }\n        else {\n            settingsAsRecord = settings;\n        }\n        return this.sendCommand(\"sps\" /* CommandName.SetPackageSettings */, settingsAsRecord);\n    }\n    /**\n     * If the extension package containing this editor extension has configurable settings,\n     * fetch the current values of those settings for this installation of this extension.\n     *\n     * Only settings that have been set by the installing user will have a value in the map,\n     * other settings will be missing.\n     *\n     * @returns A promise that resolves to a map of setting names to current setting values\n     */\n    async getPackageSettings() {\n        return new Map(Object.entries(await this.sendCommand(\"gps\" /* CommandName.GetPackageSettings */, undefined)));\n    }\n    /**\n     * @returns True if the current user is allowed to edit package settings on this installation\n     * of this extension (if any settings exist), or false otherwise.\n     */\n    async canEditPackageSettings() {\n        return this.sendCommand(\"ceps\" /* CommandName.CanEditPackageSettings */, undefined);\n    }\n    async awaitDataImport(dataConnectorName, syncDataSourceId, syncCollectionId, primaryKeys, timeout = 30000) {\n        return new collectionproxy_1.CollectionProxy(await this.sendCommand(\"ai\" /* CommandName.AwaitImport */, {\n            'n': dataConnectorName,\n            's': syncDataSourceId,\n            'c': syncCollectionId,\n            'pk': primaryKeys,\n            't': timeout,\n        }), this);\n    }\n    /** @ignore until spreadsheet integration is ready for launch (CHART-51946) */\n    async awaitDataSourceImport(dataConnectorName, syncDataSourceIdNonce) {\n        return await this.sendCommand(\"adi\" /* CommandName.AwaitDataSourceImport */, {\n            'n': dataConnectorName,\n            's': syncDataSourceIdNonce,\n        });\n    }\n    xhr(request) {\n        let streamCallback;\n        if (request.streamCallback) {\n            streamCallback = this.getUniqueActionName();\n            this.registerAction(streamCallback, (msg) => { var _a; return (_a = request.streamCallback) === null || _a === void 0 ? void 0 : _a.call(request, msg['d']); });\n        }\n        const responseFormat = request.responseFormat || 'utf8';\n        return this.sendCommand(\"xhr\" /* CommandName.SendXHR */, {\n            'url': request.url,\n            'm': request.method,\n            'd': request.data,\n            'h': request.headers,\n            'ms': request.timeoutMs,\n            'f': responseFormat,\n            's': streamCallback,\n        })\n            .then((raw) => {\n            return parseRawXHRResponse(responseFormat, raw);\n        })\n            .catch((error) => {\n            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;\n            throw parseRawXHRResponse(responseFormat, raw);\n        })\n            .finally(() => {\n            if (streamCallback) {\n                this.deleteAction(streamCallback);\n            }\n        });\n    }\n    asyncOAuthXhr(providerName, request) {\n        const responseFormat = request.responseFormat || 'utf8';\n        return this.sendCommand(\"aoauth\" /* CommandName.SendAsyncOAuthRequest */, Object.assign({ 'url': request.url, 'm': request.method, 'd': request.data, 'h': request.headers, 'ms': request.timeoutMs, 'p': providerName, 'f': responseFormat }, (request.postResultTo ? { 'prt': request.postResultTo } : {})))\n            .then((raw) => {\n            return parseRawXHRResponse(responseFormat, raw);\n        })\n            .catch((error) => {\n            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;\n            throw parseRawXHRResponse(responseFormat, raw);\n        });\n    }\n    oauthXhr(providerName, request) {\n        const responseFormat = request.responseFormat || 'utf8';\n        return this.sendCommand(\"oauth\" /* CommandName.SendOAuthRequest */, Object.assign({ 'url': request.url, 'm': request.method, 'd': request.data, 'h': request.headers, 'ms': request.timeoutMs, 'p': providerName, 'f': responseFormat }, (request.postResultTo ? { 'prt': request.postResultTo } : {})))\n            .then((raw) => {\n            return parseRawXHRResponse(responseFormat, raw);\n        })\n            .catch((error) => {\n            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;\n            throw parseRawXHRResponse(responseFormat, raw);\n        });\n    }\n    triggerAuthFlow(providerName) {\n        return this.sendCommand(\"tauth\" /* CommandName.TriggerAuthFlow */, {\n            'p': providerName,\n        });\n    }\n    /**\n     * Returns an OAuth token for the given provider, prompting the user to grant access if necessary\n     *\n     * @param providerName Name of the OAuth provider\n     * @returns An oauth token, or undefined if a valid token cannot be obtained\n     */\n    async getOAuthToken(providerName) {\n        return await this.sendCommand(\"got\" /* CommandName.GetOAuthToken */, { 'p': providerName });\n    }\n    /**\n     * Fetch the OAuth Client Id if there is one\n     *\n     * @param providerName Name of the OAuth provider\n     * @returns A oauth client id or undefined if it doesn't exist\n     */\n    async getOAuthClientId(providerName) {\n        return await this.sendCommand(\"goci\" /* CommandName.GetOAuthClientId */, { 'p': providerName });\n    }\n    permanentTokenXhr(providerName, request) {\n        const responseFormat = request.responseFormat || 'utf8';\n        return this.sendCommand(\"perm\" /* CommandName.SendPermanentTokenRequest */, {\n            'url': request.url,\n            'm': request.method,\n            'd': request.data,\n            'h': request.headers,\n            'ms': request.timeoutMs,\n            'p': providerName,\n            'f': responseFormat,\n        })\n            .then((raw) => {\n            return parseRawXHRResponse(responseFormat, raw);\n        })\n            .catch((error) => {\n            const raw = (0, commandtypes_1.isRawSendXHRResponse)(error) ? error : undefined;\n            throw parseRawXHRResponse(responseFormat, raw);\n        });\n    }\n    /**\n     * Register a named action. These actions can be triggered from custom UI, for example as the action of a\n     * custom menu item.\n     *\n     * Some actions may return a value that is used by the core application, e.g. a `visibleAction` for a menu\n     * item. However, if you return a `Promise` from your callback, that value will be discarded and your\n     * action will return `undefined` instead. The ability to provide a callback that returns a Promise is only\n     * a convenience so that you can register actions with `async` callbacks for easy async/await.\n     *\n     * Throws an error if the same action name is registered multiple times.\n     *\n     * @param name name of the action\n     * @param callback function to execute when this action is invoked\n     */\n    registerAction(name, callback) {\n        if (this.actionExists(name)) {\n            throw new Error('Action already exists: ' + name);\n        }\n        this.callbacks.set(name, callback);\n    }\n    /**\n     * Register a named action that receives file upload data. These callbacks can be used in\n     * Menu.addMenuItem as the file action.\n     * @param name The name of the action\n     * @param callback Function to execute when this action is invoked\n     */\n    registerFileUploadAction(name, callback) {\n        this.registerAction(name, (msg) => {\n            callback(msg['f'].map((rawFile) => {\n                if (rawFile['b']) {\n                    return { fileName: rawFile['n'], text: rawFile['t'], binary: (0, base64_1.decodeBase64)(rawFile['b']) };\n                }\n                else {\n                    return { fileName: rawFile['n'], text: rawFile['t'] };\n                }\n            }));\n        });\n    }\n    /**\n     * Registers a handler for link unfurling.\n     * @param domain The domain\n     * @param callbacks The callbacks to call when a link matching the domain is pasted.\n     */\n    registerUnfurlHandler(domain, callbacks) {\n        const action = this.getUniqueActionName();\n        this.registerAction(action, async (rawMsg) => {\n            var _a;\n            const msg = (0, unfurleventmessage_1.deserializeUnfurlEventMessage)(rawMsg);\n            switch (msg.unfurlCallbackType) {\n                case unfurlcallbacks_1.UnfurlCallbackType.Unfurl: {\n                    try {\n                        const result = await callbacks.unfurlCallback(msg.url);\n                        if (result && !(0, unfurlrefresherrortype_1.unfurlRefreshErrorTypeValidator)(result)) {\n                            return (0, unfurldetails_1.serializeUnfurlDetails)(result);\n                        }\n                    }\n                    catch (err) {\n                        return unfurlrefresherrortype_1.UnfurlRefreshErrorType.GenericFailure;\n                    }\n                    break;\n                }\n                case unfurlcallbacks_1.UnfurlCallbackType.AfterUnfurl: {\n                    if (msg.blockId) {\n                        const proxy = this.getBlockProxy(msg.blockId);\n                        if (proxy instanceof linkunfurlblockproxy_1.LinkUnfurlBlockProxy) {\n                            await ((_a = callbacks.afterUnfurlCallback) === null || _a === void 0 ? void 0 : _a.call(callbacks, proxy, msg.url));\n                        }\n                    }\n                    break;\n                }\n            }\n            return undefined;\n        });\n        this.sendCommand(\"ru\" /* CommandName.RegisterUnfurl */, { 'd': domain, 'a': action });\n    }\n    /**\n     * @ignore\n     * @deprecated Use registerUnfurlHandler instead.\n     */\n    experimentalRegisterUnfurlHandler(domain, callbacks) {\n        return this.registerUnfurlHandler(domain, callbacks);\n    }\n    /**\n     * Remove the callback for a given action. If the action is later invoked, nothing will happen.\n     * @param name name of the action to unregister\n     */\n    deleteAction(name) {\n        this.callbacks.delete(name);\n    }\n    /**\n     * @param name name of the action to check\n     * @returns true if a callback has been registered for this action; false otherwise\n     */\n    actionExists(name) {\n        return this.callbacks.has(name);\n    }\n    //Note: UnionToIntersection here fixes the type of params required if you're passing in something that's not a single\n    //specific command name, to require the type of all possible command names you could pass in, intersected. So if you\n    //call this with a CommandName.ListBlocks|CommandName.ListLines it will work as expected but if you just pass in a\n    //CommandName, there won't be any possible params you could pass that would meet all the requirements (string & undefined & ...)\n    /**\n     * Execute an API command. This is the low-level API that most of this SDK wraps. It is not expected that you should\n     * ever need to use this directly.\n     *\n     * @param name name of the API command to execute\n     * @param params data to pass to the API command\n     * @returns the output of the given API command\n     */\n    sendCommand(name, params) {\n        return lucid.executeCommand(name, params);\n    }\n    /**\n     * Create and return a proxy for accessing a block with the given ID. If the block is of a type that has a specific\n     * proxy implementation (e.g. an ERD block) then a specialized subclass of BlockProxy may be returned.\n     *\n     * @param id ID of the block to create a proxy for\n     * @returns the given block\n     */\n    getBlockProxy(id) {\n        const className = this.sendCommand(\"gp\" /* CommandName.GetProperty */, { 'id': id, 'p': 'ClassName' });\n        let proxy = (0, blockproxyregistry_1.findProxyClass)(className);\n        if (proxy === customblockproxy_1.CustomBlockProxy) {\n            proxy = customblockproxy_1.CustomBlockProxy.getCustomBlockClass(this, id);\n        }\n        if (proxy) {\n            return new proxy(id, this);\n        }\n        else {\n            return new blockproxy_1.BlockProxy(id, this);\n        }\n    }\n    /**\n     * Because code for block classes are loaded incrementally, you MUST call\n     * loadBlockClasses with the given block class name (and wait for it to\n     * resolve) before attempting to create a block. If you don't, an error\n     * will be thrown.\n     *\n     * @param classNames the block classes to load\n     * @returns a promise that resolves when the block classes can be used to create new blocks on the document\n     */\n    loadBlockClasses(classNames) {\n        return this.sendCommand(\"lbc\" /* CommandName.LoadBlockClasses */, classNames);\n    }\n    /**\n     * Import one or pages of the specified document or template into the current document\n     * as new pages.\n     * NOTE: The indices of the pages to import will change if the pages are rearranged\n     * on the source document or template.\n     *\n     * @param documentId The ID of the document or template to import\n     * @param pageNums An array of zero-indexed page indices to import from the document or template\n     * @returns a promise that resolves to void when the pages have been imported or the\n     * the import failed\n     */\n    async importPage(documentId, pageNums) {\n        return await this.sendCommand(\"imp\" /* CommandName.ImportPage */, { 'id': documentId, 'n': pageNums });\n    }\n    /**\n     * Load the requested shape library's content, and if it was found, return a block definition ready to be\n     * created.\n     *\n     * Example usage:\n     * ```inline:typescript\n     * const client = new EditorClient();\n     * const viewport = new Viewport(client);\n     *\n     * const page = viewport.getCurrentPage();\n     * if (page) {\n     *     const def = await page.getCustomShapeDefinition('libraryName', 'shapeName');\n     *     if (def) {\n     *         //Customize the shape about to be created\n     *         def.boundingBox.x = 500;\n     *         def.boundingBox.y = 500;\n     *\n     *         //Create the shape itself\n     *         const block = page.addBlock(def);\n     *\n     *         //Set any data fields on the shape as needed\n     *         block.shapeData.set('Value', 50);\n     *     }\n     * }\n     * ```\n     * @param library Name of the shape library in this extension to search for\n     * @param shape Name of the shape within that library to search for\n     * @returns\n     */\n    async getCustomShapeDefinition(library, shape) {\n        await this.loadBlockClasses(['CustomBlock']);\n        const shapeData = await this.sendCommand(\"gcs\" /* CommandName.GetCustomShape */, { 'l': library, 's': shape });\n        if (shapeData) {\n            return {\n                className: 'CustomBlock',\n                boundingBox: shapeData['bb'],\n                stencil: shapeData['s'],\n                properties: shapeData['p'],\n            };\n        }\n        return undefined;\n    }\n    /**\n     * @param callback A callback that processes the bootstrap data, if any, stored on the document and\n     * associated with this editor extension. If this callback is async (returns a promise), then the\n     * bootstrap data is not cleared off of the document until that promise resolves.\n     *\n     * @param markExtensionAsRequired If bootstrap data is available for this editor extension, this will mark the\n     * document as requiring the extension. Once marked, if the extension is not installed the user will be\n     * notified about the extension being required on document load. The minimum extension version required by the\n     * document is the version provided in the request body when creating the document.\n     *\n     * @return a promise that resolves immediately if there is no available bootstrap data, or else after\n     * the callback successfully completes. This promise will reject/throw if the callback throws or\n     * returns a promise that rejects, or if there is another editor session processing the same bootstrap\n     * data at the same time.\n     */\n    async processAndClearBootstrapData(callback, markExtensionAsRequired) {\n        const name = this.getUniqueActionName();\n        this.registerAction(name, (msg) => {\n            return callback(msg['d']);\n        });\n        await this.sendCommand(\"b\" /* CommandName.Bootstrap */, { 'c': name, 'm': markExtensionAsRequired });\n        this.deleteAction(name);\n    }\n    /**\n     * @param id ID of the line to create a proxy for\n     * @returns the given line\n     */\n    getLineProxy(id) {\n        return new lineproxy_1.LineProxy(id, this);\n    }\n    /**\n     * @param id ID of the page to create a proxy for\n     * @returns the given page\n     */\n    getPageProxy(id) {\n        return new pageproxy_1.PageProxy(id, this);\n    }\n    /**\n     * @param id ID of the item to create a proxy for\n     * @returns the given item\n     */\n    getItemProxy(id) {\n        const type = this.sendCommand(\"get\" /* CommandName.GetElementType */, { 'id': id });\n        switch (type) {\n            case 'block':\n                return this.getBlockProxy(id);\n            case 'line':\n                return this.getLineProxy(id);\n            case 'group':\n                return new groupproxy_1.GroupProxy(id, this);\n            default:\n                throw new Error('Element ' + id + ' is not an Item; type found is ' + type);\n        }\n    }\n    /**\n     * @param id ID of the item to create a proxy for\n     * @returns the given item, or undefined if the item does not exist or an error occurs\n     */\n    tryGetItemProxy(id) {\n        try {\n            const item = this.getItemProxy(id);\n            if (item.exists()) {\n                return item;\n            }\n        }\n        catch (_a) { }\n        return undefined;\n    }\n    /**\n     * @param id ID of the element to create a proxy for\n     * @returns the given element\n     */\n    getElementProxy(id) {\n        const type = this.sendCommand(\"get\" /* CommandName.GetElementType */, { 'id': id });\n        switch (type) {\n            case 'block':\n                return this.getBlockProxy(id);\n            case 'line':\n                return this.getLineProxy(id);\n            case 'page':\n                return this.getPageProxy(id);\n            case 'document':\n                return new documentproxy_1.DocumentProxy(this);\n            case 'group':\n                return new groupproxy_1.GroupProxy(id, this);\n            default:\n                return new elementproxy_1.ElementProxy(id, this);\n        }\n    }\n    /**\n     * @hidden\n     */\n    listenToEditor() {\n        lucid.listen((msg) => {\n            var _a;\n            return (_a = this.callbacks.get(msg['id'])) === null || _a === void 0 ? void 0 : _a(msg);\n        });\n    }\n    /**\n     * Display an alert modal to the user\n     * @param text Body text to display in the alert modal\n     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json\n     * @param buttonText Text for the OK button; defaults to \"OK\" (or a translation)\n     * @returns a Promise that resolves true if the user clicks OK, false if they otherwise dismiss the modal\n     */\n    alert(text, title, buttonText) {\n        return this.sendCommand(\"a\" /* CommandName.Alert */, { 't': title, 'b': text, 'bt': buttonText });\n    }\n    /**\n     * Display a confirm modal to the user\n     * @param text Body text to display in the alert modal\n     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json\n     * @param okText Text for the OK button; defaults to \"OK\" (or a translation)\n     * @param cancelText Text for the Cancel button; defaults to \"Cancel\" (or a translation)\n     * @returns a Promise that resolves true if the user clicks OK, false if they click Cancel or otherwise dismiss the modal\n     */\n    confirm(text, title, okText, cancelText) {\n        return this.sendCommand(\"c\" /* CommandName.Confirm */, { 't': title, 'b': text, 'o': okText, 'c': cancelText });\n    }\n    /**\n     * Display a prompt modal to the user\n     * @param text Body text to display in the alert modal\n     * @param title Title of the alert modal; defaults to the extension title specified in manifest.json\n     * @returns a Promise that resolves to a string if a user enters one, or undefined if they cancel\n     */\n    prompt(text, title) {\n        return this.sendCommand(\"p\" /* CommandName.Prompt */, { 't': title, 'b': text });\n    }\n    /**\n     * Executes the given callback within a mutex scoped to the current document, extension, and the given name.\n     * If another editor session currently has the given mutex name locked within the same extension package ID\n     * on this same document, this function's returned promise will resolve to false. Otherwise, the mutex will\n     * be locked for the duration of the callback and the returned promise will resolve to true.\n     * @param name Name of the intra-document mutex to attempt to lock\n     * @param callback Code to execute while the mutex is locked, if it is successfully locked\n     * @returns A promise resolving to a boolean indicating whether the mutex was successfully locked\n     */\n    async withIntraDocumentMutex(name, callback) {\n        const action = this.getUniqueActionName();\n        this.registerAction(action, callback);\n        try {\n            return await this.sendCommand(\"wm\" /* CommandName.WithMutex */, { 'n': name, 'a': action });\n        }\n        finally {\n            this.deleteAction(action);\n        }\n    }\n    /**\n     * @param callback Callback that will be executed with the user's local undo/redo history suppressed. This is\n     * useful when you want to make changes to a document that will not be erased if the user uses undo or redo,\n     * for example adding shape data onto shapes as a result of a background process that collects data from a\n     * remote API.\n     */\n    withSilentActions(callback) {\n        const action = this.getUniqueActionName();\n        this.registerAction(action, () => {\n            const result = callback();\n            if ((0, checks_1.isPromise)(result)) {\n                throw new Error('withSilentActions cannot be used with an async callback');\n            }\n        });\n        try {\n            this.sendCommand(\"wsa\" /* CommandName.WithSilentActions */, { 'a': action });\n        }\n        finally {\n            this.deleteAction(action);\n        }\n    }\n    /**\n     * Hash a particular string using the given algorithm.\n     *\n     * Hashing can be very slow in extensions, so we provide this utility function to instead run hashing algorithms\n     * in the client.\n     *\n     * @param algorithm Which hashing algorithm to apply to the string. We currently only support SHA256.\n     * @param string The raw string we are calculating the hash of.\n     * @returns The hashed string.\n     */\n    /** @ignore because our documentation gets generated incorrectly for an as-yet unknown reason. It seems to refer to the HashAlgorithmEnum with an incorrect link. */\n    hash(algorithm, string) {\n        return this.sendCommand(\"hsh\" /* CommandName.CalculateHash */, { 'a': algorithm, 's': string });\n    }\n    constructor() {\n        this.nextId = 0;\n        this.callbacks = new Map();\n        this.listenToEditor();\n    }\n}\nexports.EditorClient = EditorClient;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/editorclient.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/index.js":
/*!***************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./commandtypes */ \"./node_modules/lucid-extension-sdk/commandtypes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/base64 */ \"./node_modules/lucid-extension-sdk/core/base64.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/cardintegration/cardfielddisplaysettings */ \"./node_modules/lucid-extension-sdk/core/cardintegration/cardfielddisplaysettings.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/cardintegration/cardintegrationconfig */ \"./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationconfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/cardintegration/cardintegrationdefinitions */ \"./node_modules/lucid-extension-sdk/core/cardintegration/cardintegrationdefinitions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/cardintegration/lucidcardintegration */ \"./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegration.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/cardintegration/lucidcardintegrationregistry */ \"./node_modules/lucid-extension-sdk/core/cardintegration/lucidcardintegrationregistry.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/datasourcetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/datasourcetype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/datasourceutils */ \"./node_modules/lucid-extension-sdk/core/data/datasource/datasourceutils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/metadatatypes */ \"./node_modules/lucid-extension-sdk/core/data/datasource/metadatatypes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/serializeddatasourceproperties */ \"./node_modules/lucid-extension-sdk/core/data/datasource/serializeddatasourceproperties.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/serializedimporteddatasource */ \"./node_modules/lucid-extension-sdk/core/data/datasource/serializedimporteddatasource.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/serializedupstreamconfig */ \"./node_modules/lucid-extension-sdk/core/data/datasource/serializedupstreamconfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/upstreamconfig */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreamconfig.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/upstreampatchtype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreampatchtype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/datasource/upstreamupdatetype */ \"./node_modules/lucid-extension-sdk/core/data/datasource/upstreamupdatetype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldspecification */ \"./node_modules/lucid-extension-sdk/core/data/fieldspecification.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/basefieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/basefieldtypedefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/collectionenumfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/collectionenumfieldtype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/fieldtypearray */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypearray.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/fieldtypedefinition */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/fieldtypedefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/literalfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/literalfieldtype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/ndimensionalfieldtypearray */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/ndimensionalfieldtypearray.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/scalarfieldtype */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/scalarfieldtype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/fieldtypedefinition/semantickind */ \"./node_modules/lucid-extension-sdk/core/data/fieldtypedefinition/semantickind.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/referencekeys/serializedreferencekey */ \"./node_modules/lucid-extension-sdk/core/data/referencekeys/serializedreferencekey.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/serializedfield/serializeddataitems */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializeddataitems.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/serializedfield/serializedfielddefinition */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfielddefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/serializedfield/serializedfields */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedfields.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/data/serializedfield/serializedschema */ \"./node_modules/lucid-extension-sdk/core/data/serializedfield/serializedschema.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/dataerrortype */ \"./node_modules/lucid-extension-sdk/core/dataerrortype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/guards */ \"./node_modules/lucid-extension-sdk/core/guards.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/humanreadableerror */ \"./node_modules/lucid-extension-sdk/core/humanreadableerror.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/iframe/iframeutils */ \"./node_modules/lucid-extension-sdk/core/iframe/iframeutils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/jsonserializable */ \"./node_modules/lucid-extension-sdk/core/jsonserializable.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/lucidproduct */ \"./node_modules/lucid-extension-sdk/core/lucidproduct.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/object */ \"./node_modules/lucid-extension-sdk/core/object.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/offsettype */ \"./node_modules/lucid-extension-sdk/core/offsettype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/optionalkey */ \"./node_modules/lucid-extension-sdk/core/optionalkey.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/datagraphic/badgeposition */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/badgeposition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/datagraphic/datagraphicindexes */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/datagraphicindexes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/datagraphic/staticdatagraphicsettings */ \"./node_modules/lucid-extension-sdk/core/properties/datagraphic/staticdatagraphicsettings.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/fillcolor */ \"./node_modules/lucid-extension-sdk/core/properties/fillcolor.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/shadow */ \"./node_modules/lucid-extension-sdk/core/properties/shadow.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/properties/strokestyle */ \"./node_modules/lucid-extension-sdk/core/properties/strokestyle.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/rules/conditions */ \"./node_modules/lucid-extension-sdk/core/rules/conditions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/rules/conditiontype */ \"./node_modules/lucid-extension-sdk/core/rules/conditiontype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/rules/serializedeffect */ \"./node_modules/lucid-extension-sdk/core/rules/serializedeffect.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/serializeddataerror */ \"./node_modules/lucid-extension-sdk/core/serializeddataerror.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/shapedatainheritance */ \"./node_modules/lucid-extension-sdk/core/shapedatainheritance.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/spreadsheetintegration/lucidspreadsheetintegration */ \"./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegration.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/spreadsheetintegration/lucidspreadsheetintegrationregistry */ \"./node_modules/lucid-extension-sdk/core/spreadsheetintegration/lucidspreadsheetintegrationregistry.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/unfurl/unfurlcallbacks */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurlcallbacks.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/unfurl/unfurldetails */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurldetails.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/unfurl/unfurliframe */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurliframe.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/unfurl/unfurlrefresherrortype */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurlrefresherrortype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/unfurl/unfurlthumbnail */ \"./node_modules/lucid-extension-sdk/core/unfurl/unfurlthumbnail.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/validators/validators */ \"./node_modules/lucid-extension-sdk/core/validators/validators.js\"), exports);\n__exportStar(__webpack_require__(/*! ./core/xhr */ \"./node_modules/lucid-extension-sdk/core/xhr.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/collectiondefinition */ \"./node_modules/lucid-extension-sdk/data/collectiondefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/collectionproxy */ \"./node_modules/lucid-extension-sdk/data/collectionproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/dataerror */ \"./node_modules/lucid-extension-sdk/data/dataerror.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/dataitemproxy */ \"./node_modules/lucid-extension-sdk/data/dataitemproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/dataproxy */ \"./node_modules/lucid-extension-sdk/data/dataproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/datasourceproxy */ \"./node_modules/lucid-extension-sdk/data/datasourceproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/dataupdatefiltertype */ \"./node_modules/lucid-extension-sdk/data/dataupdatefiltertype.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/referencekeydefinition */ \"./node_modules/lucid-extension-sdk/data/referencekeydefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/referencekeyproxy */ \"./node_modules/lucid-extension-sdk/data/referencekeyproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./data/schemadefinition */ \"./node_modules/lucid-extension-sdk/data/schemadefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/actions/action */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/action.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/actions/managewebhookresponsebody */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/managewebhookresponsebody.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/actions/patchresponsebody */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/patchresponsebody.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/actions/serializedactions */ \"./node_modules/lucid-extension-sdk/dataconnector/actions/serializedactions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/dataconnector */ \"./node_modules/lucid-extension-sdk/dataconnector/dataconnector.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/dataconnectorclient */ \"./node_modules/lucid-extension-sdk/dataconnector/dataconnectorclient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/datasourceclient */ \"./node_modules/lucid-extension-sdk/dataconnector/datasourceclient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/datasourcemetadatatypes */ \"./node_modules/lucid-extension-sdk/dataconnector/datasourcemetadatatypes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/datasourceupdatetypes */ \"./node_modules/lucid-extension-sdk/dataconnector/datasourceupdatetypes.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dataconnector/signaturevalidator */ \"./node_modules/lucid-extension-sdk/dataconnector/signaturevalidator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/blockproxyregistry */ \"./node_modules/lucid-extension-sdk/document/blockclasses/blockproxyregistry.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/cardblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/cardblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/customblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/customblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/erdblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/erdblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/legendblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/legendblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/linkunfurlblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/linkunfurlblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/swimlaneblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/swimlaneblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockclasses/tableblockproxy */ \"./node_modules/lucid-extension-sdk/document/blockclasses/tableblockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockdefinition */ \"./node_modules/lucid-extension-sdk/document/blockdefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/blockproxy */ \"./node_modules/lucid-extension-sdk/document/blockproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/documentproxy */ \"./node_modules/lucid-extension-sdk/document/documentproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/elementproxy */ \"./node_modules/lucid-extension-sdk/document/elementproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/groupproxy */ \"./node_modules/lucid-extension-sdk/document/groupproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/itemproxy */ \"./node_modules/lucid-extension-sdk/document/itemproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/linedefinition */ \"./node_modules/lucid-extension-sdk/document/linedefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/lineproxy */ \"./node_modules/lucid-extension-sdk/document/lineproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/linetextareapositioning */ \"./node_modules/lucid-extension-sdk/document/linetextareapositioning.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/mapproxy */ \"./node_modules/lucid-extension-sdk/document/mapproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/pagedefinition */ \"./node_modules/lucid-extension-sdk/document/pagedefinition.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/pageproxy */ \"./node_modules/lucid-extension-sdk/document/pageproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/propertystoreproxy */ \"./node_modules/lucid-extension-sdk/document/propertystoreproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/shapedataproxy */ \"./node_modules/lucid-extension-sdk/document/shapedataproxy.js\"), exports);\n__exportStar(__webpack_require__(/*! ./document/text/textstyle */ \"./node_modules/lucid-extension-sdk/document/text/textstyle.js\"), exports);\n__exportStar(__webpack_require__(/*! ./editorclient */ \"./node_modules/lucid-extension-sdk/editorclient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./index */ \"./node_modules/lucid-extension-sdk/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./math */ \"./node_modules/lucid-extension-sdk/math.js\"), exports);\n__exportStar(__webpack_require__(/*! ./message/unfurleventmessage */ \"./node_modules/lucid-extension-sdk/message/unfurleventmessage.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/alertmodal */ \"./node_modules/lucid-extension-sdk/ui/alertmodal.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/iframeui */ \"./node_modules/lucid-extension-sdk/ui/iframeui.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/menu */ \"./node_modules/lucid-extension-sdk/ui/menu.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/modal */ \"./node_modules/lucid-extension-sdk/ui/modal.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/panel */ \"./node_modules/lucid-extension-sdk/ui/panel.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ui/viewport */ \"./node_modules/lucid-extension-sdk/ui/viewport.js\"), exports);\n__exportStar(__webpack_require__(/*! ./user/userproxy */ \"./node_modules/lucid-extension-sdk/user/userproxy.js\"), exports);\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/index.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/math.js":
/*!**************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/math.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rotateAroundFn = exports.toCornersAsArray = exports.boxFrom4Points = exports.rotateBox = exports.rotatedBoundingBox = exports.boxCenter = exports.clip = exports.percentBoxesOverlap = exports.boxesOverlap = exports.isBoxWithin = exports.padBox = exports.combinedBoundingBox = void 0;\nfunction combinedBoundingBox(boxes) {\n    if (boxes.length == 0) {\n        return undefined;\n    }\n    let minX = Number.MAX_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxX = -Number.MAX_VALUE;\n    let maxY = -Number.MAX_VALUE;\n    for (const box of boxes) {\n        minX = Math.min(minX, box.x);\n        maxX = Math.max(maxX, box.x + box.w);\n        minY = Math.min(minY, box.y);\n        maxY = Math.max(maxY, box.y + box.h);\n    }\n    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };\n}\nexports.combinedBoundingBox = combinedBoundingBox;\nfunction padBox(box, padding) {\n    return { x: box.x - padding, y: box.y - padding, w: box.w + padding * 2, h: box.h + padding * 2 };\n}\nexports.padBox = padBox;\n/**\n * Is box a completely within box b?\n */\nfunction isBoxWithin(a, b) {\n    return a.x >= b.x && a.y >= b.y && a.x + a.w <= b.x + b.w && a.y + a.h <= b.y + b.h;\n}\nexports.isBoxWithin = isBoxWithin;\n/**\n * Do two boxes overlap?\n */\nfunction boxesOverlap(a, b) {\n    return a.x + a.w >= b.x && a.y + a.h >= b.y && b.x + b.w >= a.x && b.y + b.h >= a.y;\n}\nexports.boxesOverlap = boxesOverlap;\n/**\n * return the percentage of a that overlaps with b.\n * if a is entirely within b, it returns 1 (or a number a little less than 1\n * (e.g., 0.99999999999) due to numerical inaccuracy); if a is entirely\n * outside b, it returns 0.\n */\nfunction percentBoxesOverlap(a, b) {\n    const intersection = clip(a, b);\n    // if either dimension is negative return zero\n    if (intersection.w <= 0 || intersection.h <= 0) {\n        return 0;\n    }\n    const area = intersection.w * intersection.h;\n    return area / (a.w * a.h);\n}\nexports.percentBoxesOverlap = percentBoxesOverlap;\n/**\n * Gets the intersection of two boxes\n * @return a clipped to b\n */\nfunction clip(a, b) {\n    const x = Math.max(a.x, b.x);\n    const y = Math.max(a.y, b.y);\n    const w = Math.min(a.x + a.w, b.x + b.w) - x;\n    const h = Math.min(a.y + a.h, b.y + b.h) - y;\n    return { x, y, w, h };\n}\nexports.clip = clip;\nfunction boxCenter(b) {\n    return { x: b.x + b.w / 2, y: b.y + b.h / 2 };\n}\nexports.boxCenter = boxCenter;\n/**\n * Returns the bounding box that would surround the given\n * box when rotated the given amount.\n */\nfunction rotatedBoundingBox(b, angle, center) {\n    if (!angle) {\n        return b;\n    }\n    center = center || boxCenter(b);\n    return boxFrom4Points.apply(null, rotateBox(b, angle, center));\n}\nexports.rotatedBoundingBox = rotatedBoundingBox;\nfunction rotateBox(b, angle, center) {\n    const ret = toCornersAsArray(b);\n    center = center || boxCenter(b);\n    if (angle != 0) {\n        return ret.map(rotateAroundFn(center, angle));\n    }\n    return ret;\n}\nexports.rotateBox = rotateBox;\nfunction boxFrom4Points(a, b, c, d) {\n    const xMin = Math.min(a.x, b.x, c.x, d.x);\n    const xMax = Math.max(a.x, b.x, c.x, d.x);\n    const yMin = Math.min(a.y, b.y, c.y, d.y);\n    const yMax = Math.max(a.y, b.y, c.y, d.y);\n    return { x: xMin, y: yMin, w: xMax - xMin, h: yMax - yMin };\n}\nexports.boxFrom4Points = boxFrom4Points;\nfunction toCornersAsArray(box) {\n    return [\n        { x: box.x, y: box.y },\n        { x: box.x + box.w, y: box.y },\n        { x: box.x + box.w, y: box.y + box.h },\n        { x: box.x, y: box.y + box.h },\n    ];\n}\nexports.toCornersAsArray = toCornersAsArray;\nfunction rotateAroundFn(anchor, angle) {\n    const cos = Math.cos(angle);\n    const sin = Math.sin(angle);\n    return (p) => {\n        const anchorX = anchor.x;\n        const anchorY = anchor.y;\n        const x = p.x - anchorX;\n        const y = p.y - anchorY;\n        return { x: x * cos - y * sin + anchorX, y: y * cos + x * sin + anchorY };\n    };\n}\nexports.rotateAroundFn = rotateAroundFn;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/math.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/message/unfurleventmessage.js":
/*!************************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/message/unfurleventmessage.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeUnfurlEventMessage = exports.deserializeUnfurlEventMessage = void 0;\n/** @ignore */\nfunction deserializeUnfurlEventMessage(raw) {\n    return {\n        id: raw['id'],\n        url: raw['u'],\n        unfurlCallbackType: raw['t'],\n        blockId: raw['b'],\n    };\n}\nexports.deserializeUnfurlEventMessage = deserializeUnfurlEventMessage;\n/** @ignore */\nfunction serializeUnfurlEventMessage(concrete) {\n    return {\n        'id': concrete.id,\n        'u': concrete.url,\n        't': concrete.unfurlCallbackType,\n        'b': concrete.blockId,\n    };\n}\nexports.serializeUnfurlEventMessage = serializeUnfurlEventMessage;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/message/unfurleventmessage.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/ui/alertmodal.js":
/*!***********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/ui/alertmodal.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AlertModal = void 0;\nconst modal_1 = __webpack_require__(/*! ./modal */ \"./node_modules/lucid-extension-sdk/ui/modal.js\");\n/**\n * A simple example modal that displays a message to the user\n * TODO: Replace with a dedicated command\n * @ignore\n */\nclass AlertModal extends modal_1.Modal {\n    constructor(client, title, message) {\n        super(client, {\n            width: 300,\n            height: 200,\n            title: title,\n            content: `\n<html>\n<head>\n<style type=\"text/css\">\np {\n    font-family: 'Graphik LC Web', sans-serif;\n    font-size:14px;\n    text-align:center;\n}\n</style>\n</head>\n<body>\n<p id=\"message\"></p>\n<script type=\"text/javascript\">\n    var p = document.getElementById('message');\n    p.innerText = ${JSON.stringify(message)};\n</script>\n</body>\n</html>\n            `,\n        });\n    }\n}\nexports.AlertModal = AlertModal;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/ui/alertmodal.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/ui/iframeui.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/ui/iframeui.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IframeUI = exports.IncomingUIMessageType = void 0;\nconst defer_1 = __webpack_require__(/*! ../core/defer */ \"./node_modules/lucid-extension-sdk/core/defer.js\");\n/** @ignore */\nvar IncomingUIMessageType;\n(function (IncomingUIMessageType) {\n    IncomingUIMessageType[IncomingUIMessageType[\"Closed\"] = 1] = \"Closed\";\n    IncomingUIMessageType[IncomingUIMessageType[\"PostMessageFromFrame\"] = 2] = \"PostMessageFromFrame\";\n    IncomingUIMessageType[IncomingUIMessageType[\"FrameLoaded\"] = 3] = \"FrameLoaded\";\n    IncomingUIMessageType[IncomingUIMessageType[\"FramePosition\"] = 4] = \"FramePosition\";\n})(IncomingUIMessageType || (exports.IncomingUIMessageType = IncomingUIMessageType = {}));\n/**\n * Base class for defining and interacting with custom UI elements whose contents are displayed\n * in an iframe.\n */\nclass IframeUI {\n    constructor(client) {\n        this.client = client;\n        this.id = ++IframeUI.nextId;\n        this.messageActionName = IframeUI.uiMessageActionNamePrefix + this.id;\n        /** True after the iframe has fired an onload event (not all scripts are necessarily finished executing) */\n        this.loaded = false;\n        this.frameLoadedPromise = (0, defer_1.defer)();\n        /**\n         * The location of this frame within the top-level browser window. This is always updated immediately before\n         * `messageFromFrame` is called.\n         */\n        this.framePosition = { x: 0, y: 0, w: 1, h: 1 };\n    }\n    /** @ignore */\n    static isUIMessageActionName(name) {\n        return name.startsWith(IframeUI.uiMessageActionNamePrefix);\n    }\n    /**\n     * Subclasses must call hookMessages some time before the UI is displayed. A Modal\n     * will call this when the open() method is called, where a Panel will need to do\n     * this in the constructor to watch for the user opening the panel.\n     */\n    hookMessages() {\n        this.client.registerAction(this.messageActionName, (message) => {\n            switch (message['t']) {\n                case IncomingUIMessageType.Closed:\n                    this.loaded = false;\n                    this.frameClosed();\n                    break;\n                case IncomingUIMessageType.PostMessageFromFrame:\n                    this.messageFromFrame(message['data']);\n                    break;\n                case IncomingUIMessageType.FramePosition:\n                    this.framePosition = message['data'];\n                    break;\n                case IncomingUIMessageType.FrameLoaded:\n                    this.loaded = true;\n                    this.frameLoadedPromise.resolve();\n                    this.frameLoaded();\n                    break;\n            }\n        });\n    }\n    /**\n     * Subclasses must call unhookMessages to allow them to be garbage collected.\n     */\n    unhookMessages() {\n        this.client.deleteAction(this.messageActionName);\n    }\n    /**\n     * Send a message to this UI component's iframe via window.postMessage.\n     * @param data Data to send to the iframe\n     */\n    async sendMessage(data) {\n        await this.frameLoadedPromise;\n        this.client.sendCommand(\"suim\" /* CommandName.SendUIMessage */, {\n            'n': this.messageActionName,\n            'd': data,\n        });\n    }\n    /**\n     * Receives messages sent from the iframe via parent.postMessage(<data>, '*')\n     * @param message data sent from the iframe\n     */\n    messageFromFrame(message) { }\n    /**\n     * Called when the iframe has been constructed, its srcdoc set, and the window loaded event has fired\n     */\n    frameLoaded() { }\n    /**\n     * Called when the iframe has been removed from the DOM\n     */\n    frameClosed() { }\n}\nexports.IframeUI = IframeUI;\nIframeUI.nextId = 0;\nIframeUI.uiMessageActionNamePrefix = '__ui_message__';\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/ui/iframeui.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/ui/menu.js":
/*!*****************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/ui/menu.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Menu = exports.MenuLocation = exports.MenuType = void 0;\n/**\n * Type of menu you're adding.\n * Consider using addDropdownMenuItem, addContextMenuItem, or addContentDockMenuItem for easier to use entrypoints and clearer requirements.\n */\nvar MenuType;\n(function (MenuType) {\n    /** The main drop down menus. */\n    MenuType[MenuType[\"Main\"] = 1] = \"Main\";\n    /** The context menu that appears when the user right-clicks the canvas. */\n    MenuType[MenuType[\"Context\"] = 2] = \"Context\";\n    /** The side dock in Lucidspark and Teamspaces */\n    MenuType[MenuType[\"ContentDock\"] = 3] = \"ContentDock\";\n})(MenuType || (exports.MenuType = MenuType = {}));\n/**\n * Semantic locations to place a new menu item.\n */\nvar MenuLocation;\n(function (MenuLocation) {\n    /** Default location: a new top-level menu entry for this extension, or the end of the context menu */\n    MenuLocation[MenuLocation[\"Extension\"] = 1] = \"Extension\";\n    MenuLocation[MenuLocation[\"Edit\"] = 2] = \"Edit\";\n    MenuLocation[MenuLocation[\"View\"] = 3] = \"View\";\n    MenuLocation[MenuLocation[\"Share\"] = 4] = \"Share\";\n    MenuLocation[MenuLocation[\"Export\"] = 5] = \"Export\";\n    MenuLocation[MenuLocation[\"Import\"] = 6] = \"Import\";\n})(MenuLocation || (exports.MenuLocation = MenuLocation = {}));\nclass Menu {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Generic function to create a new menu item to trigger custom code.\n     * You can use addDropdownMenuItem, addContextMenuItem, or addContentDockMenuItem for easier to use entrypoints.\n     *\n     * The action must be registered with\n     * [EditorClient.registerAction](/extension-sdk/#classes_editorclient-EditorClient_registeraction)\n     * prior to using it in the menu.\n     *\n     * @param item The definition of the new menu item\n     */\n    addMenuItem(item) {\n        if (item.action && !this.client.actionExists(item.action)) {\n            throw new Error('Unregistered action: ' + item.action);\n        }\n        if (item.visibleAction && !this.client.actionExists(item.visibleAction)) {\n            throw new Error('Unregistered action: ' + item.visibleAction);\n        }\n        if (item.disabledAction && !this.client.actionExists(item.disabledAction)) {\n            throw new Error('Unregistered action: ' + item.disabledAction);\n        }\n        if (item.menuType == MenuType.ContentDock && !item.iconUrl) {\n            throw new Error('MenuType.ContentDock requires icon url');\n        }\n        if (item.menuType == MenuType.ContentDock && !item.action) {\n            throw new Error('MenuType.ContentDock requires action');\n        }\n        this.client.sendCommand(\"ami\" /* CommandName.AddMenuItem */, {\n            'l': item.label,\n            'i': item.iconUrl,\n            'a': item.action,\n            'v': item.visibleAction,\n            'd': item.disabledAction,\n            't': item.menuType,\n            'loc': item.location,\n            'f': item.file\n                ? {\n                    'a': item.file.action,\n                    'ac': item.file.accept,\n                    's': item.file.singleFileOnly,\n                    'b': item.file.binary,\n                }\n                : undefined,\n        });\n    }\n    /**\n     * Create a menu in the basic drop down top menus. In Lucidspark this will just be under the generic menu.\n     * In Lucidchart you can configure this to be in any of the other drop down menus.\n     *\n     * The action must be registered with\n     * [EditorClient.registerAction](/extension-sdk/#classes_editorclient-EditorClient_registeraction)\n     * prior to using it in the menu.\n     *\n     * @param item The definition of the new menu item\n     */\n    addDropdownMenuItem(item) {\n        var _a;\n        this.addMenuItem({\n            label: item.label,\n            action: item.action,\n            visibleAction: item.visibleAction,\n            disabledAction: item.disabledAction,\n            menuType: MenuType.Main,\n            location: (_a = item.location) !== null && _a !== void 0 ? _a : MenuLocation.Extension,\n            file: item.file,\n        });\n    }\n    /**\n     * Create a menu in the right click context menu. Appears in both Lucidspark and Lucidchart.\n     *\n     * The action must be registered with\n     * [EditorClient.registerAction](/extension-sdk/#classes_editorclient-EditorClient_registeraction)\n     * prior to using it in the menu.\n     *\n     * @param item The definition of the new menu item\n     */\n    addContextMenuItem(item) {\n        this.addMenuItem({\n            label: item.label,\n            action: item.action,\n            visibleAction: item.visibleAction,\n            disabledAction: item.disabledAction,\n            menuType: MenuType.Context,\n            location: MenuLocation.Extension,\n            file: item.file,\n        });\n    }\n    /**\n     * Create an icon tied to an action (required) that appears in the left toolbar in Lucidspark and Teamspaces (not in Lucidchart).\n     *\n     * The action must be registered with\n     * [EditorClient.registerAction](/extension-sdk/#classes_editorclient-EditorClient_registeraction)\n     * prior to using it in the menu.\n     *\n     * @param item The definition of the new menu item\n     */\n    addContentDockMenuItem(item) {\n        this.addMenuItem({\n            label: item.label,\n            iconUrl: item.iconUrl,\n            action: item.action,\n            visibleAction: item.visibleAction,\n            disabledAction: item.disabledAction,\n            menuType: MenuType.ContentDock,\n            location: MenuLocation.Extension,\n            file: item.file,\n        });\n    }\n}\nexports.Menu = Menu;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/ui/menu.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/ui/modal.js":
/*!******************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/ui/modal.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Modal = void 0;\nconst iframeui_1 = __webpack_require__(/*! ./iframeui */ \"./node_modules/lucid-extension-sdk/ui/iframeui.js\");\n/**\n * Extend this class to show a custom modal to the user, whose contents are displayed in a sandboxed\n * iframe controlled by your extension.\n *\n * To pass a message to a script running in the modal, call sendMessage. The data you pass in will be\n * sent to the iframe with window.postMessage.\n *\n * To pass messages back from the modal to this class, call parent.postMessage from within the iframe.\n * The data sent will be passed along to the messageFromFrame implementation on your Modal class.\n */\nclass Modal extends iframeui_1.IframeUI {\n    constructor(client, config) {\n        super(client);\n        this.config = config;\n        this.visible = false;\n    }\n    frameClosed() {\n        this.visible = false;\n        this.unhookMessages();\n    }\n    async show() {\n        if (!this.visible) {\n            this.hookMessages();\n            await this.client.sendCommand(\"sm\" /* CommandName.ShowModal */, {\n                'n': this.messageActionName,\n                't': this.config.title,\n                'w': this.config.width,\n                'h': this.config.height,\n                'cl': this.config.chromeless,\n                'fs': this.config.fullScreen,\n                'tb': this.config.transparentBackground,\n                'c': this.config.content,\n                'u': this.config.url,\n            });\n            this.visible = true;\n        }\n    }\n    /**\n     * If this modal is currently visible, close it, destroying the iframe.\n     */\n    hide() {\n        if (this.visible) {\n            this.client.sendCommand(\"hm\" /* CommandName.HideModal */, { 'n': this.messageActionName });\n            this.visible = false;\n        }\n    }\n}\nexports.Modal = Modal;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/ui/modal.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/ui/panel.js":
/*!******************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/ui/panel.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Panel = exports.PanelLocation = void 0;\nconst iframeui_1 = __webpack_require__(/*! ./iframeui */ \"./node_modules/lucid-extension-sdk/ui/iframeui.js\");\n/**\n * Semantic locations to place a new menu item.\n */\nvar PanelLocation;\n(function (PanelLocation) {\n    /** In Lucidchart, create a sibling to the Contextual Panel */\n    PanelLocation[PanelLocation[\"RightDock\"] = 1] = \"RightDock\";\n    /** In Lucidchart, create a sibling to the shape toolbox */\n    PanelLocation[PanelLocation[\"ContentDock\"] = 2] = \"ContentDock\";\n    /** In Lucidchart & Lucidspark, add to the image dock */\n    PanelLocation[PanelLocation[\"ImageSearchTab\"] = 3] = \"ImageSearchTab\";\n})(PanelLocation || (exports.PanelLocation = PanelLocation = {}));\n/**\n * Extend this class to show a custom panel to the user, whose contents are displayed in a sandboxed\n * iframe controlled by your extension.\n *\n * To pass a message to a script running in the panel, call sendMessage. The data you pass in will be\n * sent to the iframe with window.postMessage.\n *\n * To pass messages back from the panel to this class, call parent.postMessage from within the iframe.\n * The data sent will be passed along to the messageFromFrame implementation on your Panel class.\n */\nclass Panel extends iframeui_1.IframeUI {\n    constructor(client, config) {\n        super(client);\n        this.config = config;\n        this.hookMessages();\n        this.client.sendCommand(\"rp\" /* CommandName.RegisterPanel */, {\n            'n': this.messageActionName,\n            't': this.config.title,\n            'l': this.config.location,\n            'c': this.config.content,\n            'u': this.config.url,\n            'v': this.config.visibleAction,\n            'i': this.config.iconUrl,\n            'to': this.config.toolTip,\n            'p': this.config.persist,\n            'w': this.config.width,\n            'h': this.config.height,\n        });\n    }\n    /**\n     * Show this panel if the panel is in the rightDock and it is not already visible.\n     */\n    show() {\n        if (this.config.location == PanelLocation.RightDock) {\n            this.client.sendCommand(\"spn\" /* CommandName.ShowPanel */, { 'n': this.messageActionName });\n        }\n    }\n    /**\n     * Hide this panel if the panel is in the rightDock and it is currently visible.\n     */\n    hide() {\n        if (this.config.location == PanelLocation.RightDock) {\n            this.client.sendCommand(\"hp\" /* CommandName.HidePanel */, { 'n': this.messageActionName });\n        }\n    }\n}\nexports.Panel = Panel;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/ui/panel.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/ui/viewport.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/ui/viewport.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Viewport = void 0;\nconst checks_1 = __webpack_require__(/*! ../core/checks */ \"./node_modules/lucid-extension-sdk/core/checks.js\");\nconst fillcolor_1 = __webpack_require__(/*! ../core/properties/fillcolor */ \"./node_modules/lucid-extension-sdk/core/properties/fillcolor.js\");\nconst imagedefinition_1 = __webpack_require__(/*! ../document/imagedefinition */ \"./node_modules/lucid-extension-sdk/document/imagedefinition.js\");\nconst itemproxy_1 = __webpack_require__(/*! ../document/itemproxy */ \"./node_modules/lucid-extension-sdk/document/itemproxy.js\");\nconst pageproxy_1 = __webpack_require__(/*! ../document/pageproxy */ \"./node_modules/lucid-extension-sdk/document/pageproxy.js\");\nconst math_1 = __webpack_require__(/*! ../math */ \"./node_modules/lucid-extension-sdk/math.js\");\nclass Viewport {\n    constructor(client) {\n        this.client = client;\n    }\n    static nextHookName() {\n        return '__viewport__hook' + Viewport.nextHookId++;\n    }\n    /**\n     * @param deep If true, and groups are selected, include the contents of those groups in the array\n     * @returns An array of currently-selected items on the currently-visible page\n     */\n    getSelectedItems(deep) {\n        const ids = this.client.sendCommand(\"gs\" /* CommandName.GetSelection */, { 'd': deep });\n        return ids\n            .map((id) => this.client.getElementProxy(id))\n            .filter((proxy) => proxy instanceof itemproxy_1.ItemProxy);\n    }\n    /**\n     * Unselect all currently-selected items, and select the subset of the given items that exist on\n     * the currently-visible page.\n     * @param items\n     */\n    setSelectedItems(items) {\n        this.client.sendCommand(\"ss\" /* CommandName.SetSelection */, { 'i': items.map((i) => i.id) });\n    }\n    /**\n     * Find available space on the current page for adding new content.\n     * @param width\n     * @param height\n     * @returns a reference to the page and origin (upper-left point) of the space you can add new\n     * content of the given size to.\n     */\n    findAvailableSpace(width, height) {\n        const result = this.client.sendCommand(\"fas\" /* CommandName.FindAvailableSpace */, { 'w': width, 'h': height });\n        return {\n            page: new pageproxy_1.PageProxy(result['p'], this.client),\n            x: result['x'],\n            y: result['y'],\n        };\n    }\n    /**\n     * @returns the page currently being viewed\n     */\n    getCurrentPage() {\n        const id = this.client.sendCommand(\"gcp\" /* CommandName.GetCurrentPage */, undefined);\n        return id == null ? id : new pageproxy_1.PageProxy(id, this.client);\n    }\n    /**\n     * View the given page in the viewport\n     * @param page The page to view\n     */\n    setCurrentPage(page) {\n        this.client.sendCommand(\"scp\" /* CommandName.SetCurrentPage */, page.id);\n    }\n    /**\n     * @returns the box for the current viewport location\n     */\n    getVisibleRect() {\n        return this.client.sendCommand(\"gvr\" /* CommandName.GetVisibleRect */, undefined);\n    }\n    /**\n     * Switch to the page containing these items, if necessary, and then animate the viewport\n     * to zoom in and focus on these items.\n     * @param items The items the camera should zoom to\n     */\n    focusCameraOnItems(items) {\n        const bb = (0, math_1.combinedBoundingBox)(items.map((e) => e.getBoundingBox()));\n        if (bb && items[0]) {\n            //TODO: A reasonable max zoom level (e.g. 200%)\n            this.client.sendCommand(\"av\" /* CommandName.AnimateViewport */, {\n                'bb': (0, math_1.padBox)(bb, 80),\n                'p': items[0].getPage().id,\n            });\n        }\n    }\n    /**\n     * If {@link callback} returns false, text editing is prevented.\n     * If {@link callback} returns true, text editing continues as normal.\n     *\n     * If {@link callback} returns a {@link TextEditCompletionCallback}(/extension-sdk/#modules_ui_viewport_texteditcompletioncallback),\n     * then text editing is allowed, but that completion callback is called.\n     *\n     * when the user finishes editing that text. That completion callback may return true or false to allow or deny the edit, or\n     * also may return a replacement string to use instead of the text the user actually typed. If replacement text is provided,\n     * it will be styled as close to the original as possible, but styles that apply to only parts of the original text will be\n     * discarded.\n     *\n     * @param callback Called just before the user starts editing text.\n     * @param eager Whether to trigger the callback eagerly during text edit\n     *\n     * @returns A handle representing this hook, which can be passed to unhookTextEdit to remove this hook.\n     */\n    hookTextEdit(callback, eager) {\n        const actionName = Viewport.nextHookName();\n        this.client.registerAction(actionName, async (textHookParam) => {\n            const element = this.client.getElementProxy(textHookParam['i']);\n            if (element instanceof itemproxy_1.ItemProxy) {\n                const result = await callback(element, textHookParam['t'], textHookParam['v']);\n                if ((0, checks_1.isBoolean)(result)) {\n                    return result;\n                }\n                else {\n                    const completeName = Viewport.nextHookName();\n                    this.client.registerAction(completeName, (textCompleteParam) => {\n                        this.client.deleteAction(completeName);\n                        return result(textCompleteParam['v']);\n                    });\n                    return completeName;\n                }\n            }\n            else {\n                //Shouldn't be possible, but just in case allow text editing as normal\n                return true;\n            }\n        });\n        this.client.sendCommand(\"hte\" /* CommandName.HookTextEdit */, { 'n': actionName, 'e': !!eager });\n        return actionName;\n    }\n    /**\n     * Remove a hook set by hookTextEdit.\n     *\n     * @param handle The return value of hookTextEdit.\n     */\n    unhookTextEdit(handle) {\n        this.client.deleteAction(handle);\n        this.client.sendCommand(\"ute\" /* CommandName.UnhookTextEdit */, { 'n': handle });\n    }\n    /**\n     * @param callback Called when the user changes their selection of items\n     *\n     * @returns A handle representing this hook, which can be passed to unhookSelection to remove this hook.\n     */\n    hookSelection(callback) {\n        const actionName = Viewport.nextHookName();\n        this.client.registerAction(actionName, async (param) => {\n            const elements = param['ids']\n                .map((id) => this.client.getElementProxy(id))\n                .filter((element) => element instanceof itemproxy_1.ItemProxy);\n            callback(elements);\n        });\n        this.client.sendCommand(\"hs\" /* CommandName.HookSelection */, { 'n': actionName });\n        return actionName;\n    }\n    /**\n     * Remove a hook set by hookSelection.\n     *\n     * @param handle The return value of hookSelection.\n     */\n    unhookSelection(handle) {\n        this.client.deleteAction(handle);\n        this.client.sendCommand(\"us\" /* CommandName.UnhookSelection */, { 'n': handle });\n    }\n    /**\n     * Start an interaction of the current user dragging a new block onto the current page, exactly\n     * as if they started dragging that block out of the normal toolbox. At the time this function is\n     * called, the user's primary mouse button should be down (e.g. in a mousedown event handler).\n     *\n     * @param definition Definition of the block to create if and where the user drops it on-canvas\n     * @returns A promise resolving to a reference to the created block, if successfully dropped,\n     *  or undefined if the user cancels the drag interaction.\n     */\n    async startDraggingNewBlock(definition) {\n        var _a;\n        const properties = (_a = definition.properties) !== null && _a !== void 0 ? _a : {};\n        if (definition.fillStyle !== undefined) {\n            properties['FillColor'] = (0, fillcolor_1.serializeSimpleFill)(definition.fillStyle);\n        }\n        if (definition.lineWidth !== undefined) {\n            properties['LineWidth'] = definition.lineWidth;\n        }\n        const maybeBlockId = await this.client.sendCommand(\"sdc\" /* CommandName.StartDragBlockToCanvas */, {\n            'c': definition.className,\n            'sz': {\n                'w': definition.boundingBox.w,\n                'h': definition.boundingBox.h,\n            },\n            'p': properties,\n            's': definition.stencil,\n        });\n        return maybeBlockId ? this.client.getBlockProxy(maybeBlockId) : undefined;\n    }\n    /**\n     * Start an interaction of the current user dragging a new image onto the current page, exactly\n     * as if they started dragging that image out of the normal toolbox. At the time this function is\n     * called, the user's primary mouse button should be down (e.g. in a mousedown event handler).\n     *\n     * @param definition Definition of the image to create if and where the user drops it on-canvas\n     * @returns A promise resolving to a reference to the created image, if successfully dropped,\n     *  or undefined if the user cancels the drag interaction.\n     */\n    async startDraggingNewImage(definition) {\n        await this.client.loadBlockClasses(['UserImage2Block']);\n        return await this.startDraggingNewBlock((0, imagedefinition_1.imageToBlockDefinition)(definition));\n    }\n    /**\n     * If startDraggingNewBlock has been called, and the drag-new-block interaction is still active,\n     * cancel that interaction.\n     */\n    cancelDraggingNewBlock() {\n        this.client.sendCommand(\"cdc\" /* CommandName.CancelDragBlockToCanvas */, undefined);\n    }\n    /**\n     * If startDraggingNewImage has been called, and the drag-new-image interaction is still active,\n     * cancel that interaction.\n     */\n    cancelDraggingNewImage() {\n        this.cancelDraggingNewBlock();\n    }\n    /**\n     * After calling startDraggingNewBlock, call this to simulate the user moving the mouse at the\n     * given location within the top-level browser window.\n     *\n     * This has no effect if the drag-new-block interaction is not active.\n     *\n     * To convert a position in a Panel's iframe to a position in the top-level browser window,\n     * add the IframeUI.framePosition.\n     */\n    dragPointerMove(x, y) {\n        this.client.sendCommand(\"dpm\" /* CommandName.DragPointerMove */, { x, y });\n    }\n    /**\n     * After calling startDraggingNewBlock, call this to simulate the user releasing the mouse\n     * button at the given location within the top-level browser window.\n     *\n     * This has no effect if the drag-new-block interaction is not active.\n     *\n     * To convert a position in a Panel's iframe to a position in the top-level browser window,\n     * add the IframeUI.framePosition.\n     */\n    dragPointerUp(x, y) {\n        this.client.sendCommand(\"dpu\" /* CommandName.DragPointerUp */, { x, y });\n    }\n}\nexports.Viewport = Viewport;\nViewport.nextHookId = 0;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/ui/viewport.js?");

/***/ }),

/***/ "./node_modules/lucid-extension-sdk/user/userproxy.js":
/*!************************************************************!*\
  !*** ./node_modules/lucid-extension-sdk/user/userproxy.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UserProxy = void 0;\n/**\n * The UserProxy class gives access to the current user on the current Lucid document.\n */\nclass UserProxy {\n    constructor(client) {\n        this.client = client;\n        this.id = this.client.sendCommand(\"guid\" /* CommandName.GetUserId */, undefined);\n    }\n    /**\n     * @returns the permission the user has on the current document.\n     */\n    getAccessPermssionOnDocument() {\n        return this.client.sendCommand(\"gdap\" /* CommandName.GetDocumentAccessPermission */, undefined);\n    }\n}\nexports.UserProxy = UserProxy;\n\n\n//# sourceURL=webpack:///./node_modules/lucid-extension-sdk/user/userproxy.js?");

/***/ }),

/***/ "./src/extension.ts":
/*!**************************!*\
  !*** ./src/extension.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RightPanel = void 0;\nconst lucid_extension_sdk_1 = __webpack_require__(/*! lucid-extension-sdk */ \"./node_modules/lucid-extension-sdk/index.js\");\nconst client = new lucid_extension_sdk_1.EditorClient();\nclass RightPanel extends lucid_extension_sdk_1.Panel {\n    constructor(client) {\n        super(client, {\n            title: 'Spotify',\n            url: 'http://localhost:3000',\n            location: lucid_extension_sdk_1.PanelLocation.RightDock,\n            iconUrl: RightPanel.icon,\n        });\n    }\n    async messageFromFrame(message) {\n        if (message === 'login') {\n            console.log(\"extension hyoooooooooooo\");\n            this.sendMessage({\n                token: await client.getOAuthToken('spotify'),\n            });\n        }\n    }\n}\nexports.RightPanel = RightPanel;\nRightPanel.icon = 'https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Spotify_icon.svg/1982px-Spotify_icon.svg.png';\nconst rightPanel = new RightPanel(client);\n\n\n//# sourceURL=webpack:///./src/extension.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/extension.ts");
/******/ 	
/******/ })()
;